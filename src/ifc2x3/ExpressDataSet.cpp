/*
//////////////////////////////////
// This File has been generated //
// by Expressik light generator //
//  Powered by : Eve CSTB       //
//////////////////////////////////

 * *************************************************************************
 *                                                                         *
 *     STEP Early Classes C++                                              *
 *                                                                         *
 *     Copyright (C) 2009 CSTB                                             *
 *                                                                         *
 *                                                                         *
 *   For further information please contact                                *
 *                                                                         *
 *         eve@cstb.fr                                                     *
 *   or                                                                    *
 *         Mod-Eve, CSTB                                                   *
 *         290, route des Lucioles                                         *
 *         BP 209                                                          *
 *         06904 Sophia Antipolis, France                                  *
 *                                                                         *
 ***************************************************************************
*/

#include "ifc2x3/ExpressDataSet.h"

#include "ifc2x3/CopyOp.h"
#include "ifc2x3/Ifc2DCompositeCurve.h"
#include "ifc2x3/IfcActionRequest.h"
#include "ifc2x3/IfcActor.h"
#include "ifc2x3/IfcActorRole.h"
#include "ifc2x3/IfcActuatorType.h"
#include "ifc2x3/IfcAirTerminalBoxType.h"
#include "ifc2x3/IfcAirTerminalType.h"
#include "ifc2x3/IfcAirToAirHeatRecoveryType.h"
#include "ifc2x3/IfcAlarmType.h"
#include "ifc2x3/IfcAngularDimension.h"
#include "ifc2x3/IfcAnnotation.h"
#include "ifc2x3/IfcAnnotationCurveOccurrence.h"
#include "ifc2x3/IfcAnnotationFillArea.h"
#include "ifc2x3/IfcAnnotationFillAreaOccurrence.h"
#include "ifc2x3/IfcAnnotationSurface.h"
#include "ifc2x3/IfcAnnotationSurfaceOccurrence.h"
#include "ifc2x3/IfcAnnotationSymbolOccurrence.h"
#include "ifc2x3/IfcAnnotationTextOccurrence.h"
#include "ifc2x3/IfcApplication.h"
#include "ifc2x3/IfcAppliedValueRelationship.h"
#include "ifc2x3/IfcApproval.h"
#include "ifc2x3/IfcApprovalActorRelationship.h"
#include "ifc2x3/IfcApprovalPropertyRelationship.h"
#include "ifc2x3/IfcApprovalRelationship.h"
#include "ifc2x3/IfcArbitraryClosedProfileDef.h"
#include "ifc2x3/IfcArbitraryOpenProfileDef.h"
#include "ifc2x3/IfcArbitraryProfileDefWithVoids.h"
#include "ifc2x3/IfcAsset.h"
#include "ifc2x3/IfcAsymmetricIShapeProfileDef.h"
#include "ifc2x3/IfcAxis1Placement.h"
#include "ifc2x3/IfcAxis2Placement2D.h"
#include "ifc2x3/IfcAxis2Placement3D.h"
#include "ifc2x3/IfcBeam.h"
#include "ifc2x3/IfcBeamType.h"
#include "ifc2x3/IfcBezierCurve.h"
#include "ifc2x3/IfcBlobTexture.h"
#include "ifc2x3/IfcBlock.h"
#include "ifc2x3/IfcBoilerType.h"
#include "ifc2x3/IfcBooleanClippingResult.h"
#include "ifc2x3/IfcBooleanResult.h"
#include "ifc2x3/IfcBoundaryEdgeCondition.h"
#include "ifc2x3/IfcBoundaryFaceCondition.h"
#include "ifc2x3/IfcBoundaryNodeCondition.h"
#include "ifc2x3/IfcBoundaryNodeConditionWarping.h"
#include "ifc2x3/IfcBoundedSurface.h"
#include "ifc2x3/IfcBoundingBox.h"
#include "ifc2x3/IfcBoxedHalfSpace.h"
#include "ifc2x3/IfcBuilding.h"
#include "ifc2x3/IfcBuildingElementPart.h"
#include "ifc2x3/IfcBuildingElementProxy.h"
#include "ifc2x3/IfcBuildingElementProxyType.h"
#include "ifc2x3/IfcBuildingStorey.h"
#include "ifc2x3/IfcCShapeProfileDef.h"
#include "ifc2x3/IfcCableCarrierFittingType.h"
#include "ifc2x3/IfcCableCarrierSegmentType.h"
#include "ifc2x3/IfcCableSegmentType.h"
#include "ifc2x3/IfcCalendarDate.h"
#include "ifc2x3/IfcCartesianPoint.h"
#include "ifc2x3/IfcCartesianTransformationOperator2D.h"
#include "ifc2x3/IfcCartesianTransformationOperator2DnonUniform.h"
#include "ifc2x3/IfcCartesianTransformationOperator3D.h"
#include "ifc2x3/IfcCartesianTransformationOperator3DnonUniform.h"
#include "ifc2x3/IfcCenterLineProfileDef.h"
#include "ifc2x3/IfcChamferEdgeFeature.h"
#include "ifc2x3/IfcChillerType.h"
#include "ifc2x3/IfcCircle.h"
#include "ifc2x3/IfcCircleHollowProfileDef.h"
#include "ifc2x3/IfcCircleProfileDef.h"
#include "ifc2x3/IfcClassification.h"
#include "ifc2x3/IfcClassificationItem.h"
#include "ifc2x3/IfcClassificationItemRelationship.h"
#include "ifc2x3/IfcClassificationNotation.h"
#include "ifc2x3/IfcClassificationNotationFacet.h"
#include "ifc2x3/IfcClassificationReference.h"
#include "ifc2x3/IfcClosedShell.h"
#include "ifc2x3/IfcCoilType.h"
#include "ifc2x3/IfcColourRgb.h"
#include "ifc2x3/IfcColumn.h"
#include "ifc2x3/IfcColumnType.h"
#include "ifc2x3/IfcComplexProperty.h"
#include "ifc2x3/IfcCompositeCurve.h"
#include "ifc2x3/IfcCompositeCurveSegment.h"
#include "ifc2x3/IfcCompositeProfileDef.h"
#include "ifc2x3/IfcCompressorType.h"
#include "ifc2x3/IfcCondenserType.h"
#include "ifc2x3/IfcCondition.h"
#include "ifc2x3/IfcConditionCriterion.h"
#include "ifc2x3/IfcConnectedFaceSet.h"
#include "ifc2x3/IfcConnectionCurveGeometry.h"
#include "ifc2x3/IfcConnectionPointEccentricity.h"
#include "ifc2x3/IfcConnectionPointGeometry.h"
#include "ifc2x3/IfcConnectionPortGeometry.h"
#include "ifc2x3/IfcConnectionSurfaceGeometry.h"
#include "ifc2x3/IfcConstraintAggregationRelationship.h"
#include "ifc2x3/IfcConstraintClassificationRelationship.h"
#include "ifc2x3/IfcConstraintRelationship.h"
#include "ifc2x3/IfcConstructionEquipmentResource.h"
#include "ifc2x3/IfcConstructionMaterialResource.h"
#include "ifc2x3/IfcConstructionProductResource.h"
#include "ifc2x3/IfcContextDependentUnit.h"
#include "ifc2x3/IfcControllerType.h"
#include "ifc2x3/IfcConversionBasedUnit.h"
#include "ifc2x3/IfcCooledBeamType.h"
#include "ifc2x3/IfcCoolingTowerType.h"
#include "ifc2x3/IfcCoordinatedUniversalTimeOffset.h"
#include "ifc2x3/IfcCostItem.h"
#include "ifc2x3/IfcCostSchedule.h"
#include "ifc2x3/IfcCostValue.h"
#include "ifc2x3/IfcCovering.h"
#include "ifc2x3/IfcCoveringType.h"
#include "ifc2x3/IfcCraneRailAShapeProfileDef.h"
#include "ifc2x3/IfcCraneRailFShapeProfileDef.h"
#include "ifc2x3/IfcCrewResource.h"
#include "ifc2x3/IfcCsgSolid.h"
#include "ifc2x3/IfcCurrencyRelationship.h"
#include "ifc2x3/IfcCurtainWall.h"
#include "ifc2x3/IfcCurtainWallType.h"
#include "ifc2x3/IfcCurveBoundedPlane.h"
#include "ifc2x3/IfcCurveStyle.h"
#include "ifc2x3/IfcCurveStyleFont.h"
#include "ifc2x3/IfcCurveStyleFontAndScaling.h"
#include "ifc2x3/IfcCurveStyleFontPattern.h"
#include "ifc2x3/IfcDamperType.h"
#include "ifc2x3/IfcDateAndTime.h"
#include "ifc2x3/IfcDefinedSymbol.h"
#include "ifc2x3/IfcDerivedProfileDef.h"
#include "ifc2x3/IfcDerivedUnit.h"
#include "ifc2x3/IfcDerivedUnitElement.h"
#include "ifc2x3/IfcDiameterDimension.h"
#include "ifc2x3/IfcDimensionCalloutRelationship.h"
#include "ifc2x3/IfcDimensionCurve.h"
#include "ifc2x3/IfcDimensionCurveDirectedCallout.h"
#include "ifc2x3/IfcDimensionCurveTerminator.h"
#include "ifc2x3/IfcDimensionPair.h"
#include "ifc2x3/IfcDimensionalExponents.h"
#include "ifc2x3/IfcDirection.h"
#include "ifc2x3/IfcDiscreteAccessory.h"
#include "ifc2x3/IfcDiscreteAccessoryType.h"
#include "ifc2x3/IfcDistributionChamberElement.h"
#include "ifc2x3/IfcDistributionChamberElementType.h"
#include "ifc2x3/IfcDistributionControlElement.h"
#include "ifc2x3/IfcDistributionElement.h"
#include "ifc2x3/IfcDistributionElementType.h"
#include "ifc2x3/IfcDistributionFlowElement.h"
#include "ifc2x3/IfcDistributionPort.h"
#include "ifc2x3/IfcDocumentElectronicFormat.h"
#include "ifc2x3/IfcDocumentInformation.h"
#include "ifc2x3/IfcDocumentInformationRelationship.h"
#include "ifc2x3/IfcDocumentReference.h"
#include "ifc2x3/IfcDoor.h"
#include "ifc2x3/IfcDoorLiningProperties.h"
#include "ifc2x3/IfcDoorPanelProperties.h"
#include "ifc2x3/IfcDoorStyle.h"
#include "ifc2x3/IfcDraughtingCallout.h"
#include "ifc2x3/IfcDraughtingCalloutRelationship.h"
#include "ifc2x3/IfcDraughtingPreDefinedColour.h"
#include "ifc2x3/IfcDraughtingPreDefinedCurveFont.h"
#include "ifc2x3/IfcDraughtingPreDefinedTextFont.h"
#include "ifc2x3/IfcDuctFittingType.h"
#include "ifc2x3/IfcDuctSegmentType.h"
#include "ifc2x3/IfcDuctSilencerType.h"
#include "ifc2x3/IfcEdge.h"
#include "ifc2x3/IfcEdgeCurve.h"
#include "ifc2x3/IfcEdgeLoop.h"
#include "ifc2x3/IfcElectricApplianceType.h"
#include "ifc2x3/IfcElectricDistributionPoint.h"
#include "ifc2x3/IfcElectricFlowStorageDeviceType.h"
#include "ifc2x3/IfcElectricGeneratorType.h"
#include "ifc2x3/IfcElectricHeaterType.h"
#include "ifc2x3/IfcElectricMotorType.h"
#include "ifc2x3/IfcElectricTimeControlType.h"
#include "ifc2x3/IfcElectricalBaseProperties.h"
#include "ifc2x3/IfcElectricalCircuit.h"
#include "ifc2x3/IfcElectricalElement.h"
#include "ifc2x3/IfcElementAssembly.h"
#include "ifc2x3/IfcElementQuantity.h"
#include "ifc2x3/IfcEllipse.h"
#include "ifc2x3/IfcEllipseProfileDef.h"
#include "ifc2x3/IfcEnergyConversionDevice.h"
#include "ifc2x3/IfcEnergyProperties.h"
#include "ifc2x3/IfcEnvironmentalImpactValue.h"
#include "ifc2x3/IfcEquipmentElement.h"
#include "ifc2x3/IfcEquipmentStandard.h"
#include "ifc2x3/IfcEvaporativeCoolerType.h"
#include "ifc2x3/IfcEvaporatorType.h"
#include "ifc2x3/IfcExtendedMaterialProperties.h"
#include "ifc2x3/IfcExternallyDefinedHatchStyle.h"
#include "ifc2x3/IfcExternallyDefinedSurfaceStyle.h"
#include "ifc2x3/IfcExternallyDefinedSymbol.h"
#include "ifc2x3/IfcExternallyDefinedTextFont.h"
#include "ifc2x3/IfcExtrudedAreaSolid.h"
#include "ifc2x3/IfcFace.h"
#include "ifc2x3/IfcFaceBasedSurfaceModel.h"
#include "ifc2x3/IfcFaceBound.h"
#include "ifc2x3/IfcFaceOuterBound.h"
#include "ifc2x3/IfcFaceSurface.h"
#include "ifc2x3/IfcFacetedBrep.h"
#include "ifc2x3/IfcFacetedBrepWithVoids.h"
#include "ifc2x3/IfcFailureConnectionCondition.h"
#include "ifc2x3/IfcFanType.h"
#include "ifc2x3/IfcFastener.h"
#include "ifc2x3/IfcFastenerType.h"
#include "ifc2x3/IfcFillAreaStyle.h"
#include "ifc2x3/IfcFillAreaStyleHatching.h"
#include "ifc2x3/IfcFillAreaStyleTileSymbolWithStyle.h"
#include "ifc2x3/IfcFillAreaStyleTiles.h"
#include "ifc2x3/IfcFilterType.h"
#include "ifc2x3/IfcFireSuppressionTerminalType.h"
#include "ifc2x3/IfcFlowController.h"
#include "ifc2x3/IfcFlowFitting.h"
#include "ifc2x3/IfcFlowInstrumentType.h"
#include "ifc2x3/IfcFlowMeterType.h"
#include "ifc2x3/IfcFlowMovingDevice.h"
#include "ifc2x3/IfcFlowSegment.h"
#include "ifc2x3/IfcFlowStorageDevice.h"
#include "ifc2x3/IfcFlowTerminal.h"
#include "ifc2x3/IfcFlowTreatmentDevice.h"
#include "ifc2x3/IfcFluidFlowProperties.h"
#include "ifc2x3/IfcFooting.h"
#include "ifc2x3/IfcFuelProperties.h"
#include "ifc2x3/IfcFurnishingElement.h"
#include "ifc2x3/IfcFurnishingElementType.h"
#include "ifc2x3/IfcFurnitureStandard.h"
#include "ifc2x3/IfcFurnitureType.h"
#include "ifc2x3/IfcGasTerminalType.h"
#include "ifc2x3/IfcGeneralMaterialProperties.h"
#include "ifc2x3/IfcGeneralProfileProperties.h"
#include "ifc2x3/IfcGeometricCurveSet.h"
#include "ifc2x3/IfcGeometricRepresentationContext.h"
#include "ifc2x3/IfcGeometricRepresentationSubContext.h"
#include "ifc2x3/IfcGeometricSet.h"
#include "ifc2x3/IfcGrid.h"
#include "ifc2x3/IfcGridAxis.h"
#include "ifc2x3/IfcGridPlacement.h"
#include "ifc2x3/IfcGroup.h"
#include "ifc2x3/IfcHalfSpaceSolid.h"
#include "ifc2x3/IfcHeatExchangerType.h"
#include "ifc2x3/IfcHumidifierType.h"
#include "ifc2x3/IfcHygroscopicMaterialProperties.h"
#include "ifc2x3/IfcIShapeProfileDef.h"
#include "ifc2x3/IfcImageTexture.h"
#include "ifc2x3/IfcInventory.h"
#include "ifc2x3/IfcIrregularTimeSeries.h"
#include "ifc2x3/IfcIrregularTimeSeriesValue.h"
#include "ifc2x3/IfcJunctionBoxType.h"
#include "ifc2x3/IfcLShapeProfileDef.h"
#include "ifc2x3/IfcLaborResource.h"
#include "ifc2x3/IfcLampType.h"
#include "ifc2x3/IfcLibraryInformation.h"
#include "ifc2x3/IfcLibraryReference.h"
#include "ifc2x3/IfcLightDistributionData.h"
#include "ifc2x3/IfcLightFixtureType.h"
#include "ifc2x3/IfcLightIntensityDistribution.h"
#include "ifc2x3/IfcLightSourceAmbient.h"
#include "ifc2x3/IfcLightSourceDirectional.h"
#include "ifc2x3/IfcLightSourceGoniometric.h"
#include "ifc2x3/IfcLightSourcePositional.h"
#include "ifc2x3/IfcLightSourceSpot.h"
#include "ifc2x3/IfcLine.h"
#include "ifc2x3/IfcLinearDimension.h"
#include "ifc2x3/IfcLocalPlacement.h"
#include "ifc2x3/IfcLocalTime.h"
#include "ifc2x3/IfcLoop.h"
#include "ifc2x3/IfcMappedItem.h"
#include "ifc2x3/IfcMaterial.h"
#include "ifc2x3/IfcMaterialClassificationRelationship.h"
#include "ifc2x3/IfcMaterialDefinitionRepresentation.h"
#include "ifc2x3/IfcMaterialLayer.h"
#include "ifc2x3/IfcMaterialLayerSet.h"
#include "ifc2x3/IfcMaterialLayerSetUsage.h"
#include "ifc2x3/IfcMaterialList.h"
#include "ifc2x3/IfcMeasureWithUnit.h"
#include "ifc2x3/IfcMechanicalConcreteMaterialProperties.h"
#include "ifc2x3/IfcMechanicalFastener.h"
#include "ifc2x3/IfcMechanicalFastenerType.h"
#include "ifc2x3/IfcMechanicalMaterialProperties.h"
#include "ifc2x3/IfcMechanicalSteelMaterialProperties.h"
#include "ifc2x3/IfcMember.h"
#include "ifc2x3/IfcMemberType.h"
#include "ifc2x3/IfcMetric.h"
#include "ifc2x3/IfcMonetaryUnit.h"
#include "ifc2x3/IfcMotorConnectionType.h"
#include "ifc2x3/IfcMove.h"
#include "ifc2x3/IfcObjective.h"
#include "ifc2x3/IfcOccupant.h"
#include "ifc2x3/IfcOffsetCurve2D.h"
#include "ifc2x3/IfcOffsetCurve3D.h"
#include "ifc2x3/IfcOneDirectionRepeatFactor.h"
#include "ifc2x3/IfcOpenShell.h"
#include "ifc2x3/IfcOpeningElement.h"
#include "ifc2x3/IfcOpticalMaterialProperties.h"
#include "ifc2x3/IfcOrderAction.h"
#include "ifc2x3/IfcOrganization.h"
#include "ifc2x3/IfcOrganizationRelationship.h"
#include "ifc2x3/IfcOrientedEdge.h"
#include "ifc2x3/IfcOutletType.h"
#include "ifc2x3/IfcOwnerHistory.h"
#include "ifc2x3/IfcPath.h"
#include "ifc2x3/IfcPerformanceHistory.h"
#include "ifc2x3/IfcPermeableCoveringProperties.h"
#include "ifc2x3/IfcPermit.h"
#include "ifc2x3/IfcPerson.h"
#include "ifc2x3/IfcPersonAndOrganization.h"
#include "ifc2x3/IfcPhysicalComplexQuantity.h"
#include "ifc2x3/IfcPile.h"
#include "ifc2x3/IfcPipeFittingType.h"
#include "ifc2x3/IfcPipeSegmentType.h"
#include "ifc2x3/IfcPixelTexture.h"
#include "ifc2x3/IfcPlanarBox.h"
#include "ifc2x3/IfcPlanarExtent.h"
#include "ifc2x3/IfcPlane.h"
#include "ifc2x3/IfcPlate.h"
#include "ifc2x3/IfcPlateType.h"
#include "ifc2x3/IfcPointOnCurve.h"
#include "ifc2x3/IfcPointOnSurface.h"
#include "ifc2x3/IfcPolyLoop.h"
#include "ifc2x3/IfcPolygonalBoundedHalfSpace.h"
#include "ifc2x3/IfcPolyline.h"
#include "ifc2x3/IfcPostalAddress.h"
#include "ifc2x3/IfcPreDefinedDimensionSymbol.h"
#include "ifc2x3/IfcPreDefinedPointMarkerSymbol.h"
#include "ifc2x3/IfcPreDefinedTerminatorSymbol.h"
#include "ifc2x3/IfcPresentationLayerAssignment.h"
#include "ifc2x3/IfcPresentationLayerWithStyle.h"
#include "ifc2x3/IfcPresentationStyleAssignment.h"
#include "ifc2x3/IfcProcedure.h"
#include "ifc2x3/IfcProductDefinitionShape.h"
#include "ifc2x3/IfcProductRepresentation.h"
#include "ifc2x3/IfcProductsOfCombustionProperties.h"
#include "ifc2x3/IfcProject.h"
#include "ifc2x3/IfcProjectOrder.h"
#include "ifc2x3/IfcProjectOrderRecord.h"
#include "ifc2x3/IfcProjectionCurve.h"
#include "ifc2x3/IfcProjectionElement.h"
#include "ifc2x3/IfcPropertyBoundedValue.h"
#include "ifc2x3/IfcPropertyConstraintRelationship.h"
#include "ifc2x3/IfcPropertyDependencyRelationship.h"
#include "ifc2x3/IfcPropertyEnumeratedValue.h"
#include "ifc2x3/IfcPropertyEnumeration.h"
#include "ifc2x3/IfcPropertyListValue.h"
#include "ifc2x3/IfcPropertyReferenceValue.h"
#include "ifc2x3/IfcPropertySet.h"
#include "ifc2x3/IfcPropertySingleValue.h"
#include "ifc2x3/IfcPropertyTableValue.h"
#include "ifc2x3/IfcProtectiveDeviceType.h"
#include "ifc2x3/IfcProxy.h"
#include "ifc2x3/IfcPumpType.h"
#include "ifc2x3/IfcQuantityArea.h"
#include "ifc2x3/IfcQuantityCount.h"
#include "ifc2x3/IfcQuantityLength.h"
#include "ifc2x3/IfcQuantityTime.h"
#include "ifc2x3/IfcQuantityVolume.h"
#include "ifc2x3/IfcQuantityWeight.h"
#include "ifc2x3/IfcRadiusDimension.h"
#include "ifc2x3/IfcRailing.h"
#include "ifc2x3/IfcRailingType.h"
#include "ifc2x3/IfcRamp.h"
#include "ifc2x3/IfcRampFlight.h"
#include "ifc2x3/IfcRampFlightType.h"
#include "ifc2x3/IfcRationalBezierCurve.h"
#include "ifc2x3/IfcRectangleHollowProfileDef.h"
#include "ifc2x3/IfcRectangleProfileDef.h"
#include "ifc2x3/IfcRectangularPyramid.h"
#include "ifc2x3/IfcRectangularTrimmedSurface.h"
#include "ifc2x3/IfcReferencesValueDocument.h"
#include "ifc2x3/IfcRegularTimeSeries.h"
#include "ifc2x3/IfcReinforcementBarProperties.h"
#include "ifc2x3/IfcReinforcementDefinitionProperties.h"
#include "ifc2x3/IfcReinforcingBar.h"
#include "ifc2x3/IfcReinforcingMesh.h"
#include "ifc2x3/IfcRelAggregates.h"
#include "ifc2x3/IfcRelAssignsTasks.h"
#include "ifc2x3/IfcRelAssignsToActor.h"
#include "ifc2x3/IfcRelAssignsToControl.h"
#include "ifc2x3/IfcRelAssignsToGroup.h"
#include "ifc2x3/IfcRelAssignsToProcess.h"
#include "ifc2x3/IfcRelAssignsToProduct.h"
#include "ifc2x3/IfcRelAssignsToProjectOrder.h"
#include "ifc2x3/IfcRelAssignsToResource.h"
#include "ifc2x3/IfcRelAssociates.h"
#include "ifc2x3/IfcRelAssociatesAppliedValue.h"
#include "ifc2x3/IfcRelAssociatesApproval.h"
#include "ifc2x3/IfcRelAssociatesClassification.h"
#include "ifc2x3/IfcRelAssociatesConstraint.h"
#include "ifc2x3/IfcRelAssociatesDocument.h"
#include "ifc2x3/IfcRelAssociatesLibrary.h"
#include "ifc2x3/IfcRelAssociatesMaterial.h"
#include "ifc2x3/IfcRelAssociatesProfileProperties.h"
#include "ifc2x3/IfcRelConnectsElements.h"
#include "ifc2x3/IfcRelConnectsPathElements.h"
#include "ifc2x3/IfcRelConnectsPortToElement.h"
#include "ifc2x3/IfcRelConnectsPorts.h"
#include "ifc2x3/IfcRelConnectsStructuralActivity.h"
#include "ifc2x3/IfcRelConnectsStructuralElement.h"
#include "ifc2x3/IfcRelConnectsStructuralMember.h"
#include "ifc2x3/IfcRelConnectsWithEccentricity.h"
#include "ifc2x3/IfcRelConnectsWithRealizingElements.h"
#include "ifc2x3/IfcRelContainedInSpatialStructure.h"
#include "ifc2x3/IfcRelCoversBldgElements.h"
#include "ifc2x3/IfcRelCoversSpaces.h"
#include "ifc2x3/IfcRelDefinesByProperties.h"
#include "ifc2x3/IfcRelDefinesByType.h"
#include "ifc2x3/IfcRelFillsElement.h"
#include "ifc2x3/IfcRelFlowControlElements.h"
#include "ifc2x3/IfcRelInteractionRequirements.h"
#include "ifc2x3/IfcRelNests.h"
#include "ifc2x3/IfcRelOccupiesSpaces.h"
#include "ifc2x3/IfcRelOverridesProperties.h"
#include "ifc2x3/IfcRelProjectsElement.h"
#include "ifc2x3/IfcRelReferencedInSpatialStructure.h"
#include "ifc2x3/IfcRelSchedulesCostItems.h"
#include "ifc2x3/IfcRelSequence.h"
#include "ifc2x3/IfcRelServicesBuildings.h"
#include "ifc2x3/IfcRelSpaceBoundary.h"
#include "ifc2x3/IfcRelVoidsElement.h"
#include "ifc2x3/IfcRelaxation.h"
#include "ifc2x3/IfcRepresentation.h"
#include "ifc2x3/IfcRepresentationContext.h"
#include "ifc2x3/IfcRepresentationMap.h"
#include "ifc2x3/IfcRevolvedAreaSolid.h"
#include "ifc2x3/IfcRibPlateProfileProperties.h"
#include "ifc2x3/IfcRightCircularCone.h"
#include "ifc2x3/IfcRightCircularCylinder.h"
#include "ifc2x3/IfcRoof.h"
#include "ifc2x3/IfcRoundedEdgeFeature.h"
#include "ifc2x3/IfcRoundedRectangleProfileDef.h"
#include "ifc2x3/IfcSIUnit.h"
#include "ifc2x3/IfcSanitaryTerminalType.h"
#include "ifc2x3/IfcScheduleTimeControl.h"
#include "ifc2x3/IfcSectionProperties.h"
#include "ifc2x3/IfcSectionReinforcementProperties.h"
#include "ifc2x3/IfcSectionedSpine.h"
#include "ifc2x3/IfcSensorType.h"
#include "ifc2x3/IfcServiceLife.h"
#include "ifc2x3/IfcServiceLifeFactor.h"
#include "ifc2x3/IfcShapeAspect.h"
#include "ifc2x3/IfcShapeRepresentation.h"
#include "ifc2x3/IfcShellBasedSurfaceModel.h"
#include "ifc2x3/IfcSite.h"
#include "ifc2x3/IfcSlab.h"
#include "ifc2x3/IfcSlabType.h"
#include "ifc2x3/IfcSlippageConnectionCondition.h"
#include "ifc2x3/IfcSoundProperties.h"
#include "ifc2x3/IfcSoundValue.h"
#include "ifc2x3/IfcSpace.h"
#include "ifc2x3/IfcSpaceHeaterType.h"
#include "ifc2x3/IfcSpaceProgram.h"
#include "ifc2x3/IfcSpaceThermalLoadProperties.h"
#include "ifc2x3/IfcSpaceType.h"
#include "ifc2x3/IfcSphere.h"
#include "ifc2x3/IfcStackTerminalType.h"
#include "ifc2x3/IfcStair.h"
#include "ifc2x3/IfcStairFlight.h"
#include "ifc2x3/IfcStairFlightType.h"
#include "ifc2x3/IfcStructuralAnalysisModel.h"
#include "ifc2x3/IfcStructuralCurveConnection.h"
#include "ifc2x3/IfcStructuralCurveMember.h"
#include "ifc2x3/IfcStructuralCurveMemberVarying.h"
#include "ifc2x3/IfcStructuralLinearAction.h"
#include "ifc2x3/IfcStructuralLinearActionVarying.h"
#include "ifc2x3/IfcStructuralLoadGroup.h"
#include "ifc2x3/IfcStructuralLoadLinearForce.h"
#include "ifc2x3/IfcStructuralLoadPlanarForce.h"
#include "ifc2x3/IfcStructuralLoadSingleDisplacement.h"
#include "ifc2x3/IfcStructuralLoadSingleDisplacementDistortion.h"
#include "ifc2x3/IfcStructuralLoadSingleForce.h"
#include "ifc2x3/IfcStructuralLoadSingleForceWarping.h"
#include "ifc2x3/IfcStructuralLoadTemperature.h"
#include "ifc2x3/IfcStructuralPlanarAction.h"
#include "ifc2x3/IfcStructuralPlanarActionVarying.h"
#include "ifc2x3/IfcStructuralPointAction.h"
#include "ifc2x3/IfcStructuralPointConnection.h"
#include "ifc2x3/IfcStructuralPointReaction.h"
#include "ifc2x3/IfcStructuralProfileProperties.h"
#include "ifc2x3/IfcStructuralResultGroup.h"
#include "ifc2x3/IfcStructuralSteelProfileProperties.h"
#include "ifc2x3/IfcStructuralSurfaceConnection.h"
#include "ifc2x3/IfcStructuralSurfaceMember.h"
#include "ifc2x3/IfcStructuralSurfaceMemberVarying.h"
#include "ifc2x3/IfcStructuredDimensionCallout.h"
#include "ifc2x3/IfcStyledItem.h"
#include "ifc2x3/IfcStyledRepresentation.h"
#include "ifc2x3/IfcSubContractResource.h"
#include "ifc2x3/IfcSubedge.h"
#include "ifc2x3/IfcSurfaceCurveSweptAreaSolid.h"
#include "ifc2x3/IfcSurfaceOfLinearExtrusion.h"
#include "ifc2x3/IfcSurfaceOfRevolution.h"
#include "ifc2x3/IfcSurfaceStyle.h"
#include "ifc2x3/IfcSurfaceStyleLighting.h"
#include "ifc2x3/IfcSurfaceStyleRefraction.h"
#include "ifc2x3/IfcSurfaceStyleRendering.h"
#include "ifc2x3/IfcSurfaceStyleShading.h"
#include "ifc2x3/IfcSurfaceStyleWithTextures.h"
#include "ifc2x3/IfcSweptDiskSolid.h"
#include "ifc2x3/IfcSwitchingDeviceType.h"
#include "ifc2x3/IfcSymbolStyle.h"
#include "ifc2x3/IfcSystem.h"
#include "ifc2x3/IfcSystemFurnitureElementType.h"
#include "ifc2x3/IfcTShapeProfileDef.h"
#include "ifc2x3/IfcTable.h"
#include "ifc2x3/IfcTableRow.h"
#include "ifc2x3/IfcTankType.h"
#include "ifc2x3/IfcTask.h"
#include "ifc2x3/IfcTelecomAddress.h"
#include "ifc2x3/IfcTendon.h"
#include "ifc2x3/IfcTendonAnchor.h"
#include "ifc2x3/IfcTerminatorSymbol.h"
#include "ifc2x3/IfcTextLiteral.h"
#include "ifc2x3/IfcTextLiteralWithExtent.h"
#include "ifc2x3/IfcTextStyle.h"
#include "ifc2x3/IfcTextStyleFontModel.h"
#include "ifc2x3/IfcTextStyleForDefinedFont.h"
#include "ifc2x3/IfcTextStyleTextModel.h"
#include "ifc2x3/IfcTextStyleWithBoxCharacteristics.h"
#include "ifc2x3/IfcTextureCoordinateGenerator.h"
#include "ifc2x3/IfcTextureMap.h"
#include "ifc2x3/IfcTextureVertex.h"
#include "ifc2x3/IfcThermalMaterialProperties.h"
#include "ifc2x3/IfcTimeSeriesReferenceRelationship.h"
#include "ifc2x3/IfcTimeSeriesSchedule.h"
#include "ifc2x3/IfcTimeSeriesValue.h"
#include "ifc2x3/IfcTopologyRepresentation.h"
#include "ifc2x3/IfcTransformerType.h"
#include "ifc2x3/IfcTransportElement.h"
#include "ifc2x3/IfcTransportElementType.h"
#include "ifc2x3/IfcTrapeziumProfileDef.h"
#include "ifc2x3/IfcTrimmedCurve.h"
#include "ifc2x3/IfcTubeBundleType.h"
#include "ifc2x3/IfcTwoDirectionRepeatFactor.h"
#include "ifc2x3/IfcTypeObject.h"
#include "ifc2x3/IfcTypeProduct.h"
#include "ifc2x3/IfcUShapeProfileDef.h"
#include "ifc2x3/IfcUnitAssignment.h"
#include "ifc2x3/IfcUnitaryEquipmentType.h"
#include "ifc2x3/IfcValveType.h"
#include "ifc2x3/IfcVector.h"
#include "ifc2x3/IfcVertex.h"
#include "ifc2x3/IfcVertexBasedTextureMap.h"
#include "ifc2x3/IfcVertexLoop.h"
#include "ifc2x3/IfcVertexPoint.h"
#include "ifc2x3/IfcVibrationIsolatorType.h"
#include "ifc2x3/IfcVirtualElement.h"
#include "ifc2x3/IfcVirtualGridIntersection.h"
#include "ifc2x3/IfcWall.h"
#include "ifc2x3/IfcWallStandardCase.h"
#include "ifc2x3/IfcWallType.h"
#include "ifc2x3/IfcWasteTerminalType.h"
#include "ifc2x3/IfcWaterProperties.h"
#include "ifc2x3/IfcWindow.h"
#include "ifc2x3/IfcWindowLiningProperties.h"
#include "ifc2x3/IfcWindowPanelProperties.h"
#include "ifc2x3/IfcWindowStyle.h"
#include "ifc2x3/IfcWorkPlan.h"
#include "ifc2x3/IfcWorkSchedule.h"
#include "ifc2x3/IfcZShapeProfileDef.h"
#include "ifc2x3/IfcZone.h"
#include <Step/BaseExpressDataSet.h>
#include <Step/BaseObject.h>
#include <Step/BaseSPFObject.h>
#include <Step/SPFData.h>

using namespace ifc2x3;

ExpressDataSet::ExpressDataSet() : Step::BaseExpressDataSet() {
    m_refIfc2DCompositeCurveList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcActionRequestList.push_back(&m_IfcActionRequest_Map);
    m_refIfcActorList.push_back(&m_IfcActor_Map);
    m_refIfcActorList.push_back(&m_IfcOccupant_Map);
    m_refIfcActorRoleList.push_back(&m_IfcActorRole_Map);
    m_refIfcActuatorTypeList.push_back(&m_IfcActuatorType_Map);
    m_refIfcAddressList.push_back(&m_IfcPostalAddress_Map);
    m_refIfcAddressList.push_back(&m_IfcTelecomAddress_Map);
    m_refIfcAirTerminalBoxTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcAirTerminalTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcAirToAirHeatRecoveryTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcAlarmTypeList.push_back(&m_IfcAlarmType_Map);
    m_refIfcAngularDimensionList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcAnnotationList.push_back(&m_IfcAnnotation_Map);
    m_refIfcAnnotationCurveOccurrenceList.push_back(&m_IfcAnnotationCurveOccurrence_Map);
    m_refIfcAnnotationCurveOccurrenceList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcAnnotationCurveOccurrenceList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcAnnotationFillAreaList.push_back(&m_IfcAnnotationFillArea_Map);
    m_refIfcAnnotationFillAreaOccurrenceList.push_back(&m_IfcAnnotationFillAreaOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationCurveOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationSymbolOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationTextOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationFillAreaOccurrence_Map);
    m_refIfcAnnotationOccurrenceList.push_back(&m_IfcAnnotationSurfaceOccurrence_Map);
    m_refIfcAnnotationSurfaceList.push_back(&m_IfcAnnotationSurface_Map);
    m_refIfcAnnotationSurfaceOccurrenceList.push_back(&m_IfcAnnotationSurfaceOccurrence_Map);
    m_refIfcAnnotationSymbolOccurrenceList.push_back(&m_IfcAnnotationSymbolOccurrence_Map);
    m_refIfcAnnotationSymbolOccurrenceList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcAnnotationSymbolOccurrenceList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcAnnotationTextOccurrenceList.push_back(&m_IfcAnnotationTextOccurrence_Map);
    m_refIfcApplicationList.push_back(&m_IfcApplication_Map);
    m_refIfcAppliedValueList.push_back(&m_IfcCostValue_Map);
    m_refIfcAppliedValueList.push_back(&m_IfcEnvironmentalImpactValue_Map);
    m_refIfcAppliedValueRelationshipList.push_back(&m_IfcAppliedValueRelationship_Map);
    m_refIfcApprovalList.push_back(&m_IfcApproval_Map);
    m_refIfcApprovalActorRelationshipList.push_back(&m_IfcApprovalActorRelationship_Map);
    m_refIfcApprovalPropertyRelationshipList.push_back(&m_IfcApprovalPropertyRelationship_Map);
    m_refIfcApprovalRelationshipList.push_back(&m_IfcApprovalRelationship_Map);
    m_refIfcArbitraryClosedProfileDefList.push_back(&m_IfcArbitraryClosedProfileDef_Map);
    m_refIfcArbitraryClosedProfileDefList.push_back(&m_IfcArbitraryProfileDefWithVoids_Map);
    m_refIfcArbitraryOpenProfileDefList.push_back(&m_IfcArbitraryOpenProfileDef_Map);
    m_refIfcArbitraryOpenProfileDefList.push_back(&m_IfcCenterLineProfileDef_Map);
    m_refIfcArbitraryProfileDefWithVoidsList.push_back(&m_IfcArbitraryProfileDefWithVoids_Map);
    m_refIfcAssetList.push_back(&m_IfcAsset_Map);
    m_refIfcAsymmetricIShapeProfileDefList.push_back(&m_IfcAsymmetricIShapeProfileDef_Map);
    m_refIfcAxis1PlacementList.push_back(&m_IfcAxis1Placement_Map);
    m_refIfcAxis2Placement2DList.push_back(&m_IfcAxis2Placement2D_Map);
    m_refIfcAxis2Placement3DList.push_back(&m_IfcAxis2Placement3D_Map);
    m_refIfcBSplineCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcBSplineCurveList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcBeamList.push_back(&m_IfcBeam_Map);
    m_refIfcBeamTypeList.push_back(&m_IfcBeamType_Map);
    m_refIfcBezierCurveList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcBezierCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcBlobTextureList.push_back(&m_IfcBlobTexture_Map);
    m_refIfcBlockList.push_back(&m_IfcBlock_Map);
    m_refIfcBoilerTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcBooleanClippingResultList.push_back(&m_IfcBooleanClippingResult_Map);
    m_refIfcBooleanResultList.push_back(&m_IfcBooleanResult_Map);
    m_refIfcBooleanResultList.push_back(&m_IfcBooleanClippingResult_Map);
    m_refIfcBoundaryConditionList.push_back(&m_IfcBoundaryEdgeCondition_Map);
    m_refIfcBoundaryConditionList.push_back(&m_IfcBoundaryFaceCondition_Map);
    m_refIfcBoundaryConditionList.push_back(&m_IfcBoundaryNodeConditionWarping_Map);
    m_refIfcBoundaryConditionList.push_back(&m_IfcBoundaryNodeCondition_Map);
    m_refIfcBoundaryEdgeConditionList.push_back(&m_IfcBoundaryEdgeCondition_Map);
    m_refIfcBoundaryFaceConditionList.push_back(&m_IfcBoundaryFaceCondition_Map);
    m_refIfcBoundaryNodeConditionList.push_back(&m_IfcBoundaryNodeCondition_Map);
    m_refIfcBoundaryNodeConditionList.push_back(&m_IfcBoundaryNodeConditionWarping_Map);
    m_refIfcBoundaryNodeConditionWarpingList.push_back(&m_IfcBoundaryNodeConditionWarping_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcPolyline_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcBoundedCurveList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcBoundedCurveList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcBoundedSurfaceList.push_back(&m_IfcBoundedSurface_Map);
    m_refIfcBoundedSurfaceList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcBoundedSurfaceList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcBoundingBoxList.push_back(&m_IfcBoundingBox_Map);
    m_refIfcBoxedHalfSpaceList.push_back(&m_IfcBoxedHalfSpace_Map);
    m_refIfcBuildingList.push_back(&m_IfcBuilding_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcCovering_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcBeam_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcTendon_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcColumn_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcDoor_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcFooting_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcMember_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcPile_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcPlate_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcRailing_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcRamp_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcRampFlight_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcRoof_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcSlab_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcStair_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcStairFlight_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcWall_Map);
    m_refIfcBuildingElementList.push_back(&m_IfcWindow_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcTendon_Map);
    m_refIfcBuildingElementComponentList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcBuildingElementPartList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcBuildingElementProxyList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcBuildingElementProxyTypeList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcBeamType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcColumnType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcCoveringType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcMemberType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcPlateType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcRailingType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcSlabType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcBuildingElementTypeList.push_back(&m_IfcWallType_Map);
    m_refIfcBuildingStoreyList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcCShapeProfileDefList.push_back(&m_IfcCShapeProfileDef_Map);
    m_refIfcCableCarrierFittingTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcCableCarrierSegmentTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcCableSegmentTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcCalendarDateList.push_back(&m_IfcCalendarDate_Map);
    m_refIfcCartesianPointList.push_back(&m_IfcCartesianPoint_Map);
    m_refIfcCartesianTransformationOperatorList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcCartesianTransformationOperatorList.push_back(&m_IfcCartesianTransformationOperator2D_Map);
    m_refIfcCartesianTransformationOperatorList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcCartesianTransformationOperatorList.push_back(&m_IfcCartesianTransformationOperator3D_Map);
    m_refIfcCartesianTransformationOperator2DList.push_back(&m_IfcCartesianTransformationOperator2D_Map);
    m_refIfcCartesianTransformationOperator2DList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcCartesianTransformationOperator2DnonUniformList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcCartesianTransformationOperator3DList.push_back(&m_IfcCartesianTransformationOperator3D_Map);
    m_refIfcCartesianTransformationOperator3DList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcCartesianTransformationOperator3DnonUniformList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcCenterLineProfileDefList.push_back(&m_IfcCenterLineProfileDef_Map);
    m_refIfcChamferEdgeFeatureList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcChillerTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcCircleList.push_back(&m_IfcCircle_Map);
    m_refIfcCircleHollowProfileDefList.push_back(&m_IfcCircleHollowProfileDef_Map);
    m_refIfcCircleProfileDefList.push_back(&m_IfcCircleProfileDef_Map);
    m_refIfcCircleProfileDefList.push_back(&m_IfcCircleHollowProfileDef_Map);
    m_refIfcClassificationList.push_back(&m_IfcClassification_Map);
    m_refIfcClassificationItemList.push_back(&m_IfcClassificationItem_Map);
    m_refIfcClassificationItemRelationshipList.push_back(&m_IfcClassificationItemRelationship_Map);
    m_refIfcClassificationNotationList.push_back(&m_IfcClassificationNotation_Map);
    m_refIfcClassificationNotationFacetList.push_back(&m_IfcClassificationNotationFacet_Map);
    m_refIfcClassificationReferenceList.push_back(&m_IfcClassificationReference_Map);
    m_refIfcClosedShellList.push_back(&m_IfcClosedShell_Map);
    m_refIfcCoilTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcColourRgbList.push_back(&m_IfcColourRgb_Map);
    m_refIfcColourSpecificationList.push_back(&m_IfcColourRgb_Map);
    m_refIfcColumnList.push_back(&m_IfcColumn_Map);
    m_refIfcColumnTypeList.push_back(&m_IfcColumnType_Map);
    m_refIfcComplexPropertyList.push_back(&m_IfcComplexProperty_Map);
    m_refIfcCompositeCurveList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcCompositeCurveList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcCompositeCurveSegmentList.push_back(&m_IfcCompositeCurveSegment_Map);
    m_refIfcCompositeProfileDefList.push_back(&m_IfcCompositeProfileDef_Map);
    m_refIfcCompressorTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcCondenserTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcConditionList.push_back(&m_IfcCondition_Map);
    m_refIfcConditionCriterionList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcConicList.push_back(&m_IfcCircle_Map);
    m_refIfcConicList.push_back(&m_IfcEllipse_Map);
    m_refIfcConnectedFaceSetList.push_back(&m_IfcConnectedFaceSet_Map);
    m_refIfcConnectedFaceSetList.push_back(&m_IfcOpenShell_Map);
    m_refIfcConnectedFaceSetList.push_back(&m_IfcClosedShell_Map);
    m_refIfcConnectionCurveGeometryList.push_back(&m_IfcConnectionCurveGeometry_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionCurveGeometry_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionPointEccentricity_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionPointGeometry_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionPortGeometry_Map);
    m_refIfcConnectionGeometryList.push_back(&m_IfcConnectionSurfaceGeometry_Map);
    m_refIfcConnectionPointEccentricityList.push_back(&m_IfcConnectionPointEccentricity_Map);
    m_refIfcConnectionPointGeometryList.push_back(&m_IfcConnectionPointGeometry_Map);
    m_refIfcConnectionPointGeometryList.push_back(&m_IfcConnectionPointEccentricity_Map);
    m_refIfcConnectionPortGeometryList.push_back(&m_IfcConnectionPortGeometry_Map);
    m_refIfcConnectionSurfaceGeometryList.push_back(&m_IfcConnectionSurfaceGeometry_Map);
    m_refIfcConstraintList.push_back(&m_IfcMetric_Map);
    m_refIfcConstraintList.push_back(&m_IfcObjective_Map);
    m_refIfcConstraintAggregationRelationshipList.push_back(&m_IfcConstraintAggregationRelationship_Map);
    m_refIfcConstraintClassificationRelationshipList.push_back(&m_IfcConstraintClassificationRelationship_Map);
    m_refIfcConstraintRelationshipList.push_back(&m_IfcConstraintRelationship_Map);
    m_refIfcConstructionEquipmentResourceList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcConstructionMaterialResourceList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcConstructionProductResourceList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcCrewResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcLaborResource_Map);
    m_refIfcConstructionResourceList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcContextDependentUnitList.push_back(&m_IfcContextDependentUnit_Map);
    m_refIfcControlList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcControlList.push_back(&m_IfcActionRequest_Map);
    m_refIfcControlList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcControlList.push_back(&m_IfcCostItem_Map);
    m_refIfcControlList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcControlList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcControlList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcControlList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcControlList.push_back(&m_IfcPermit_Map);
    m_refIfcControlList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcControlList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcControlList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcControlList.push_back(&m_IfcServiceLife_Map);
    m_refIfcControlList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcControlList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcControlList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcControllerTypeList.push_back(&m_IfcControllerType_Map);
    m_refIfcConversionBasedUnitList.push_back(&m_IfcConversionBasedUnit_Map);
    m_refIfcCooledBeamTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcCoolingTowerTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcCoordinatedUniversalTimeOffsetList.push_back(&m_IfcCoordinatedUniversalTimeOffset_Map);
    m_refIfcCostItemList.push_back(&m_IfcCostItem_Map);
    m_refIfcCostScheduleList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcCostValueList.push_back(&m_IfcCostValue_Map);
    m_refIfcCoveringList.push_back(&m_IfcCovering_Map);
    m_refIfcCoveringTypeList.push_back(&m_IfcCoveringType_Map);
    m_refIfcCraneRailAShapeProfileDefList.push_back(&m_IfcCraneRailAShapeProfileDef_Map);
    m_refIfcCraneRailFShapeProfileDefList.push_back(&m_IfcCraneRailFShapeProfileDef_Map);
    m_refIfcCrewResourceList.push_back(&m_IfcCrewResource_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcBlock_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcRectangularPyramid_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcRightCircularCone_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcRightCircularCylinder_Map);
    m_refIfcCsgPrimitive3DList.push_back(&m_IfcSphere_Map);
    m_refIfcCsgSolidList.push_back(&m_IfcCsgSolid_Map);
    m_refIfcCurrencyRelationshipList.push_back(&m_IfcCurrencyRelationship_Map);
    m_refIfcCurtainWallList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcCurtainWallTypeList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcCurveList.push_back(&m_IfcLine_Map);
    m_refIfcCurveList.push_back(&m_IfcCircle_Map);
    m_refIfcCurveList.push_back(&m_IfcEllipse_Map);
    m_refIfcCurveList.push_back(&m_IfcPolyline_Map);
    m_refIfcCurveList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcCurveList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcCurveList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcCurveList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcCurveList.push_back(&m_IfcOffsetCurve2D_Map);
    m_refIfcCurveList.push_back(&m_IfcOffsetCurve3D_Map);
    m_refIfcCurveBoundedPlaneList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcCurveStyleList.push_back(&m_IfcCurveStyle_Map);
    m_refIfcCurveStyleFontList.push_back(&m_IfcCurveStyleFont_Map);
    m_refIfcCurveStyleFontAndScalingList.push_back(&m_IfcCurveStyleFontAndScaling_Map);
    m_refIfcCurveStyleFontPatternList.push_back(&m_IfcCurveStyleFontPattern_Map);
    m_refIfcDamperTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcDateAndTimeList.push_back(&m_IfcDateAndTime_Map);
    m_refIfcDefinedSymbolList.push_back(&m_IfcDefinedSymbol_Map);
    m_refIfcDerivedProfileDefList.push_back(&m_IfcDerivedProfileDef_Map);
    m_refIfcDerivedUnitList.push_back(&m_IfcDerivedUnit_Map);
    m_refIfcDerivedUnitElementList.push_back(&m_IfcDerivedUnitElement_Map);
    m_refIfcDiameterDimensionList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcDimensionCalloutRelationshipList.push_back(&m_IfcDimensionCalloutRelationship_Map);
    m_refIfcDimensionCurveList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcDimensionCurveDirectedCallout_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcDimensionCurveDirectedCalloutList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcDimensionCurveTerminatorList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcDimensionPairList.push_back(&m_IfcDimensionPair_Map);
    m_refIfcDimensionalExponentsList.push_back(&m_IfcDimensionalExponents_Map);
    m_refIfcDirectionList.push_back(&m_IfcDirection_Map);
    m_refIfcDiscreteAccessoryList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcDiscreteAccessoryTypeList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcDiscreteAccessoryTypeList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcDistributionChamberElementList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcDistributionChamberElementTypeList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcDistributionControlElementList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcActuatorType_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcAlarmType_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcControllerType_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcDistributionControlElementTypeList.push_back(&m_IfcSensorType_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowController_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcDistributionElementList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcActuatorType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcAlarmType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcControllerType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcDistributionElementTypeList.push_back(&m_IfcSensorType_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowController_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcDistributionFlowElementList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcDistributionFlowElementTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcDistributionPortList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcDocumentElectronicFormatList.push_back(&m_IfcDocumentElectronicFormat_Map);
    m_refIfcDocumentInformationList.push_back(&m_IfcDocumentInformation_Map);
    m_refIfcDocumentInformationRelationshipList.push_back(&m_IfcDocumentInformationRelationship_Map);
    m_refIfcDocumentReferenceList.push_back(&m_IfcDocumentReference_Map);
    m_refIfcDoorList.push_back(&m_IfcDoor_Map);
    m_refIfcDoorLiningPropertiesList.push_back(&m_IfcDoorLiningProperties_Map);
    m_refIfcDoorPanelPropertiesList.push_back(&m_IfcDoorPanelProperties_Map);
    m_refIfcDoorStyleList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcDraughtingCallout_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcStructuredDimensionCallout_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcDraughtingCalloutList.push_back(&m_IfcDimensionCurveDirectedCallout_Map);
    m_refIfcDraughtingCalloutRelationshipList.push_back(&m_IfcDraughtingCalloutRelationship_Map);
    m_refIfcDraughtingCalloutRelationshipList.push_back(&m_IfcDimensionCalloutRelationship_Map);
    m_refIfcDraughtingCalloutRelationshipList.push_back(&m_IfcDimensionPair_Map);
    m_refIfcDraughtingPreDefinedColourList.push_back(&m_IfcDraughtingPreDefinedColour_Map);
    m_refIfcDraughtingPreDefinedCurveFontList.push_back(&m_IfcDraughtingPreDefinedCurveFont_Map);
    m_refIfcDraughtingPreDefinedTextFontList.push_back(&m_IfcDraughtingPreDefinedTextFont_Map);
    m_refIfcDuctFittingTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcDuctSegmentTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcDuctSilencerTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcEdgeList.push_back(&m_IfcEdge_Map);
    m_refIfcEdgeList.push_back(&m_IfcOrientedEdge_Map);
    m_refIfcEdgeList.push_back(&m_IfcSubedge_Map);
    m_refIfcEdgeList.push_back(&m_IfcEdgeCurve_Map);
    m_refIfcEdgeCurveList.push_back(&m_IfcEdgeCurve_Map);
    m_refIfcEdgeFeatureList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcEdgeFeatureList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcEdgeLoopList.push_back(&m_IfcEdgeLoop_Map);
    m_refIfcElectricApplianceTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcElectricDistributionPointList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcElectricFlowStorageDeviceTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcElectricGeneratorTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcElectricHeaterTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcElectricMotorTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcElectricTimeControlTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcElectricalBasePropertiesList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcElectricalCircuitList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcElectricalElementList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcElementList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcElementList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcElementList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcElementList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcElementList.push_back(&m_IfcCovering_Map);
    m_refIfcElementList.push_back(&m_IfcBeam_Map);
    m_refIfcElementList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcElementList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcElementList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcElementList.push_back(&m_IfcTendon_Map);
    m_refIfcElementList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcElementList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcElementList.push_back(&m_IfcColumn_Map);
    m_refIfcElementList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcElementList.push_back(&m_IfcDoor_Map);
    m_refIfcElementList.push_back(&m_IfcFooting_Map);
    m_refIfcElementList.push_back(&m_IfcMember_Map);
    m_refIfcElementList.push_back(&m_IfcPile_Map);
    m_refIfcElementList.push_back(&m_IfcPlate_Map);
    m_refIfcElementList.push_back(&m_IfcRailing_Map);
    m_refIfcElementList.push_back(&m_IfcRamp_Map);
    m_refIfcElementList.push_back(&m_IfcRampFlight_Map);
    m_refIfcElementList.push_back(&m_IfcRoof_Map);
    m_refIfcElementList.push_back(&m_IfcSlab_Map);
    m_refIfcElementList.push_back(&m_IfcStair_Map);
    m_refIfcElementList.push_back(&m_IfcStairFlight_Map);
    m_refIfcElementList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcElementList.push_back(&m_IfcWall_Map);
    m_refIfcElementList.push_back(&m_IfcWindow_Map);
    m_refIfcElementList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcElementList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcElementList.push_back(&m_IfcFastener_Map);
    m_refIfcElementList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcElementList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcElementList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcElementList.push_back(&m_IfcFlowController_Map);
    m_refIfcElementList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcElementList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcElementList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcElementList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcElementList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcElementList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcElementList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcElementList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcElementList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcElementList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcElementList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcElementList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcElementList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcElementList.push_back(&m_IfcTransportElement_Map);
    m_refIfcElementList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcElementAssemblyList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcElementComponentList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcElementComponentList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcElementComponentList.push_back(&m_IfcFastener_Map);
    m_refIfcElementComponentTypeList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcElementComponentTypeList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcElementComponentTypeList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcElementComponentTypeList.push_back(&m_IfcFastenerType_Map);
    m_refIfcElementQuantityList.push_back(&m_IfcElementQuantity_Map);
    m_refIfcElementTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcActuatorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcAlarmType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcControllerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSensorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcBeamType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcColumnType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCoveringType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcMemberType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcPlateType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcRailingType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSlabType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcWallType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFastenerType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcSpaceType_Map);
    m_refIfcElementTypeList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcElementarySurfaceList.push_back(&m_IfcPlane_Map);
    m_refIfcEllipseList.push_back(&m_IfcEllipse_Map);
    m_refIfcEllipseProfileDefList.push_back(&m_IfcEllipseProfileDef_Map);
    m_refIfcEnergyConversionDeviceList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcBoilerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcChillerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcCoilType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcCondenserType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcEnergyConversionDeviceTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcEnergyPropertiesList.push_back(&m_IfcEnergyProperties_Map);
    m_refIfcEnergyPropertiesList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcEnvironmentalImpactValueList.push_back(&m_IfcEnvironmentalImpactValue_Map);
    m_refIfcEquipmentElementList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcEquipmentStandardList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcEvaporativeCoolerTypeList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcEvaporatorTypeList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcExtendedMaterialPropertiesList.push_back(&m_IfcExtendedMaterialProperties_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcExternallyDefinedHatchStyle_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcExternallyDefinedTextFont_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcExternallyDefinedSurfaceStyle_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcClassificationReference_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcDocumentReference_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcLibraryReference_Map);
    m_refIfcExternalReferenceList.push_back(&m_IfcExternallyDefinedSymbol_Map);
    m_refIfcExternallyDefinedHatchStyleList.push_back(&m_IfcExternallyDefinedHatchStyle_Map);
    m_refIfcExternallyDefinedSurfaceStyleList.push_back(&m_IfcExternallyDefinedSurfaceStyle_Map);
    m_refIfcExternallyDefinedSymbolList.push_back(&m_IfcExternallyDefinedSymbol_Map);
    m_refIfcExternallyDefinedTextFontList.push_back(&m_IfcExternallyDefinedTextFont_Map);
    m_refIfcExtrudedAreaSolidList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcFaceList.push_back(&m_IfcFace_Map);
    m_refIfcFaceList.push_back(&m_IfcFaceSurface_Map);
    m_refIfcFaceBasedSurfaceModelList.push_back(&m_IfcFaceBasedSurfaceModel_Map);
    m_refIfcFaceBoundList.push_back(&m_IfcFaceBound_Map);
    m_refIfcFaceBoundList.push_back(&m_IfcFaceOuterBound_Map);
    m_refIfcFaceOuterBoundList.push_back(&m_IfcFaceOuterBound_Map);
    m_refIfcFaceSurfaceList.push_back(&m_IfcFaceSurface_Map);
    m_refIfcFacetedBrepList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcFacetedBrepWithVoidsList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcFailureConnectionConditionList.push_back(&m_IfcFailureConnectionCondition_Map);
    m_refIfcFanTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcFastenerList.push_back(&m_IfcFastener_Map);
    m_refIfcFastenerList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcFastenerTypeList.push_back(&m_IfcFastenerType_Map);
    m_refIfcFastenerTypeList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcFeatureElementList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcFeatureElementList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcFeatureElementList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcFeatureElementList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcFeatureElementAdditionList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcFeatureElementSubtractionList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcFeatureElementSubtractionList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcFeatureElementSubtractionList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcFillAreaStyleList.push_back(&m_IfcFillAreaStyle_Map);
    m_refIfcFillAreaStyleHatchingList.push_back(&m_IfcFillAreaStyleHatching_Map);
    m_refIfcFillAreaStyleTileSymbolWithStyleList.push_back(&m_IfcFillAreaStyleTileSymbolWithStyle_Map);
    m_refIfcFillAreaStyleTilesList.push_back(&m_IfcFillAreaStyleTiles_Map);
    m_refIfcFilterTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcFireSuppressionTerminalTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcFlowControllerList.push_back(&m_IfcFlowController_Map);
    m_refIfcFlowControllerList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcDamperType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcFlowControllerTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcFlowFittingList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcFlowFittingTypeList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcFlowFittingTypeList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcFlowFittingTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcFlowFittingTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcFlowInstrumentTypeList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcFlowMeterTypeList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcFlowMovingDeviceList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcFlowMovingDeviceTypeList.push_back(&m_IfcCompressorType_Map);
    m_refIfcFlowMovingDeviceTypeList.push_back(&m_IfcFanType_Map);
    m_refIfcFlowMovingDeviceTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcFlowSegmentList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcFlowSegmentTypeList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcFlowSegmentTypeList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcFlowSegmentTypeList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcFlowSegmentTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcFlowStorageDeviceList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcFlowStorageDeviceTypeList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcFlowStorageDeviceTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcFlowTerminalList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcFlowTerminalTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcFlowTreatmentDeviceList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcFlowTreatmentDeviceTypeList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcFlowTreatmentDeviceTypeList.push_back(&m_IfcFilterType_Map);
    m_refIfcFluidFlowPropertiesList.push_back(&m_IfcFluidFlowProperties_Map);
    m_refIfcFootingList.push_back(&m_IfcFooting_Map);
    m_refIfcFuelPropertiesList.push_back(&m_IfcFuelProperties_Map);
    m_refIfcFurnishingElementList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcFurnishingElementTypeList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcFurnishingElementTypeList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcFurnishingElementTypeList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcFurnitureStandardList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcFurnitureTypeList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcGasTerminalTypeList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcGeneralMaterialPropertiesList.push_back(&m_IfcGeneralMaterialProperties_Map);
    m_refIfcGeneralProfilePropertiesList.push_back(&m_IfcGeneralProfileProperties_Map);
    m_refIfcGeneralProfilePropertiesList.push_back(&m_IfcStructuralSteelProfileProperties_Map);
    m_refIfcGeneralProfilePropertiesList.push_back(&m_IfcStructuralProfileProperties_Map);
    m_refIfcGeometricCurveSetList.push_back(&m_IfcGeometricCurveSet_Map);
    m_refIfcGeometricRepresentationContextList.push_back(&m_IfcGeometricRepresentationContext_Map);
    m_refIfcGeometricRepresentationContextList.push_back(&m_IfcGeometricRepresentationSubContext_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFillAreaStyleHatching_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcVector_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcDirection_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcTwoDirectionRepeatFactor_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcOneDirectionRepeatFactor_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCartesianPoint_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPointOnCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPointOnSurface_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFillAreaStyleTiles_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFillAreaStyleTileSymbolWithStyle_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator2D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator3D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAxis2Placement2D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAxis2Placement3D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAxis1Placement_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCsgSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSweptDiskSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBoundingBox_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLine_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCircle_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcEllipse_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPolyline_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcOffsetCurve2D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcOffsetCurve3D_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCompositeCurveSegment_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBoxedHalfSpace_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPolygonalBoundedHalfSpace_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcHalfSpaceSolid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPlane_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBoundedSurface_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBooleanClippingResult_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBooleanResult_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcBlock_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRectangularPyramid_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRightCircularCone_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRightCircularCylinder_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSphere_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcFaceBasedSurfaceModel_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcStructuredDimensionCallout_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcDimensionCurveDirectedCallout_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcDraughtingCallout_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAnnotationFillArea_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcAnnotationSurface_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcDefinedSymbol_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcGeometricCurveSet_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcGeometricSet_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLightSourceAmbient_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLightSourceDirectional_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLightSourceGoniometric_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcLightSourcePositional_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPlanarBox_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcPlanarExtent_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcSectionedSpine_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcShellBasedSurfaceModel_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcTextLiteralWithExtent_Map);
    m_refIfcGeometricRepresentationItemList.push_back(&m_IfcTextLiteral_Map);
    m_refIfcGeometricRepresentationSubContextList.push_back(&m_IfcGeometricRepresentationSubContext_Map);
    m_refIfcGeometricSetList.push_back(&m_IfcGeometricSet_Map);
    m_refIfcGeometricSetList.push_back(&m_IfcGeometricCurveSet_Map);
    m_refIfcGridList.push_back(&m_IfcGrid_Map);
    m_refIfcGridAxisList.push_back(&m_IfcGridAxis_Map);
    m_refIfcGridPlacementList.push_back(&m_IfcGridPlacement_Map);
    m_refIfcGroupList.push_back(&m_IfcGroup_Map);
    m_refIfcGroupList.push_back(&m_IfcAsset_Map);
    m_refIfcGroupList.push_back(&m_IfcCondition_Map);
    m_refIfcGroupList.push_back(&m_IfcInventory_Map);
    m_refIfcGroupList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcGroupList.push_back(&m_IfcZone_Map);
    m_refIfcGroupList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcGroupList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcGroupList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcGroupList.push_back(&m_IfcSystem_Map);
    m_refIfcHalfSpaceSolidList.push_back(&m_IfcHalfSpaceSolid_Map);
    m_refIfcHalfSpaceSolidList.push_back(&m_IfcBoxedHalfSpace_Map);
    m_refIfcHalfSpaceSolidList.push_back(&m_IfcPolygonalBoundedHalfSpace_Map);
    m_refIfcHeatExchangerTypeList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcHumidifierTypeList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcHygroscopicMaterialPropertiesList.push_back(&m_IfcHygroscopicMaterialProperties_Map);
    m_refIfcIShapeProfileDefList.push_back(&m_IfcIShapeProfileDef_Map);
    m_refIfcIShapeProfileDefList.push_back(&m_IfcAsymmetricIShapeProfileDef_Map);
    m_refIfcImageTextureList.push_back(&m_IfcImageTexture_Map);
    m_refIfcInventoryList.push_back(&m_IfcInventory_Map);
    m_refIfcIrregularTimeSeriesList.push_back(&m_IfcIrregularTimeSeries_Map);
    m_refIfcIrregularTimeSeriesValueList.push_back(&m_IfcIrregularTimeSeriesValue_Map);
    m_refIfcJunctionBoxTypeList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcLShapeProfileDefList.push_back(&m_IfcLShapeProfileDef_Map);
    m_refIfcLaborResourceList.push_back(&m_IfcLaborResource_Map);
    m_refIfcLampTypeList.push_back(&m_IfcLampType_Map);
    m_refIfcLibraryInformationList.push_back(&m_IfcLibraryInformation_Map);
    m_refIfcLibraryReferenceList.push_back(&m_IfcLibraryReference_Map);
    m_refIfcLightDistributionDataList.push_back(&m_IfcLightDistributionData_Map);
    m_refIfcLightFixtureTypeList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcLightIntensityDistributionList.push_back(&m_IfcLightIntensityDistribution_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSourceAmbient_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSourceDirectional_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSourceGoniometric_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcLightSourceList.push_back(&m_IfcLightSourcePositional_Map);
    m_refIfcLightSourceAmbientList.push_back(&m_IfcLightSourceAmbient_Map);
    m_refIfcLightSourceDirectionalList.push_back(&m_IfcLightSourceDirectional_Map);
    m_refIfcLightSourceGoniometricList.push_back(&m_IfcLightSourceGoniometric_Map);
    m_refIfcLightSourcePositionalList.push_back(&m_IfcLightSourcePositional_Map);
    m_refIfcLightSourcePositionalList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcLightSourceSpotList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcLineList.push_back(&m_IfcLine_Map);
    m_refIfcLinearDimensionList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcLocalPlacementList.push_back(&m_IfcLocalPlacement_Map);
    m_refIfcLocalTimeList.push_back(&m_IfcLocalTime_Map);
    m_refIfcLoopList.push_back(&m_IfcLoop_Map);
    m_refIfcLoopList.push_back(&m_IfcEdgeLoop_Map);
    m_refIfcLoopList.push_back(&m_IfcPolyLoop_Map);
    m_refIfcLoopList.push_back(&m_IfcVertexLoop_Map);
    m_refIfcManifoldSolidBrepList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcManifoldSolidBrepList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcMappedItemList.push_back(&m_IfcMappedItem_Map);
    m_refIfcMaterialList.push_back(&m_IfcMaterial_Map);
    m_refIfcMaterialClassificationRelationshipList.push_back(&m_IfcMaterialClassificationRelationship_Map);
    m_refIfcMaterialDefinitionRepresentationList.push_back(&m_IfcMaterialDefinitionRepresentation_Map);
    m_refIfcMaterialLayerList.push_back(&m_IfcMaterialLayer_Map);
    m_refIfcMaterialLayerSetList.push_back(&m_IfcMaterialLayerSet_Map);
    m_refIfcMaterialLayerSetUsageList.push_back(&m_IfcMaterialLayerSetUsage_Map);
    m_refIfcMaterialListList.push_back(&m_IfcMaterialList_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcExtendedMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcFuelProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcGeneralMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcHygroscopicMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcMechanicalSteelMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcMechanicalConcreteMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcMechanicalMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcOpticalMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcProductsOfCombustionProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcThermalMaterialProperties_Map);
    m_refIfcMaterialPropertiesList.push_back(&m_IfcWaterProperties_Map);
    m_refIfcMeasureWithUnitList.push_back(&m_IfcMeasureWithUnit_Map);
    m_refIfcMechanicalConcreteMaterialPropertiesList.push_back(&m_IfcMechanicalConcreteMaterialProperties_Map);
    m_refIfcMechanicalFastenerList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcMechanicalFastenerTypeList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcMechanicalMaterialPropertiesList.push_back(&m_IfcMechanicalMaterialProperties_Map);
    m_refIfcMechanicalMaterialPropertiesList.push_back(&m_IfcMechanicalSteelMaterialProperties_Map);
    m_refIfcMechanicalMaterialPropertiesList.push_back(&m_IfcMechanicalConcreteMaterialProperties_Map);
    m_refIfcMechanicalSteelMaterialPropertiesList.push_back(&m_IfcMechanicalSteelMaterialProperties_Map);
    m_refIfcMemberList.push_back(&m_IfcMember_Map);
    m_refIfcMemberTypeList.push_back(&m_IfcMemberType_Map);
    m_refIfcMetricList.push_back(&m_IfcMetric_Map);
    m_refIfcMonetaryUnitList.push_back(&m_IfcMonetaryUnit_Map);
    m_refIfcMotorConnectionTypeList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcMoveList.push_back(&m_IfcMove_Map);
    m_refIfcNamedUnitList.push_back(&m_IfcContextDependentUnit_Map);
    m_refIfcNamedUnitList.push_back(&m_IfcConversionBasedUnit_Map);
    m_refIfcNamedUnitList.push_back(&m_IfcSIUnit_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcObjectList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcObjectList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcObjectList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcObjectList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcObjectList.push_back(&m_IfcCovering_Map);
    m_refIfcObjectList.push_back(&m_IfcBeam_Map);
    m_refIfcObjectList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcObjectList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcObjectList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcObjectList.push_back(&m_IfcTendon_Map);
    m_refIfcObjectList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcObjectList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcObjectList.push_back(&m_IfcColumn_Map);
    m_refIfcObjectList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcObjectList.push_back(&m_IfcDoor_Map);
    m_refIfcObjectList.push_back(&m_IfcFooting_Map);
    m_refIfcObjectList.push_back(&m_IfcMember_Map);
    m_refIfcObjectList.push_back(&m_IfcPile_Map);
    m_refIfcObjectList.push_back(&m_IfcPlate_Map);
    m_refIfcObjectList.push_back(&m_IfcRailing_Map);
    m_refIfcObjectList.push_back(&m_IfcRamp_Map);
    m_refIfcObjectList.push_back(&m_IfcRampFlight_Map);
    m_refIfcObjectList.push_back(&m_IfcRoof_Map);
    m_refIfcObjectList.push_back(&m_IfcSlab_Map);
    m_refIfcObjectList.push_back(&m_IfcStair_Map);
    m_refIfcObjectList.push_back(&m_IfcStairFlight_Map);
    m_refIfcObjectList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcObjectList.push_back(&m_IfcWall_Map);
    m_refIfcObjectList.push_back(&m_IfcWindow_Map);
    m_refIfcObjectList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcObjectList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcObjectList.push_back(&m_IfcFastener_Map);
    m_refIfcObjectList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcObjectList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcObjectList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowController_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcObjectList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcObjectList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcObjectList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcObjectList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcObjectList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcObjectList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcObjectList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcObjectList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcObjectList.push_back(&m_IfcTransportElement_Map);
    m_refIfcObjectList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcObjectList.push_back(&m_IfcSpace_Map);
    m_refIfcObjectList.push_back(&m_IfcBuilding_Map);
    m_refIfcObjectList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcObjectList.push_back(&m_IfcSite_Map);
    m_refIfcObjectList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcObjectList.push_back(&m_IfcAnnotation_Map);
    m_refIfcObjectList.push_back(&m_IfcGrid_Map);
    m_refIfcObjectList.push_back(&m_IfcProxy_Map);
    m_refIfcObjectList.push_back(&m_IfcAsset_Map);
    m_refIfcObjectList.push_back(&m_IfcCondition_Map);
    m_refIfcObjectList.push_back(&m_IfcInventory_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcObjectList.push_back(&m_IfcZone_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcObjectList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcObjectList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcObjectList.push_back(&m_IfcSystem_Map);
    m_refIfcObjectList.push_back(&m_IfcGroup_Map);
    m_refIfcObjectList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcObjectList.push_back(&m_IfcActionRequest_Map);
    m_refIfcObjectList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcObjectList.push_back(&m_IfcCostItem_Map);
    m_refIfcObjectList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcObjectList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcObjectList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcObjectList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcObjectList.push_back(&m_IfcPermit_Map);
    m_refIfcObjectList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcObjectList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcObjectList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcObjectList.push_back(&m_IfcServiceLife_Map);
    m_refIfcObjectList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcObjectList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcObjectList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcObjectList.push_back(&m_IfcOccupant_Map);
    m_refIfcObjectList.push_back(&m_IfcActor_Map);
    m_refIfcObjectList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcObjectList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcObjectList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcObjectList.push_back(&m_IfcCrewResource_Map);
    m_refIfcObjectList.push_back(&m_IfcLaborResource_Map);
    m_refIfcObjectList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcObjectList.push_back(&m_IfcOrderAction_Map);
    m_refIfcObjectList.push_back(&m_IfcMove_Map);
    m_refIfcObjectList.push_back(&m_IfcTask_Map);
    m_refIfcObjectList.push_back(&m_IfcProcedure_Map);
    m_refIfcObjectList.push_back(&m_IfcProject_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCovering_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBeam_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTendon_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcColumn_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDoor_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFooting_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMember_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPile_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPlate_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRailing_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRamp_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRampFlight_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRoof_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSlab_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStair_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStairFlight_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWall_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWindow_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFastener_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowController_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTransportElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSpace_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBuilding_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSite_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAnnotation_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcGrid_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProxy_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAsset_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCondition_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcInventory_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcZone_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSystem_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcGroup_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcActionRequest_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCostItem_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPermit_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcServiceLife_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcOccupant_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcActor_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCrewResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcLaborResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcOrderAction_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMove_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTask_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProcedure_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProject_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDamperType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcValveType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcLampType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcOutletType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBoilerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcChillerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCoilType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCondenserType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTransformerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCompressorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFanType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPumpType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFilterType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTankType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcActuatorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcAlarmType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcControllerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSensorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBeamType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcColumnType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCoveringType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMemberType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcPlateType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRailingType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSlabType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcWallType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFastenerType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcSpaceType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTypeProduct_Map);
    m_refIfcObjectDefinitionList.push_back(&m_IfcTypeObject_Map);
    m_refIfcObjectPlacementList.push_back(&m_IfcLocalPlacement_Map);
    m_refIfcObjectPlacementList.push_back(&m_IfcGridPlacement_Map);
    m_refIfcObjectiveList.push_back(&m_IfcObjective_Map);
    m_refIfcOccupantList.push_back(&m_IfcOccupant_Map);
    m_refIfcOffsetCurve2DList.push_back(&m_IfcOffsetCurve2D_Map);
    m_refIfcOffsetCurve3DList.push_back(&m_IfcOffsetCurve3D_Map);
    m_refIfcOneDirectionRepeatFactorList.push_back(&m_IfcOneDirectionRepeatFactor_Map);
    m_refIfcOneDirectionRepeatFactorList.push_back(&m_IfcTwoDirectionRepeatFactor_Map);
    m_refIfcOpenShellList.push_back(&m_IfcOpenShell_Map);
    m_refIfcOpeningElementList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcOpticalMaterialPropertiesList.push_back(&m_IfcOpticalMaterialProperties_Map);
    m_refIfcOrderActionList.push_back(&m_IfcOrderAction_Map);
    m_refIfcOrganizationList.push_back(&m_IfcOrganization_Map);
    m_refIfcOrganizationRelationshipList.push_back(&m_IfcOrganizationRelationship_Map);
    m_refIfcOrientedEdgeList.push_back(&m_IfcOrientedEdge_Map);
    m_refIfcOutletTypeList.push_back(&m_IfcOutletType_Map);
    m_refIfcOwnerHistoryList.push_back(&m_IfcOwnerHistory_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcAsymmetricIShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcIShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcCShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcCircleHollowProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcCircleProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcCraneRailAShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcCraneRailFShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcEllipseProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcLShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcRoundedRectangleProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcRectangleHollowProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcRectangleProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcTShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcTrapeziumProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcUShapeProfileDef_Map);
    m_refIfcParameterizedProfileDefList.push_back(&m_IfcZShapeProfileDef_Map);
    m_refIfcPathList.push_back(&m_IfcPath_Map);
    m_refIfcPerformanceHistoryList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcPermeableCoveringPropertiesList.push_back(&m_IfcPermeableCoveringProperties_Map);
    m_refIfcPermitList.push_back(&m_IfcPermit_Map);
    m_refIfcPersonList.push_back(&m_IfcPerson_Map);
    m_refIfcPersonAndOrganizationList.push_back(&m_IfcPersonAndOrganization_Map);
    m_refIfcPhysicalComplexQuantityList.push_back(&m_IfcPhysicalComplexQuantity_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcPhysicalComplexQuantity_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityArea_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityCount_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityLength_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityTime_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityVolume_Map);
    m_refIfcPhysicalQuantityList.push_back(&m_IfcQuantityWeight_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityArea_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityCount_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityLength_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityTime_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityVolume_Map);
    m_refIfcPhysicalSimpleQuantityList.push_back(&m_IfcQuantityWeight_Map);
    m_refIfcPileList.push_back(&m_IfcPile_Map);
    m_refIfcPipeFittingTypeList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcPipeSegmentTypeList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcPixelTextureList.push_back(&m_IfcPixelTexture_Map);
    m_refIfcPlacementList.push_back(&m_IfcAxis2Placement2D_Map);
    m_refIfcPlacementList.push_back(&m_IfcAxis2Placement3D_Map);
    m_refIfcPlacementList.push_back(&m_IfcAxis1Placement_Map);
    m_refIfcPlanarBoxList.push_back(&m_IfcPlanarBox_Map);
    m_refIfcPlanarExtentList.push_back(&m_IfcPlanarExtent_Map);
    m_refIfcPlanarExtentList.push_back(&m_IfcPlanarBox_Map);
    m_refIfcPlaneList.push_back(&m_IfcPlane_Map);
    m_refIfcPlateList.push_back(&m_IfcPlate_Map);
    m_refIfcPlateTypeList.push_back(&m_IfcPlateType_Map);
    m_refIfcPointList.push_back(&m_IfcCartesianPoint_Map);
    m_refIfcPointList.push_back(&m_IfcPointOnCurve_Map);
    m_refIfcPointList.push_back(&m_IfcPointOnSurface_Map);
    m_refIfcPointOnCurveList.push_back(&m_IfcPointOnCurve_Map);
    m_refIfcPointOnSurfaceList.push_back(&m_IfcPointOnSurface_Map);
    m_refIfcPolyLoopList.push_back(&m_IfcPolyLoop_Map);
    m_refIfcPolygonalBoundedHalfSpaceList.push_back(&m_IfcPolygonalBoundedHalfSpace_Map);
    m_refIfcPolylineList.push_back(&m_IfcPolyline_Map);
    m_refIfcPortList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcPostalAddressList.push_back(&m_IfcPostalAddress_Map);
    m_refIfcPreDefinedColourList.push_back(&m_IfcDraughtingPreDefinedColour_Map);
    m_refIfcPreDefinedCurveFontList.push_back(&m_IfcDraughtingPreDefinedCurveFont_Map);
    m_refIfcPreDefinedDimensionSymbolList.push_back(&m_IfcPreDefinedDimensionSymbol_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcDraughtingPreDefinedCurveFont_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcDraughtingPreDefinedColour_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcDraughtingPreDefinedTextFont_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcTextStyleFontModel_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcPreDefinedDimensionSymbol_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcPreDefinedPointMarkerSymbol_Map);
    m_refIfcPreDefinedItemList.push_back(&m_IfcPreDefinedTerminatorSymbol_Map);
    m_refIfcPreDefinedPointMarkerSymbolList.push_back(&m_IfcPreDefinedPointMarkerSymbol_Map);
    m_refIfcPreDefinedSymbolList.push_back(&m_IfcPreDefinedDimensionSymbol_Map);
    m_refIfcPreDefinedSymbolList.push_back(&m_IfcPreDefinedPointMarkerSymbol_Map);
    m_refIfcPreDefinedSymbolList.push_back(&m_IfcPreDefinedTerminatorSymbol_Map);
    m_refIfcPreDefinedTerminatorSymbolList.push_back(&m_IfcPreDefinedTerminatorSymbol_Map);
    m_refIfcPreDefinedTextFontList.push_back(&m_IfcDraughtingPreDefinedTextFont_Map);
    m_refIfcPreDefinedTextFontList.push_back(&m_IfcTextStyleFontModel_Map);
    m_refIfcPresentationLayerAssignmentList.push_back(&m_IfcPresentationLayerAssignment_Map);
    m_refIfcPresentationLayerAssignmentList.push_back(&m_IfcPresentationLayerWithStyle_Map);
    m_refIfcPresentationLayerWithStyleList.push_back(&m_IfcPresentationLayerWithStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcCurveStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcSymbolStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcFillAreaStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcTextStyle_Map);
    m_refIfcPresentationStyleList.push_back(&m_IfcSurfaceStyle_Map);
    m_refIfcPresentationStyleAssignmentList.push_back(&m_IfcPresentationStyleAssignment_Map);
    m_refIfcProcedureList.push_back(&m_IfcProcedure_Map);
    m_refIfcProcessList.push_back(&m_IfcOrderAction_Map);
    m_refIfcProcessList.push_back(&m_IfcMove_Map);
    m_refIfcProcessList.push_back(&m_IfcTask_Map);
    m_refIfcProcessList.push_back(&m_IfcProcedure_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcProductList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcProductList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcProductList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcProductList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcProductList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcProductList.push_back(&m_IfcCovering_Map);
    m_refIfcProductList.push_back(&m_IfcBeam_Map);
    m_refIfcProductList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcProductList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcProductList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcProductList.push_back(&m_IfcTendon_Map);
    m_refIfcProductList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcProductList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcProductList.push_back(&m_IfcColumn_Map);
    m_refIfcProductList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcProductList.push_back(&m_IfcDoor_Map);
    m_refIfcProductList.push_back(&m_IfcFooting_Map);
    m_refIfcProductList.push_back(&m_IfcMember_Map);
    m_refIfcProductList.push_back(&m_IfcPile_Map);
    m_refIfcProductList.push_back(&m_IfcPlate_Map);
    m_refIfcProductList.push_back(&m_IfcRailing_Map);
    m_refIfcProductList.push_back(&m_IfcRamp_Map);
    m_refIfcProductList.push_back(&m_IfcRampFlight_Map);
    m_refIfcProductList.push_back(&m_IfcRoof_Map);
    m_refIfcProductList.push_back(&m_IfcSlab_Map);
    m_refIfcProductList.push_back(&m_IfcStair_Map);
    m_refIfcProductList.push_back(&m_IfcStairFlight_Map);
    m_refIfcProductList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcProductList.push_back(&m_IfcWall_Map);
    m_refIfcProductList.push_back(&m_IfcWindow_Map);
    m_refIfcProductList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcProductList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcProductList.push_back(&m_IfcFastener_Map);
    m_refIfcProductList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcProductList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcProductList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcProductList.push_back(&m_IfcFlowController_Map);
    m_refIfcProductList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcProductList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcProductList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcProductList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcProductList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcProductList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcProductList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcProductList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcProductList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcProductList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcProductList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcProductList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcProductList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcProductList.push_back(&m_IfcTransportElement_Map);
    m_refIfcProductList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcProductList.push_back(&m_IfcSpace_Map);
    m_refIfcProductList.push_back(&m_IfcBuilding_Map);
    m_refIfcProductList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcProductList.push_back(&m_IfcSite_Map);
    m_refIfcProductList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcProductList.push_back(&m_IfcAnnotation_Map);
    m_refIfcProductList.push_back(&m_IfcGrid_Map);
    m_refIfcProductList.push_back(&m_IfcProxy_Map);
    m_refIfcProductDefinitionShapeList.push_back(&m_IfcProductDefinitionShape_Map);
    m_refIfcProductRepresentationList.push_back(&m_IfcProductRepresentation_Map);
    m_refIfcProductRepresentationList.push_back(&m_IfcMaterialDefinitionRepresentation_Map);
    m_refIfcProductRepresentationList.push_back(&m_IfcProductDefinitionShape_Map);
    m_refIfcProductsOfCombustionPropertiesList.push_back(&m_IfcProductsOfCombustionProperties_Map);
    m_refIfcProfileDefList.push_back(&m_IfcArbitraryProfileDefWithVoids_Map);
    m_refIfcProfileDefList.push_back(&m_IfcArbitraryClosedProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCenterLineProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcArbitraryOpenProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcAsymmetricIShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcIShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCircleHollowProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCircleProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCraneRailAShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCraneRailFShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcEllipseProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcLShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcRoundedRectangleProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcRectangleHollowProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcRectangleProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcTShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcTrapeziumProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcUShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcZShapeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcCompositeProfileDef_Map);
    m_refIfcProfileDefList.push_back(&m_IfcDerivedProfileDef_Map);
    m_refIfcProfilePropertiesList.push_back(&m_IfcStructuralSteelProfileProperties_Map);
    m_refIfcProfilePropertiesList.push_back(&m_IfcStructuralProfileProperties_Map);
    m_refIfcProfilePropertiesList.push_back(&m_IfcGeneralProfileProperties_Map);
    m_refIfcProfilePropertiesList.push_back(&m_IfcRibPlateProfileProperties_Map);
    m_refIfcProjectList.push_back(&m_IfcProject_Map);
    m_refIfcProjectOrderList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcProjectOrderRecordList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcProjectionCurveList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcProjectionElementList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcPropertyList.push_back(&m_IfcComplexProperty_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertyBoundedValue_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertyEnumeratedValue_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertyListValue_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertyReferenceValue_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertySingleValue_Map);
    m_refIfcPropertyList.push_back(&m_IfcPropertyTableValue_Map);
    m_refIfcPropertyBoundedValueList.push_back(&m_IfcPropertyBoundedValue_Map);
    m_refIfcPropertyConstraintRelationshipList.push_back(&m_IfcPropertyConstraintRelationship_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcDoorLiningProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcDoorPanelProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcEnergyProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcElementQuantity_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcFluidFlowProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcPermeableCoveringProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcPropertySet_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcReinforcementDefinitionProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcServiceLifeFactor_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcSoundProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcSoundValue_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcSpaceThermalLoadProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcWindowLiningProperties_Map);
    m_refIfcPropertyDefinitionList.push_back(&m_IfcWindowPanelProperties_Map);
    m_refIfcPropertyDependencyRelationshipList.push_back(&m_IfcPropertyDependencyRelationship_Map);
    m_refIfcPropertyEnumeratedValueList.push_back(&m_IfcPropertyEnumeratedValue_Map);
    m_refIfcPropertyEnumerationList.push_back(&m_IfcPropertyEnumeration_Map);
    m_refIfcPropertyListValueList.push_back(&m_IfcPropertyListValue_Map);
    m_refIfcPropertyReferenceValueList.push_back(&m_IfcPropertyReferenceValue_Map);
    m_refIfcPropertySetList.push_back(&m_IfcPropertySet_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcDoorLiningProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcDoorPanelProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcEnergyProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcElementQuantity_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcFluidFlowProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcPermeableCoveringProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcPropertySet_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcReinforcementDefinitionProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcServiceLifeFactor_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcSoundProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcSoundValue_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcSpaceThermalLoadProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcWindowLiningProperties_Map);
    m_refIfcPropertySetDefinitionList.push_back(&m_IfcWindowPanelProperties_Map);
    m_refIfcPropertySingleValueList.push_back(&m_IfcPropertySingleValue_Map);
    m_refIfcPropertyTableValueList.push_back(&m_IfcPropertyTableValue_Map);
    m_refIfcProtectiveDeviceTypeList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcProxyList.push_back(&m_IfcProxy_Map);
    m_refIfcPumpTypeList.push_back(&m_IfcPumpType_Map);
    m_refIfcQuantityAreaList.push_back(&m_IfcQuantityArea_Map);
    m_refIfcQuantityCountList.push_back(&m_IfcQuantityCount_Map);
    m_refIfcQuantityLengthList.push_back(&m_IfcQuantityLength_Map);
    m_refIfcQuantityTimeList.push_back(&m_IfcQuantityTime_Map);
    m_refIfcQuantityVolumeList.push_back(&m_IfcQuantityVolume_Map);
    m_refIfcQuantityWeightList.push_back(&m_IfcQuantityWeight_Map);
    m_refIfcRadiusDimensionList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcRailingList.push_back(&m_IfcRailing_Map);
    m_refIfcRailingTypeList.push_back(&m_IfcRailingType_Map);
    m_refIfcRampList.push_back(&m_IfcRamp_Map);
    m_refIfcRampFlightList.push_back(&m_IfcRampFlight_Map);
    m_refIfcRampFlightTypeList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcRationalBezierCurveList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcRectangleHollowProfileDefList.push_back(&m_IfcRectangleHollowProfileDef_Map);
    m_refIfcRectangleProfileDefList.push_back(&m_IfcRectangleProfileDef_Map);
    m_refIfcRectangleProfileDefList.push_back(&m_IfcRoundedRectangleProfileDef_Map);
    m_refIfcRectangleProfileDefList.push_back(&m_IfcRectangleHollowProfileDef_Map);
    m_refIfcRectangularPyramidList.push_back(&m_IfcRectangularPyramid_Map);
    m_refIfcRectangularTrimmedSurfaceList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcReferencesValueDocumentList.push_back(&m_IfcReferencesValueDocument_Map);
    m_refIfcRegularTimeSeriesList.push_back(&m_IfcRegularTimeSeries_Map);
    m_refIfcReinforcementBarPropertiesList.push_back(&m_IfcReinforcementBarProperties_Map);
    m_refIfcReinforcementDefinitionPropertiesList.push_back(&m_IfcReinforcementDefinitionProperties_Map);
    m_refIfcReinforcingBarList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcReinforcingElementList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcReinforcingElementList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcReinforcingElementList.push_back(&m_IfcTendon_Map);
    m_refIfcReinforcingElementList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcReinforcingMeshList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcRelAggregatesList.push_back(&m_IfcRelAggregates_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToProduct_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToGroup_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToControl_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToActor_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToResource_Map);
    m_refIfcRelAssignsList.push_back(&m_IfcRelAssignsToProcess_Map);
    m_refIfcRelAssignsTasksList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRelAssignsToActorList.push_back(&m_IfcRelAssignsToActor_Map);
    m_refIfcRelAssignsToActorList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRelAssignsToControlList.push_back(&m_IfcRelAssignsToControl_Map);
    m_refIfcRelAssignsToControlList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRelAssignsToControlList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRelAssignsToControlList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRelAssignsToGroupList.push_back(&m_IfcRelAssignsToGroup_Map);
    m_refIfcRelAssignsToProcessList.push_back(&m_IfcRelAssignsToProcess_Map);
    m_refIfcRelAssignsToProductList.push_back(&m_IfcRelAssignsToProduct_Map);
    m_refIfcRelAssignsToProjectOrderList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRelAssignsToResourceList.push_back(&m_IfcRelAssignsToResource_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociates_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesAppliedValue_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesApproval_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesClassification_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesConstraint_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesDocument_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesLibrary_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesMaterial_Map);
    m_refIfcRelAssociatesList.push_back(&m_IfcRelAssociatesProfileProperties_Map);
    m_refIfcRelAssociatesAppliedValueList.push_back(&m_IfcRelAssociatesAppliedValue_Map);
    m_refIfcRelAssociatesApprovalList.push_back(&m_IfcRelAssociatesApproval_Map);
    m_refIfcRelAssociatesClassificationList.push_back(&m_IfcRelAssociatesClassification_Map);
    m_refIfcRelAssociatesConstraintList.push_back(&m_IfcRelAssociatesConstraint_Map);
    m_refIfcRelAssociatesDocumentList.push_back(&m_IfcRelAssociatesDocument_Map);
    m_refIfcRelAssociatesLibraryList.push_back(&m_IfcRelAssociatesLibrary_Map);
    m_refIfcRelAssociatesMaterialList.push_back(&m_IfcRelAssociatesMaterial_Map);
    m_refIfcRelAssociatesProfilePropertiesList.push_back(&m_IfcRelAssociatesProfileProperties_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsStructuralActivity_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsStructuralElement_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsStructuralMember_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelFillsElement_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelVoidsElement_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsElements_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelCoversBldgElements_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelCoversSpaces_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelReferencedInSpatialStructure_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelServicesBuildings_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelContainedInSpatialStructure_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelSpaceBoundary_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelProjectsElement_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsPortToElement_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelConnectsPorts_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelFlowControlElements_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelSequence_Map);
    m_refIfcRelConnectsList.push_back(&m_IfcRelInteractionRequirements_Map);
    m_refIfcRelConnectsElementsList.push_back(&m_IfcRelConnectsElements_Map);
    m_refIfcRelConnectsElementsList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRelConnectsElementsList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRelConnectsPathElementsList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRelConnectsPortToElementList.push_back(&m_IfcRelConnectsPortToElement_Map);
    m_refIfcRelConnectsPortsList.push_back(&m_IfcRelConnectsPorts_Map);
    m_refIfcRelConnectsStructuralActivityList.push_back(&m_IfcRelConnectsStructuralActivity_Map);
    m_refIfcRelConnectsStructuralElementList.push_back(&m_IfcRelConnectsStructuralElement_Map);
    m_refIfcRelConnectsStructuralMemberList.push_back(&m_IfcRelConnectsStructuralMember_Map);
    m_refIfcRelConnectsStructuralMemberList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRelConnectsWithEccentricityList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRelConnectsWithRealizingElementsList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRelContainedInSpatialStructureList.push_back(&m_IfcRelContainedInSpatialStructure_Map);
    m_refIfcRelCoversBldgElementsList.push_back(&m_IfcRelCoversBldgElements_Map);
    m_refIfcRelCoversSpacesList.push_back(&m_IfcRelCoversSpaces_Map);
    m_refIfcRelDecomposesList.push_back(&m_IfcRelAggregates_Map);
    m_refIfcRelDecomposesList.push_back(&m_IfcRelNests_Map);
    m_refIfcRelDefinesList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRelDefinesList.push_back(&m_IfcRelDefinesByProperties_Map);
    m_refIfcRelDefinesList.push_back(&m_IfcRelDefinesByType_Map);
    m_refIfcRelDefinesByPropertiesList.push_back(&m_IfcRelDefinesByProperties_Map);
    m_refIfcRelDefinesByPropertiesList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRelDefinesByTypeList.push_back(&m_IfcRelDefinesByType_Map);
    m_refIfcRelFillsElementList.push_back(&m_IfcRelFillsElement_Map);
    m_refIfcRelFlowControlElementsList.push_back(&m_IfcRelFlowControlElements_Map);
    m_refIfcRelInteractionRequirementsList.push_back(&m_IfcRelInteractionRequirements_Map);
    m_refIfcRelNestsList.push_back(&m_IfcRelNests_Map);
    m_refIfcRelOccupiesSpacesList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRelOverridesPropertiesList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRelProjectsElementList.push_back(&m_IfcRelProjectsElement_Map);
    m_refIfcRelReferencedInSpatialStructureList.push_back(&m_IfcRelReferencedInSpatialStructure_Map);
    m_refIfcRelSchedulesCostItemsList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRelSequenceList.push_back(&m_IfcRelSequence_Map);
    m_refIfcRelServicesBuildingsList.push_back(&m_IfcRelServicesBuildings_Map);
    m_refIfcRelSpaceBoundaryList.push_back(&m_IfcRelSpaceBoundary_Map);
    m_refIfcRelVoidsElementList.push_back(&m_IfcRelVoidsElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToProduct_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToGroup_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToControl_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToActor_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToResource_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssignsToProcess_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAggregates_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelNests_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesAppliedValue_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesApproval_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesClassification_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesConstraint_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesDocument_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesLibrary_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesMaterial_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociatesProfileProperties_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelAssociates_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelDefinesByProperties_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelDefinesByType_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsStructuralActivity_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsStructuralElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsStructuralMember_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelFillsElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelVoidsElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsElements_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelCoversBldgElements_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelCoversSpaces_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelReferencedInSpatialStructure_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelServicesBuildings_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelContainedInSpatialStructure_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelSpaceBoundary_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelProjectsElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsPortToElement_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelConnectsPorts_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelFlowControlElements_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelSequence_Map);
    m_refIfcRelationshipList.push_back(&m_IfcRelInteractionRequirements_Map);
    m_refIfcRelaxationList.push_back(&m_IfcRelaxation_Map);
    m_refIfcRepresentationList.push_back(&m_IfcRepresentation_Map);
    m_refIfcRepresentationList.push_back(&m_IfcShapeRepresentation_Map);
    m_refIfcRepresentationList.push_back(&m_IfcTopologyRepresentation_Map);
    m_refIfcRepresentationList.push_back(&m_IfcStyledRepresentation_Map);
    m_refIfcRepresentationContextList.push_back(&m_IfcRepresentationContext_Map);
    m_refIfcRepresentationContextList.push_back(&m_IfcGeometricRepresentationSubContext_Map);
    m_refIfcRepresentationContextList.push_back(&m_IfcGeometricRepresentationContext_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationCurveOccurrence_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationSymbolOccurrence_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationTextOccurrence_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationFillAreaOccurrence_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationSurfaceOccurrence_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcStyledItem_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcMappedItem_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFillAreaStyleHatching_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcVector_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDirection_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcTwoDirectionRepeatFactor_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcOneDirectionRepeatFactor_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCartesianPoint_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPointOnCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPointOnSurface_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFillAreaStyleTiles_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFillAreaStyleTileSymbolWithStyle_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator2DnonUniform_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator2D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator3DnonUniform_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCartesianTransformationOperator3D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAxis2Placement2D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAxis2Placement3D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAxis1Placement_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCsgSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSweptDiskSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBoundingBox_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLine_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCircle_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcEllipse_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPolyline_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_Ifc2DCompositeCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCompositeCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRationalBezierCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBezierCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcOffsetCurve2D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcOffsetCurve3D_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCompositeCurveSegment_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBoxedHalfSpace_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPolygonalBoundedHalfSpace_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcHalfSpaceSolid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPlane_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBoundedSurface_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBooleanClippingResult_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBooleanResult_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcBlock_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRectangularPyramid_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRightCircularCone_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRightCircularCylinder_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSphere_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFaceBasedSurfaceModel_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcStructuredDimensionCallout_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDiameterDimension_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLinearDimension_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcRadiusDimension_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAngularDimension_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDimensionCurveDirectedCallout_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDraughtingCallout_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationFillArea_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcAnnotationSurface_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcDefinedSymbol_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcGeometricCurveSet_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcGeometricSet_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLightSourceAmbient_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLightSourceDirectional_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLightSourceGoniometric_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLightSourceSpot_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLightSourcePositional_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPlanarBox_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPlanarExtent_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSectionedSpine_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcShellBasedSurfaceModel_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcTextLiteralWithExtent_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcTextLiteral_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcVertexPoint_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcVertex_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcOrientedEdge_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcSubedge_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcEdgeCurve_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcEdge_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcOpenShell_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcClosedShell_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcConnectedFaceSet_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFaceSurface_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFace_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFaceOuterBound_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcFaceBound_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcEdgeLoop_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPolyLoop_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcVertexLoop_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcLoop_Map);
    m_refIfcRepresentationItemList.push_back(&m_IfcPath_Map);
    m_refIfcRepresentationMapList.push_back(&m_IfcRepresentationMap_Map);
    m_refIfcResourceList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcResourceList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcResourceList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcResourceList.push_back(&m_IfcCrewResource_Map);
    m_refIfcResourceList.push_back(&m_IfcLaborResource_Map);
    m_refIfcResourceList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcRevolvedAreaSolidList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcRibPlateProfilePropertiesList.push_back(&m_IfcRibPlateProfileProperties_Map);
    m_refIfcRightCircularConeList.push_back(&m_IfcRightCircularCone_Map);
    m_refIfcRightCircularCylinderList.push_back(&m_IfcRightCircularCylinder_Map);
    m_refIfcRoofList.push_back(&m_IfcRoof_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcRootList.push_back(&m_IfcOpeningElement_Map);
    m_refIfcRootList.push_back(&m_IfcChamferEdgeFeature_Map);
    m_refIfcRootList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcRootList.push_back(&m_IfcProjectionElement_Map);
    m_refIfcRootList.push_back(&m_IfcCovering_Map);
    m_refIfcRootList.push_back(&m_IfcBeam_Map);
    m_refIfcRootList.push_back(&m_IfcBuildingElementPart_Map);
    m_refIfcRootList.push_back(&m_IfcReinforcingBar_Map);
    m_refIfcRootList.push_back(&m_IfcReinforcingMesh_Map);
    m_refIfcRootList.push_back(&m_IfcTendon_Map);
    m_refIfcRootList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcRootList.push_back(&m_IfcBuildingElementProxy_Map);
    m_refIfcRootList.push_back(&m_IfcColumn_Map);
    m_refIfcRootList.push_back(&m_IfcCurtainWall_Map);
    m_refIfcRootList.push_back(&m_IfcDoor_Map);
    m_refIfcRootList.push_back(&m_IfcFooting_Map);
    m_refIfcRootList.push_back(&m_IfcMember_Map);
    m_refIfcRootList.push_back(&m_IfcPile_Map);
    m_refIfcRootList.push_back(&m_IfcPlate_Map);
    m_refIfcRootList.push_back(&m_IfcRailing_Map);
    m_refIfcRootList.push_back(&m_IfcRamp_Map);
    m_refIfcRootList.push_back(&m_IfcRampFlight_Map);
    m_refIfcRootList.push_back(&m_IfcRoof_Map);
    m_refIfcRootList.push_back(&m_IfcSlab_Map);
    m_refIfcRootList.push_back(&m_IfcStair_Map);
    m_refIfcRootList.push_back(&m_IfcStairFlight_Map);
    m_refIfcRootList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcRootList.push_back(&m_IfcWall_Map);
    m_refIfcRootList.push_back(&m_IfcWindow_Map);
    m_refIfcRootList.push_back(&m_IfcDiscreteAccessory_Map);
    m_refIfcRootList.push_back(&m_IfcMechanicalFastener_Map);
    m_refIfcRootList.push_back(&m_IfcFastener_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionControlElement_Map);
    m_refIfcRootList.push_back(&m_IfcEnergyConversionDevice_Map);
    m_refIfcRootList.push_back(&m_IfcElectricDistributionPoint_Map);
    m_refIfcRootList.push_back(&m_IfcFlowController_Map);
    m_refIfcRootList.push_back(&m_IfcFlowFitting_Map);
    m_refIfcRootList.push_back(&m_IfcFlowMovingDevice_Map);
    m_refIfcRootList.push_back(&m_IfcFlowSegment_Map);
    m_refIfcRootList.push_back(&m_IfcFlowStorageDevice_Map);
    m_refIfcRootList.push_back(&m_IfcFlowTerminal_Map);
    m_refIfcRootList.push_back(&m_IfcFlowTreatmentDevice_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionChamberElement_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionFlowElement_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionElement_Map);
    m_refIfcRootList.push_back(&m_IfcElectricalElement_Map);
    m_refIfcRootList.push_back(&m_IfcElementAssembly_Map);
    m_refIfcRootList.push_back(&m_IfcEquipmentElement_Map);
    m_refIfcRootList.push_back(&m_IfcFurnishingElement_Map);
    m_refIfcRootList.push_back(&m_IfcTransportElement_Map);
    m_refIfcRootList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcRootList.push_back(&m_IfcSpace_Map);
    m_refIfcRootList.push_back(&m_IfcBuilding_Map);
    m_refIfcRootList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcRootList.push_back(&m_IfcSite_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionPort_Map);
    m_refIfcRootList.push_back(&m_IfcAnnotation_Map);
    m_refIfcRootList.push_back(&m_IfcGrid_Map);
    m_refIfcRootList.push_back(&m_IfcProxy_Map);
    m_refIfcRootList.push_back(&m_IfcAsset_Map);
    m_refIfcRootList.push_back(&m_IfcCondition_Map);
    m_refIfcRootList.push_back(&m_IfcInventory_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcRootList.push_back(&m_IfcZone_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcRootList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcRootList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcRootList.push_back(&m_IfcSystem_Map);
    m_refIfcRootList.push_back(&m_IfcGroup_Map);
    m_refIfcRootList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcRootList.push_back(&m_IfcActionRequest_Map);
    m_refIfcRootList.push_back(&m_IfcConditionCriterion_Map);
    m_refIfcRootList.push_back(&m_IfcCostItem_Map);
    m_refIfcRootList.push_back(&m_IfcCostSchedule_Map);
    m_refIfcRootList.push_back(&m_IfcEquipmentStandard_Map);
    m_refIfcRootList.push_back(&m_IfcFurnitureStandard_Map);
    m_refIfcRootList.push_back(&m_IfcPerformanceHistory_Map);
    m_refIfcRootList.push_back(&m_IfcPermit_Map);
    m_refIfcRootList.push_back(&m_IfcProjectOrder_Map);
    m_refIfcRootList.push_back(&m_IfcProjectOrderRecord_Map);
    m_refIfcRootList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcRootList.push_back(&m_IfcServiceLife_Map);
    m_refIfcRootList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcRootList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcRootList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcRootList.push_back(&m_IfcOccupant_Map);
    m_refIfcRootList.push_back(&m_IfcActor_Map);
    m_refIfcRootList.push_back(&m_IfcConstructionEquipmentResource_Map);
    m_refIfcRootList.push_back(&m_IfcConstructionMaterialResource_Map);
    m_refIfcRootList.push_back(&m_IfcConstructionProductResource_Map);
    m_refIfcRootList.push_back(&m_IfcCrewResource_Map);
    m_refIfcRootList.push_back(&m_IfcLaborResource_Map);
    m_refIfcRootList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcRootList.push_back(&m_IfcOrderAction_Map);
    m_refIfcRootList.push_back(&m_IfcMove_Map);
    m_refIfcRootList.push_back(&m_IfcTask_Map);
    m_refIfcRootList.push_back(&m_IfcProcedure_Map);
    m_refIfcRootList.push_back(&m_IfcProject_Map);
    m_refIfcRootList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcRootList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcRootList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcRootList.push_back(&m_IfcDamperType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcRootList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcRootList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcRootList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcRootList.push_back(&m_IfcValveType_Map);
    m_refIfcRootList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcRootList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcLampType_Map);
    m_refIfcRootList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcRootList.push_back(&m_IfcOutletType_Map);
    m_refIfcRootList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcRootList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcRootList.push_back(&m_IfcBoilerType_Map);
    m_refIfcRootList.push_back(&m_IfcChillerType_Map);
    m_refIfcRootList.push_back(&m_IfcCoilType_Map);
    m_refIfcRootList.push_back(&m_IfcCondenserType_Map);
    m_refIfcRootList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcRootList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcRootList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcRootList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcRootList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcRootList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcRootList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcRootList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcRootList.push_back(&m_IfcTransformerType_Map);
    m_refIfcRootList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcRootList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcRootList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcRootList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcRootList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcRootList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcRootList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcRootList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcRootList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcRootList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcRootList.push_back(&m_IfcCompressorType_Map);
    m_refIfcRootList.push_back(&m_IfcFanType_Map);
    m_refIfcRootList.push_back(&m_IfcPumpType_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcRootList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcRootList.push_back(&m_IfcFilterType_Map);
    m_refIfcRootList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcRootList.push_back(&m_IfcTankType_Map);
    m_refIfcRootList.push_back(&m_IfcActuatorType_Map);
    m_refIfcRootList.push_back(&m_IfcAlarmType_Map);
    m_refIfcRootList.push_back(&m_IfcControllerType_Map);
    m_refIfcRootList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcRootList.push_back(&m_IfcSensorType_Map);
    m_refIfcRootList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcRootList.push_back(&m_IfcBeamType_Map);
    m_refIfcRootList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcRootList.push_back(&m_IfcColumnType_Map);
    m_refIfcRootList.push_back(&m_IfcCoveringType_Map);
    m_refIfcRootList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcRootList.push_back(&m_IfcMemberType_Map);
    m_refIfcRootList.push_back(&m_IfcPlateType_Map);
    m_refIfcRootList.push_back(&m_IfcRailingType_Map);
    m_refIfcRootList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcRootList.push_back(&m_IfcSlabType_Map);
    m_refIfcRootList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcRootList.push_back(&m_IfcWallType_Map);
    m_refIfcRootList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcRootList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcRootList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcRootList.push_back(&m_IfcFastenerType_Map);
    m_refIfcRootList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcRootList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcRootList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcRootList.push_back(&m_IfcSpaceType_Map);
    m_refIfcRootList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcRootList.push_back(&m_IfcTypeProduct_Map);
    m_refIfcRootList.push_back(&m_IfcTypeObject_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToProduct_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToGroup_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsTasks_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToProjectOrder_Map);
    m_refIfcRootList.push_back(&m_IfcRelSchedulesCostItems_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToControl_Map);
    m_refIfcRootList.push_back(&m_IfcRelOccupiesSpaces_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToActor_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToResource_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssignsToProcess_Map);
    m_refIfcRootList.push_back(&m_IfcRelAggregates_Map);
    m_refIfcRootList.push_back(&m_IfcRelNests_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesAppliedValue_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesApproval_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesClassification_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesConstraint_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesDocument_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesLibrary_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesMaterial_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociatesProfileProperties_Map);
    m_refIfcRootList.push_back(&m_IfcRelAssociates_Map);
    m_refIfcRootList.push_back(&m_IfcRelOverridesProperties_Map);
    m_refIfcRootList.push_back(&m_IfcRelDefinesByProperties_Map);
    m_refIfcRootList.push_back(&m_IfcRelDefinesByType_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsStructuralActivity_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsStructuralElement_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsWithEccentricity_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsStructuralMember_Map);
    m_refIfcRootList.push_back(&m_IfcRelFillsElement_Map);
    m_refIfcRootList.push_back(&m_IfcRelVoidsElement_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsPathElements_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsWithRealizingElements_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsElements_Map);
    m_refIfcRootList.push_back(&m_IfcRelCoversBldgElements_Map);
    m_refIfcRootList.push_back(&m_IfcRelCoversSpaces_Map);
    m_refIfcRootList.push_back(&m_IfcRelReferencedInSpatialStructure_Map);
    m_refIfcRootList.push_back(&m_IfcRelServicesBuildings_Map);
    m_refIfcRootList.push_back(&m_IfcRelContainedInSpatialStructure_Map);
    m_refIfcRootList.push_back(&m_IfcRelSpaceBoundary_Map);
    m_refIfcRootList.push_back(&m_IfcRelProjectsElement_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsPortToElement_Map);
    m_refIfcRootList.push_back(&m_IfcRelConnectsPorts_Map);
    m_refIfcRootList.push_back(&m_IfcRelFlowControlElements_Map);
    m_refIfcRootList.push_back(&m_IfcRelSequence_Map);
    m_refIfcRootList.push_back(&m_IfcRelInteractionRequirements_Map);
    m_refIfcRootList.push_back(&m_IfcDoorLiningProperties_Map);
    m_refIfcRootList.push_back(&m_IfcDoorPanelProperties_Map);
    m_refIfcRootList.push_back(&m_IfcElectricalBaseProperties_Map);
    m_refIfcRootList.push_back(&m_IfcEnergyProperties_Map);
    m_refIfcRootList.push_back(&m_IfcElementQuantity_Map);
    m_refIfcRootList.push_back(&m_IfcFluidFlowProperties_Map);
    m_refIfcRootList.push_back(&m_IfcPermeableCoveringProperties_Map);
    m_refIfcRootList.push_back(&m_IfcPropertySet_Map);
    m_refIfcRootList.push_back(&m_IfcReinforcementDefinitionProperties_Map);
    m_refIfcRootList.push_back(&m_IfcServiceLifeFactor_Map);
    m_refIfcRootList.push_back(&m_IfcSoundProperties_Map);
    m_refIfcRootList.push_back(&m_IfcSoundValue_Map);
    m_refIfcRootList.push_back(&m_IfcSpaceThermalLoadProperties_Map);
    m_refIfcRootList.push_back(&m_IfcWindowLiningProperties_Map);
    m_refIfcRootList.push_back(&m_IfcWindowPanelProperties_Map);
    m_refIfcRoundedEdgeFeatureList.push_back(&m_IfcRoundedEdgeFeature_Map);
    m_refIfcRoundedRectangleProfileDefList.push_back(&m_IfcRoundedRectangleProfileDef_Map);
    m_refIfcSIUnitList.push_back(&m_IfcSIUnit_Map);
    m_refIfcSanitaryTerminalTypeList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcScheduleTimeControlList.push_back(&m_IfcScheduleTimeControl_Map);
    m_refIfcSectionPropertiesList.push_back(&m_IfcSectionProperties_Map);
    m_refIfcSectionReinforcementPropertiesList.push_back(&m_IfcSectionReinforcementProperties_Map);
    m_refIfcSectionedSpineList.push_back(&m_IfcSectionedSpine_Map);
    m_refIfcSensorTypeList.push_back(&m_IfcSensorType_Map);
    m_refIfcServiceLifeList.push_back(&m_IfcServiceLife_Map);
    m_refIfcServiceLifeFactorList.push_back(&m_IfcServiceLifeFactor_Map);
    m_refIfcShapeAspectList.push_back(&m_IfcShapeAspect_Map);
    m_refIfcShapeModelList.push_back(&m_IfcShapeRepresentation_Map);
    m_refIfcShapeModelList.push_back(&m_IfcTopologyRepresentation_Map);
    m_refIfcShapeRepresentationList.push_back(&m_IfcShapeRepresentation_Map);
    m_refIfcShellBasedSurfaceModelList.push_back(&m_IfcShellBasedSurfaceModel_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertyBoundedValue_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertyEnumeratedValue_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertyListValue_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertyReferenceValue_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertySingleValue_Map);
    m_refIfcSimplePropertyList.push_back(&m_IfcPropertyTableValue_Map);
    m_refIfcSiteList.push_back(&m_IfcSite_Map);
    m_refIfcSlabList.push_back(&m_IfcSlab_Map);
    m_refIfcSlabTypeList.push_back(&m_IfcSlabType_Map);
    m_refIfcSlippageConnectionConditionList.push_back(&m_IfcSlippageConnectionCondition_Map);
    m_refIfcSolidModelList.push_back(&m_IfcCsgSolid_Map);
    m_refIfcSolidModelList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcSolidModelList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcSolidModelList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcSolidModelList.push_back(&m_IfcFacetedBrep_Map);
    m_refIfcSolidModelList.push_back(&m_IfcFacetedBrepWithVoids_Map);
    m_refIfcSolidModelList.push_back(&m_IfcSweptDiskSolid_Map);
    m_refIfcSoundPropertiesList.push_back(&m_IfcSoundProperties_Map);
    m_refIfcSoundValueList.push_back(&m_IfcSoundValue_Map);
    m_refIfcSpaceList.push_back(&m_IfcSpace_Map);
    m_refIfcSpaceHeaterTypeList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcSpaceProgramList.push_back(&m_IfcSpaceProgram_Map);
    m_refIfcSpaceThermalLoadPropertiesList.push_back(&m_IfcSpaceThermalLoadProperties_Map);
    m_refIfcSpaceTypeList.push_back(&m_IfcSpaceType_Map);
    m_refIfcSpatialStructureElementList.push_back(&m_IfcSpace_Map);
    m_refIfcSpatialStructureElementList.push_back(&m_IfcBuilding_Map);
    m_refIfcSpatialStructureElementList.push_back(&m_IfcBuildingStorey_Map);
    m_refIfcSpatialStructureElementList.push_back(&m_IfcSite_Map);
    m_refIfcSpatialStructureElementTypeList.push_back(&m_IfcSpaceType_Map);
    m_refIfcSphereList.push_back(&m_IfcSphere_Map);
    m_refIfcStackTerminalTypeList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcStairList.push_back(&m_IfcStair_Map);
    m_refIfcStairFlightList.push_back(&m_IfcStairFlight_Map);
    m_refIfcStairFlightTypeList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcStructuralActionList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcStructuralActivityList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcStructuralAnalysisModelList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcStructuralConnectionList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcStructuralConnectionList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcStructuralConnectionList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcStructuralConnectionConditionList.push_back(&m_IfcFailureConnectionCondition_Map);
    m_refIfcStructuralConnectionConditionList.push_back(&m_IfcSlippageConnectionCondition_Map);
    m_refIfcStructuralCurveConnectionList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcStructuralCurveMemberList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcStructuralCurveMemberList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcStructuralCurveMemberVaryingList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralCurveConnection_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcStructuralItemList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcStructuralLinearActionList.push_back(&m_IfcStructuralLinearAction_Map);
    m_refIfcStructuralLinearActionList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcStructuralLinearActionVaryingList.push_back(&m_IfcStructuralLinearActionVarying_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadLinearForce_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadPlanarForce_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadSingleDisplacementDistortion_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadSingleDisplacement_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadSingleForceWarping_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadSingleForce_Map);
    m_refIfcStructuralLoadList.push_back(&m_IfcStructuralLoadTemperature_Map);
    m_refIfcStructuralLoadGroupList.push_back(&m_IfcStructuralLoadGroup_Map);
    m_refIfcStructuralLoadLinearForceList.push_back(&m_IfcStructuralLoadLinearForce_Map);
    m_refIfcStructuralLoadPlanarForceList.push_back(&m_IfcStructuralLoadPlanarForce_Map);
    m_refIfcStructuralLoadSingleDisplacementList.push_back(&m_IfcStructuralLoadSingleDisplacement_Map);
    m_refIfcStructuralLoadSingleDisplacementList.push_back(&m_IfcStructuralLoadSingleDisplacementDistortion_Map);
    m_refIfcStructuralLoadSingleDisplacementDistortionList.push_back(&m_IfcStructuralLoadSingleDisplacementDistortion_Map);
    m_refIfcStructuralLoadSingleForceList.push_back(&m_IfcStructuralLoadSingleForce_Map);
    m_refIfcStructuralLoadSingleForceList.push_back(&m_IfcStructuralLoadSingleForceWarping_Map);
    m_refIfcStructuralLoadSingleForceWarpingList.push_back(&m_IfcStructuralLoadSingleForceWarping_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadLinearForce_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadPlanarForce_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadSingleDisplacementDistortion_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadSingleDisplacement_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadSingleForceWarping_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadSingleForce_Map);
    m_refIfcStructuralLoadStaticList.push_back(&m_IfcStructuralLoadTemperature_Map);
    m_refIfcStructuralLoadTemperatureList.push_back(&m_IfcStructuralLoadTemperature_Map);
    m_refIfcStructuralMemberList.push_back(&m_IfcStructuralCurveMemberVarying_Map);
    m_refIfcStructuralMemberList.push_back(&m_IfcStructuralCurveMember_Map);
    m_refIfcStructuralMemberList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcStructuralMemberList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcStructuralPlanarActionList.push_back(&m_IfcStructuralPlanarAction_Map);
    m_refIfcStructuralPlanarActionList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcStructuralPlanarActionVaryingList.push_back(&m_IfcStructuralPlanarActionVarying_Map);
    m_refIfcStructuralPointActionList.push_back(&m_IfcStructuralPointAction_Map);
    m_refIfcStructuralPointConnectionList.push_back(&m_IfcStructuralPointConnection_Map);
    m_refIfcStructuralPointReactionList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcStructuralProfilePropertiesList.push_back(&m_IfcStructuralProfileProperties_Map);
    m_refIfcStructuralProfilePropertiesList.push_back(&m_IfcStructuralSteelProfileProperties_Map);
    m_refIfcStructuralReactionList.push_back(&m_IfcStructuralPointReaction_Map);
    m_refIfcStructuralResultGroupList.push_back(&m_IfcStructuralResultGroup_Map);
    m_refIfcStructuralSteelProfilePropertiesList.push_back(&m_IfcStructuralSteelProfileProperties_Map);
    m_refIfcStructuralSurfaceConnectionList.push_back(&m_IfcStructuralSurfaceConnection_Map);
    m_refIfcStructuralSurfaceMemberList.push_back(&m_IfcStructuralSurfaceMember_Map);
    m_refIfcStructuralSurfaceMemberList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcStructuralSurfaceMemberVaryingList.push_back(&m_IfcStructuralSurfaceMemberVarying_Map);
    m_refIfcStructuredDimensionCalloutList.push_back(&m_IfcStructuredDimensionCallout_Map);
    m_refIfcStyleModelList.push_back(&m_IfcStyledRepresentation_Map);
    m_refIfcStyledItemList.push_back(&m_IfcStyledItem_Map);
    m_refIfcStyledItemList.push_back(&m_IfcDimensionCurve_Map);
    m_refIfcStyledItemList.push_back(&m_IfcProjectionCurve_Map);
    m_refIfcStyledItemList.push_back(&m_IfcAnnotationCurveOccurrence_Map);
    m_refIfcStyledItemList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcStyledItemList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcStyledItemList.push_back(&m_IfcAnnotationSymbolOccurrence_Map);
    m_refIfcStyledItemList.push_back(&m_IfcAnnotationTextOccurrence_Map);
    m_refIfcStyledItemList.push_back(&m_IfcAnnotationFillAreaOccurrence_Map);
    m_refIfcStyledItemList.push_back(&m_IfcAnnotationSurfaceOccurrence_Map);
    m_refIfcStyledRepresentationList.push_back(&m_IfcStyledRepresentation_Map);
    m_refIfcSubContractResourceList.push_back(&m_IfcSubContractResource_Map);
    m_refIfcSubedgeList.push_back(&m_IfcSubedge_Map);
    m_refIfcSurfaceList.push_back(&m_IfcPlane_Map);
    m_refIfcSurfaceList.push_back(&m_IfcCurveBoundedPlane_Map);
    m_refIfcSurfaceList.push_back(&m_IfcRectangularTrimmedSurface_Map);
    m_refIfcSurfaceList.push_back(&m_IfcBoundedSurface_Map);
    m_refIfcSurfaceList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcSurfaceList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcSurfaceCurveSweptAreaSolidList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcSurfaceOfLinearExtrusionList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcSurfaceOfRevolutionList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcSurfaceStyleList.push_back(&m_IfcSurfaceStyle_Map);
    m_refIfcSurfaceStyleLightingList.push_back(&m_IfcSurfaceStyleLighting_Map);
    m_refIfcSurfaceStyleRefractionList.push_back(&m_IfcSurfaceStyleRefraction_Map);
    m_refIfcSurfaceStyleRenderingList.push_back(&m_IfcSurfaceStyleRendering_Map);
    m_refIfcSurfaceStyleShadingList.push_back(&m_IfcSurfaceStyleShading_Map);
    m_refIfcSurfaceStyleShadingList.push_back(&m_IfcSurfaceStyleRendering_Map);
    m_refIfcSurfaceStyleWithTexturesList.push_back(&m_IfcSurfaceStyleWithTextures_Map);
    m_refIfcSurfaceTextureList.push_back(&m_IfcBlobTexture_Map);
    m_refIfcSurfaceTextureList.push_back(&m_IfcImageTexture_Map);
    m_refIfcSurfaceTextureList.push_back(&m_IfcPixelTexture_Map);
    m_refIfcSweptAreaSolidList.push_back(&m_IfcExtrudedAreaSolid_Map);
    m_refIfcSweptAreaSolidList.push_back(&m_IfcRevolvedAreaSolid_Map);
    m_refIfcSweptAreaSolidList.push_back(&m_IfcSurfaceCurveSweptAreaSolid_Map);
    m_refIfcSweptDiskSolidList.push_back(&m_IfcSweptDiskSolid_Map);
    m_refIfcSweptSurfaceList.push_back(&m_IfcSurfaceOfLinearExtrusion_Map);
    m_refIfcSweptSurfaceList.push_back(&m_IfcSurfaceOfRevolution_Map);
    m_refIfcSwitchingDeviceTypeList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcSymbolStyleList.push_back(&m_IfcSymbolStyle_Map);
    m_refIfcSystemList.push_back(&m_IfcSystem_Map);
    m_refIfcSystemList.push_back(&m_IfcElectricalCircuit_Map);
    m_refIfcSystemList.push_back(&m_IfcStructuralAnalysisModel_Map);
    m_refIfcSystemFurnitureElementTypeList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcTShapeProfileDefList.push_back(&m_IfcTShapeProfileDef_Map);
    m_refIfcTableList.push_back(&m_IfcTable_Map);
    m_refIfcTableRowList.push_back(&m_IfcTableRow_Map);
    m_refIfcTankTypeList.push_back(&m_IfcTankType_Map);
    m_refIfcTaskList.push_back(&m_IfcTask_Map);
    m_refIfcTaskList.push_back(&m_IfcOrderAction_Map);
    m_refIfcTaskList.push_back(&m_IfcMove_Map);
    m_refIfcTelecomAddressList.push_back(&m_IfcTelecomAddress_Map);
    m_refIfcTendonList.push_back(&m_IfcTendon_Map);
    m_refIfcTendonAnchorList.push_back(&m_IfcTendonAnchor_Map);
    m_refIfcTerminatorSymbolList.push_back(&m_IfcTerminatorSymbol_Map);
    m_refIfcTerminatorSymbolList.push_back(&m_IfcDimensionCurveTerminator_Map);
    m_refIfcTextLiteralList.push_back(&m_IfcTextLiteral_Map);
    m_refIfcTextLiteralList.push_back(&m_IfcTextLiteralWithExtent_Map);
    m_refIfcTextLiteralWithExtentList.push_back(&m_IfcTextLiteralWithExtent_Map);
    m_refIfcTextStyleList.push_back(&m_IfcTextStyle_Map);
    m_refIfcTextStyleFontModelList.push_back(&m_IfcTextStyleFontModel_Map);
    m_refIfcTextStyleForDefinedFontList.push_back(&m_IfcTextStyleForDefinedFont_Map);
    m_refIfcTextStyleTextModelList.push_back(&m_IfcTextStyleTextModel_Map);
    m_refIfcTextStyleWithBoxCharacteristicsList.push_back(&m_IfcTextStyleWithBoxCharacteristics_Map);
    m_refIfcTextureCoordinateList.push_back(&m_IfcTextureCoordinateGenerator_Map);
    m_refIfcTextureCoordinateList.push_back(&m_IfcTextureMap_Map);
    m_refIfcTextureCoordinateGeneratorList.push_back(&m_IfcTextureCoordinateGenerator_Map);
    m_refIfcTextureMapList.push_back(&m_IfcTextureMap_Map);
    m_refIfcTextureVertexList.push_back(&m_IfcTextureVertex_Map);
    m_refIfcThermalMaterialPropertiesList.push_back(&m_IfcThermalMaterialProperties_Map);
    m_refIfcTimeSeriesList.push_back(&m_IfcIrregularTimeSeries_Map);
    m_refIfcTimeSeriesList.push_back(&m_IfcRegularTimeSeries_Map);
    m_refIfcTimeSeriesReferenceRelationshipList.push_back(&m_IfcTimeSeriesReferenceRelationship_Map);
    m_refIfcTimeSeriesScheduleList.push_back(&m_IfcTimeSeriesSchedule_Map);
    m_refIfcTimeSeriesValueList.push_back(&m_IfcTimeSeriesValue_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcVertexPoint_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcVertex_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcOrientedEdge_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcSubedge_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcEdgeCurve_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcEdge_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcOpenShell_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcClosedShell_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcConnectedFaceSet_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcFaceSurface_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcFace_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcFaceOuterBound_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcFaceBound_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcEdgeLoop_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcPolyLoop_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcVertexLoop_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcLoop_Map);
    m_refIfcTopologicalRepresentationItemList.push_back(&m_IfcPath_Map);
    m_refIfcTopologyRepresentationList.push_back(&m_IfcTopologyRepresentation_Map);
    m_refIfcTransformerTypeList.push_back(&m_IfcTransformerType_Map);
    m_refIfcTransportElementList.push_back(&m_IfcTransportElement_Map);
    m_refIfcTransportElementTypeList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcTrapeziumProfileDefList.push_back(&m_IfcTrapeziumProfileDef_Map);
    m_refIfcTrimmedCurveList.push_back(&m_IfcTrimmedCurve_Map);
    m_refIfcTubeBundleTypeList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcTwoDirectionRepeatFactorList.push_back(&m_IfcTwoDirectionRepeatFactor_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTypeObject_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDamperType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcValveType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcLampType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcOutletType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcBoilerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcChillerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCoilType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCondenserType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTransformerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCompressorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFanType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcPumpType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFilterType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTankType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcActuatorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcAlarmType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcControllerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSensorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcBeamType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcColumnType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCoveringType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcMemberType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcPlateType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcRailingType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSlabType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcWallType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFastenerType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcSpaceType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcTypeObjectList.push_back(&m_IfcTypeProduct_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTypeProduct_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDoorStyle_Map);
    m_refIfcTypeProductList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcTypeProductList.push_back(&m_IfcAirTerminalBoxType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDamperType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricTimeControlType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFlowMeterType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcProtectiveDeviceType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSwitchingDeviceType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcValveType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcAirTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricApplianceType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricHeaterType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFireSuppressionTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcGasTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcLampType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcLightFixtureType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcOutletType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSanitaryTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcStackTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcAirToAirHeatRecoveryType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcBoilerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcChillerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCoilType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCondenserType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCooledBeamType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCoolingTowerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricGeneratorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricMotorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcEvaporativeCoolerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcEvaporatorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcHeatExchangerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcHumidifierType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcMotorConnectionType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSpaceHeaterType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTransformerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTubeBundleType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCableCarrierFittingType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDuctFittingType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcJunctionBoxType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcPipeFittingType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCableCarrierSegmentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCableSegmentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDuctSegmentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcPipeSegmentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCompressorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFanType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcPumpType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDistributionChamberElementType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDuctSilencerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFilterType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcElectricFlowStorageDeviceType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTankType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcActuatorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcAlarmType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcControllerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFlowInstrumentType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSensorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDistributionElementType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcBeamType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcBuildingElementProxyType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcColumnType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCoveringType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcCurtainWallType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcMemberType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcPlateType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcRailingType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcRampFlightType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSlabType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcStairFlightType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcWallType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcDiscreteAccessoryType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcMechanicalFastenerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFastenerType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFurnitureType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSystemFurnitureElementType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcFurnishingElementType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcSpaceType_Map);
    m_refIfcTypeProductList.push_back(&m_IfcTransportElementType_Map);
    m_refIfcUShapeProfileDefList.push_back(&m_IfcUShapeProfileDef_Map);
    m_refIfcUnitAssignmentList.push_back(&m_IfcUnitAssignment_Map);
    m_refIfcUnitaryEquipmentTypeList.push_back(&m_IfcUnitaryEquipmentType_Map);
    m_refIfcValveTypeList.push_back(&m_IfcValveType_Map);
    m_refIfcVectorList.push_back(&m_IfcVector_Map);
    m_refIfcVertexList.push_back(&m_IfcVertex_Map);
    m_refIfcVertexList.push_back(&m_IfcVertexPoint_Map);
    m_refIfcVertexBasedTextureMapList.push_back(&m_IfcVertexBasedTextureMap_Map);
    m_refIfcVertexLoopList.push_back(&m_IfcVertexLoop_Map);
    m_refIfcVertexPointList.push_back(&m_IfcVertexPoint_Map);
    m_refIfcVibrationIsolatorTypeList.push_back(&m_IfcVibrationIsolatorType_Map);
    m_refIfcVirtualElementList.push_back(&m_IfcVirtualElement_Map);
    m_refIfcVirtualGridIntersectionList.push_back(&m_IfcVirtualGridIntersection_Map);
    m_refIfcWallList.push_back(&m_IfcWall_Map);
    m_refIfcWallList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcWallStandardCaseList.push_back(&m_IfcWallStandardCase_Map);
    m_refIfcWallTypeList.push_back(&m_IfcWallType_Map);
    m_refIfcWasteTerminalTypeList.push_back(&m_IfcWasteTerminalType_Map);
    m_refIfcWaterPropertiesList.push_back(&m_IfcWaterProperties_Map);
    m_refIfcWindowList.push_back(&m_IfcWindow_Map);
    m_refIfcWindowLiningPropertiesList.push_back(&m_IfcWindowLiningProperties_Map);
    m_refIfcWindowPanelPropertiesList.push_back(&m_IfcWindowPanelProperties_Map);
    m_refIfcWindowStyleList.push_back(&m_IfcWindowStyle_Map);
    m_refIfcWorkControlList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcWorkControlList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcWorkPlanList.push_back(&m_IfcWorkPlan_Map);
    m_refIfcWorkScheduleList.push_back(&m_IfcWorkSchedule_Map);
    m_refIfcZShapeProfileDefList.push_back(&m_IfcZShapeProfileDef_Map);
    m_refIfcZoneList.push_back(&m_IfcZone_Map);
}

ExpressDataSet::~ExpressDataSet() {
}

Ifc2DCompositeCurve *ExpressDataSet::getIfc2DCompositeCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< Ifc2DCompositeCurve * > (current->second.get());
    }
    else {
        Ifc2DCompositeCurve *ret = static_cast< Ifc2DCompositeCurve * > (allocateIfc2DCompositeCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfc2DCompositeCurve(Ifc2DCompositeCurve *arg) {
    getAll().erase(arg->getKey());
    return m_Ifc2DCompositeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfc2DCompositeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    Ifc2DCompositeCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new Ifc2DCompositeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_Ifc2DCompositeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< Ifc2DCompositeCurve > ExpressDataSet::createIfc2DCompositeCurve(bool isVolatile) {
    if (isVolatile) {
        return new Ifc2DCompositeCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< Ifc2DCompositeCurve * > (allocateIfc2DCompositeCurve(this, Step::Id_UNSET));
    }
}

Ifc2DCompositeCurve *ExpressDataSet::cloneIfc2DCompositeCurve(ExpressDataSet *expressDataSet, const Ifc2DCompositeCurve &obj, const CopyOp &copyop) {
    Ifc2DCompositeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new Ifc2DCompositeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_Ifc2DCompositeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

Ifc2DCompositeCurve *ExpressDataSet::cloneIfc2DCompositeCurve(const Ifc2DCompositeCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfc2DCompositeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfc2DCompositeCurve(this, obj, copyop);
    }
}

IfcActionRequest *ExpressDataSet::getIfcActionRequest(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcActionRequest * > (current->second.get());
    }
    else {
        IfcActionRequest *ret = static_cast< IfcActionRequest * > (allocateIfcActionRequest(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcActionRequest(IfcActionRequest *arg) {
    getAll().erase(arg->getKey());
    return m_IfcActionRequest_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActionRequest(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcActionRequest *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActionRequest(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActionRequest_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActionRequest > ExpressDataSet::createIfcActionRequest(bool isVolatile) {
    if (isVolatile) {
        return new IfcActionRequest(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcActionRequest * > (allocateIfcActionRequest(this, Step::Id_UNSET));
    }
}

IfcActionRequest *ExpressDataSet::cloneIfcActionRequest(ExpressDataSet *expressDataSet, const IfcActionRequest &obj, const CopyOp &copyop) {
    IfcActionRequest *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActionRequest(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActionRequest_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActionRequest *ExpressDataSet::cloneIfcActionRequest(const IfcActionRequest &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcActionRequest(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcActionRequest(this, obj, copyop);
    }
}

IfcActor *ExpressDataSet::getIfcActor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcActor * > (current->second.get());
    }
    else {
        IfcActor *ret = static_cast< IfcActor * > (allocateIfcActor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcActor(IfcActor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcActor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcActor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActor > ExpressDataSet::createIfcActor(bool isVolatile) {
    if (isVolatile) {
        return new IfcActor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcActor * > (allocateIfcActor(this, Step::Id_UNSET));
    }
}

IfcActor *ExpressDataSet::cloneIfcActor(ExpressDataSet *expressDataSet, const IfcActor &obj, const CopyOp &copyop) {
    IfcActor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActor *ExpressDataSet::cloneIfcActor(const IfcActor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcActor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcActor(this, obj, copyop);
    }
}

IfcActorRole *ExpressDataSet::getIfcActorRole(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcActorRole * > (current->second.get());
    }
    else {
        IfcActorRole *ret = static_cast< IfcActorRole * > (allocateIfcActorRole(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcActorRole(IfcActorRole *arg) {
    getAll().erase(arg->getKey());
    return m_IfcActorRole_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActorRole(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcActorRole *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActorRole(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActorRole_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActorRole > ExpressDataSet::createIfcActorRole(bool isVolatile) {
    if (isVolatile) {
        return new IfcActorRole(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcActorRole * > (allocateIfcActorRole(this, Step::Id_UNSET));
    }
}

IfcActorRole *ExpressDataSet::cloneIfcActorRole(ExpressDataSet *expressDataSet, const IfcActorRole &obj, const CopyOp &copyop) {
    IfcActorRole *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActorRole(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActorRole_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActorRole *ExpressDataSet::cloneIfcActorRole(const IfcActorRole &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcActorRole(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcActorRole(this, obj, copyop);
    }
}

IfcActuatorType *ExpressDataSet::getIfcActuatorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcActuatorType * > (current->second.get());
    }
    else {
        IfcActuatorType *ret = static_cast< IfcActuatorType * > (allocateIfcActuatorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcActuatorType(IfcActuatorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcActuatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcActuatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcActuatorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcActuatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcActuatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcActuatorType > ExpressDataSet::createIfcActuatorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcActuatorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcActuatorType * > (allocateIfcActuatorType(this, Step::Id_UNSET));
    }
}

IfcActuatorType *ExpressDataSet::cloneIfcActuatorType(ExpressDataSet *expressDataSet, const IfcActuatorType &obj, const CopyOp &copyop) {
    IfcActuatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcActuatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcActuatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcActuatorType *ExpressDataSet::cloneIfcActuatorType(const IfcActuatorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcActuatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcActuatorType(this, obj, copyop);
    }
}

IfcAirTerminalBoxType *ExpressDataSet::getIfcAirTerminalBoxType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAirTerminalBoxType * > (current->second.get());
    }
    else {
        IfcAirTerminalBoxType *ret = static_cast< IfcAirTerminalBoxType * > (allocateIfcAirTerminalBoxType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAirTerminalBoxType(IfcAirTerminalBoxType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAirTerminalBoxType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirTerminalBoxType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAirTerminalBoxType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirTerminalBoxType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirTerminalBoxType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirTerminalBoxType > ExpressDataSet::createIfcAirTerminalBoxType(bool isVolatile) {
    if (isVolatile) {
        return new IfcAirTerminalBoxType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAirTerminalBoxType * > (allocateIfcAirTerminalBoxType(this, Step::Id_UNSET));
    }
}

IfcAirTerminalBoxType *ExpressDataSet::cloneIfcAirTerminalBoxType(ExpressDataSet *expressDataSet, const IfcAirTerminalBoxType &obj, const CopyOp &copyop) {
    IfcAirTerminalBoxType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirTerminalBoxType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirTerminalBoxType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirTerminalBoxType *ExpressDataSet::cloneIfcAirTerminalBoxType(const IfcAirTerminalBoxType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAirTerminalBoxType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAirTerminalBoxType(this, obj, copyop);
    }
}

IfcAirTerminalType *ExpressDataSet::getIfcAirTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAirTerminalType * > (current->second.get());
    }
    else {
        IfcAirTerminalType *ret = static_cast< IfcAirTerminalType * > (allocateIfcAirTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAirTerminalType(IfcAirTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAirTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAirTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirTerminalType > ExpressDataSet::createIfcAirTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcAirTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAirTerminalType * > (allocateIfcAirTerminalType(this, Step::Id_UNSET));
    }
}

IfcAirTerminalType *ExpressDataSet::cloneIfcAirTerminalType(ExpressDataSet *expressDataSet, const IfcAirTerminalType &obj, const CopyOp &copyop) {
    IfcAirTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirTerminalType *ExpressDataSet::cloneIfcAirTerminalType(const IfcAirTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAirTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAirTerminalType(this, obj, copyop);
    }
}

IfcAirToAirHeatRecoveryType *ExpressDataSet::getIfcAirToAirHeatRecoveryType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAirToAirHeatRecoveryType * > (current->second.get());
    }
    else {
        IfcAirToAirHeatRecoveryType *ret = static_cast< IfcAirToAirHeatRecoveryType * > (allocateIfcAirToAirHeatRecoveryType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAirToAirHeatRecoveryType(IfcAirToAirHeatRecoveryType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAirToAirHeatRecoveryType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAirToAirHeatRecoveryType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAirToAirHeatRecoveryType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAirToAirHeatRecoveryType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAirToAirHeatRecoveryType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAirToAirHeatRecoveryType > ExpressDataSet::createIfcAirToAirHeatRecoveryType(bool isVolatile) {
    if (isVolatile) {
        return new IfcAirToAirHeatRecoveryType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAirToAirHeatRecoveryType * > (allocateIfcAirToAirHeatRecoveryType(this, Step::Id_UNSET));
    }
}

IfcAirToAirHeatRecoveryType *ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(ExpressDataSet *expressDataSet, const IfcAirToAirHeatRecoveryType &obj, const CopyOp &copyop) {
    IfcAirToAirHeatRecoveryType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAirToAirHeatRecoveryType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAirToAirHeatRecoveryType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAirToAirHeatRecoveryType *ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(const IfcAirToAirHeatRecoveryType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAirToAirHeatRecoveryType(this, obj, copyop);
    }
}

IfcAlarmType *ExpressDataSet::getIfcAlarmType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAlarmType * > (current->second.get());
    }
    else {
        IfcAlarmType *ret = static_cast< IfcAlarmType * > (allocateIfcAlarmType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAlarmType(IfcAlarmType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAlarmType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAlarmType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAlarmType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAlarmType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAlarmType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAlarmType > ExpressDataSet::createIfcAlarmType(bool isVolatile) {
    if (isVolatile) {
        return new IfcAlarmType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAlarmType * > (allocateIfcAlarmType(this, Step::Id_UNSET));
    }
}

IfcAlarmType *ExpressDataSet::cloneIfcAlarmType(ExpressDataSet *expressDataSet, const IfcAlarmType &obj, const CopyOp &copyop) {
    IfcAlarmType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAlarmType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAlarmType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAlarmType *ExpressDataSet::cloneIfcAlarmType(const IfcAlarmType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAlarmType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAlarmType(this, obj, copyop);
    }
}

IfcAngularDimension *ExpressDataSet::getIfcAngularDimension(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAngularDimension * > (current->second.get());
    }
    else {
        IfcAngularDimension *ret = static_cast< IfcAngularDimension * > (allocateIfcAngularDimension(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAngularDimension(IfcAngularDimension *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAngularDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAngularDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAngularDimension *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAngularDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAngularDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAngularDimension > ExpressDataSet::createIfcAngularDimension(bool isVolatile) {
    if (isVolatile) {
        return new IfcAngularDimension(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAngularDimension * > (allocateIfcAngularDimension(this, Step::Id_UNSET));
    }
}

IfcAngularDimension *ExpressDataSet::cloneIfcAngularDimension(ExpressDataSet *expressDataSet, const IfcAngularDimension &obj, const CopyOp &copyop) {
    IfcAngularDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAngularDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAngularDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAngularDimension *ExpressDataSet::cloneIfcAngularDimension(const IfcAngularDimension &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAngularDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAngularDimension(this, obj, copyop);
    }
}

IfcAnnotation *ExpressDataSet::getIfcAnnotation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotation * > (current->second.get());
    }
    else {
        IfcAnnotation *ret = static_cast< IfcAnnotation * > (allocateIfcAnnotation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotation(IfcAnnotation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotation > ExpressDataSet::createIfcAnnotation(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotation * > (allocateIfcAnnotation(this, Step::Id_UNSET));
    }
}

IfcAnnotation *ExpressDataSet::cloneIfcAnnotation(ExpressDataSet *expressDataSet, const IfcAnnotation &obj, const CopyOp &copyop) {
    IfcAnnotation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotation *ExpressDataSet::cloneIfcAnnotation(const IfcAnnotation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotation(this, obj, copyop);
    }
}

IfcAnnotationCurveOccurrence *ExpressDataSet::getIfcAnnotationCurveOccurrence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationCurveOccurrence * > (current->second.get());
    }
    else {
        IfcAnnotationCurveOccurrence *ret = static_cast< IfcAnnotationCurveOccurrence * > (allocateIfcAnnotationCurveOccurrence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationCurveOccurrence(IfcAnnotationCurveOccurrence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationCurveOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationCurveOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationCurveOccurrence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationCurveOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationCurveOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationCurveOccurrence > ExpressDataSet::createIfcAnnotationCurveOccurrence(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationCurveOccurrence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationCurveOccurrence * > (allocateIfcAnnotationCurveOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationCurveOccurrence *ExpressDataSet::cloneIfcAnnotationCurveOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationCurveOccurrence &obj, const CopyOp &copyop) {
    IfcAnnotationCurveOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationCurveOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationCurveOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationCurveOccurrence *ExpressDataSet::cloneIfcAnnotationCurveOccurrence(const IfcAnnotationCurveOccurrence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationCurveOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationCurveOccurrence(this, obj, copyop);
    }
}

IfcAnnotationFillArea *ExpressDataSet::getIfcAnnotationFillArea(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationFillArea * > (current->second.get());
    }
    else {
        IfcAnnotationFillArea *ret = static_cast< IfcAnnotationFillArea * > (allocateIfcAnnotationFillArea(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationFillArea(IfcAnnotationFillArea *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationFillArea_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationFillArea(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationFillArea *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationFillArea(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationFillArea_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationFillArea > ExpressDataSet::createIfcAnnotationFillArea(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationFillArea(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationFillArea * > (allocateIfcAnnotationFillArea(this, Step::Id_UNSET));
    }
}

IfcAnnotationFillArea *ExpressDataSet::cloneIfcAnnotationFillArea(ExpressDataSet *expressDataSet, const IfcAnnotationFillArea &obj, const CopyOp &copyop) {
    IfcAnnotationFillArea *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationFillArea(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationFillArea_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationFillArea *ExpressDataSet::cloneIfcAnnotationFillArea(const IfcAnnotationFillArea &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationFillArea(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationFillArea(this, obj, copyop);
    }
}

IfcAnnotationFillAreaOccurrence *ExpressDataSet::getIfcAnnotationFillAreaOccurrence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationFillAreaOccurrence * > (current->second.get());
    }
    else {
        IfcAnnotationFillAreaOccurrence *ret = static_cast< IfcAnnotationFillAreaOccurrence * > (allocateIfcAnnotationFillAreaOccurrence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationFillAreaOccurrence(IfcAnnotationFillAreaOccurrence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationFillAreaOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationFillAreaOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationFillAreaOccurrence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationFillAreaOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationFillAreaOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationFillAreaOccurrence > ExpressDataSet::createIfcAnnotationFillAreaOccurrence(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationFillAreaOccurrence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationFillAreaOccurrence * > (allocateIfcAnnotationFillAreaOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationFillAreaOccurrence *ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationFillAreaOccurrence &obj, const CopyOp &copyop) {
    IfcAnnotationFillAreaOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationFillAreaOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationFillAreaOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationFillAreaOccurrence *ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(const IfcAnnotationFillAreaOccurrence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationFillAreaOccurrence(this, obj, copyop);
    }
}

IfcAnnotationSurface *ExpressDataSet::getIfcAnnotationSurface(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationSurface * > (current->second.get());
    }
    else {
        IfcAnnotationSurface *ret = static_cast< IfcAnnotationSurface * > (allocateIfcAnnotationSurface(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationSurface(IfcAnnotationSurface *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationSurface *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSurface > ExpressDataSet::createIfcAnnotationSurface(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationSurface(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationSurface * > (allocateIfcAnnotationSurface(this, Step::Id_UNSET));
    }
}

IfcAnnotationSurface *ExpressDataSet::cloneIfcAnnotationSurface(ExpressDataSet *expressDataSet, const IfcAnnotationSurface &obj, const CopyOp &copyop) {
    IfcAnnotationSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSurface *ExpressDataSet::cloneIfcAnnotationSurface(const IfcAnnotationSurface &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationSurface(this, obj, copyop);
    }
}

IfcAnnotationSurfaceOccurrence *ExpressDataSet::getIfcAnnotationSurfaceOccurrence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationSurfaceOccurrence * > (current->second.get());
    }
    else {
        IfcAnnotationSurfaceOccurrence *ret = static_cast< IfcAnnotationSurfaceOccurrence * > (allocateIfcAnnotationSurfaceOccurrence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationSurfaceOccurrence(IfcAnnotationSurfaceOccurrence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSurfaceOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSurfaceOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationSurfaceOccurrence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSurfaceOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSurfaceOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSurfaceOccurrence > ExpressDataSet::createIfcAnnotationSurfaceOccurrence(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationSurfaceOccurrence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationSurfaceOccurrence * > (allocateIfcAnnotationSurfaceOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationSurfaceOccurrence *ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationSurfaceOccurrence &obj, const CopyOp &copyop) {
    IfcAnnotationSurfaceOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSurfaceOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSurfaceOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSurfaceOccurrence *ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(const IfcAnnotationSurfaceOccurrence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationSurfaceOccurrence(this, obj, copyop);
    }
}

IfcAnnotationSymbolOccurrence *ExpressDataSet::getIfcAnnotationSymbolOccurrence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationSymbolOccurrence * > (current->second.get());
    }
    else {
        IfcAnnotationSymbolOccurrence *ret = static_cast< IfcAnnotationSymbolOccurrence * > (allocateIfcAnnotationSymbolOccurrence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationSymbolOccurrence(IfcAnnotationSymbolOccurrence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationSymbolOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationSymbolOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationSymbolOccurrence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationSymbolOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationSymbolOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationSymbolOccurrence > ExpressDataSet::createIfcAnnotationSymbolOccurrence(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationSymbolOccurrence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationSymbolOccurrence * > (allocateIfcAnnotationSymbolOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationSymbolOccurrence *ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationSymbolOccurrence &obj, const CopyOp &copyop) {
    IfcAnnotationSymbolOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationSymbolOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationSymbolOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationSymbolOccurrence *ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(const IfcAnnotationSymbolOccurrence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationSymbolOccurrence(this, obj, copyop);
    }
}

IfcAnnotationTextOccurrence *ExpressDataSet::getIfcAnnotationTextOccurrence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAnnotationTextOccurrence * > (current->second.get());
    }
    else {
        IfcAnnotationTextOccurrence *ret = static_cast< IfcAnnotationTextOccurrence * > (allocateIfcAnnotationTextOccurrence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAnnotationTextOccurrence(IfcAnnotationTextOccurrence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAnnotationTextOccurrence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAnnotationTextOccurrence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAnnotationTextOccurrence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAnnotationTextOccurrence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAnnotationTextOccurrence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAnnotationTextOccurrence > ExpressDataSet::createIfcAnnotationTextOccurrence(bool isVolatile) {
    if (isVolatile) {
        return new IfcAnnotationTextOccurrence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAnnotationTextOccurrence * > (allocateIfcAnnotationTextOccurrence(this, Step::Id_UNSET));
    }
}

IfcAnnotationTextOccurrence *ExpressDataSet::cloneIfcAnnotationTextOccurrence(ExpressDataSet *expressDataSet, const IfcAnnotationTextOccurrence &obj, const CopyOp &copyop) {
    IfcAnnotationTextOccurrence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAnnotationTextOccurrence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAnnotationTextOccurrence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAnnotationTextOccurrence *ExpressDataSet::cloneIfcAnnotationTextOccurrence(const IfcAnnotationTextOccurrence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAnnotationTextOccurrence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAnnotationTextOccurrence(this, obj, copyop);
    }
}

IfcApplication *ExpressDataSet::getIfcApplication(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcApplication * > (current->second.get());
    }
    else {
        IfcApplication *ret = static_cast< IfcApplication * > (allocateIfcApplication(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcApplication(IfcApplication *arg) {
    getAll().erase(arg->getKey());
    return m_IfcApplication_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApplication(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcApplication *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApplication(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApplication_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApplication > ExpressDataSet::createIfcApplication(bool isVolatile) {
    if (isVolatile) {
        return new IfcApplication(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcApplication * > (allocateIfcApplication(this, Step::Id_UNSET));
    }
}

IfcApplication *ExpressDataSet::cloneIfcApplication(ExpressDataSet *expressDataSet, const IfcApplication &obj, const CopyOp &copyop) {
    IfcApplication *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApplication(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApplication_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApplication *ExpressDataSet::cloneIfcApplication(const IfcApplication &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcApplication(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcApplication(this, obj, copyop);
    }
}

IfcAppliedValueRelationship *ExpressDataSet::getIfcAppliedValueRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAppliedValueRelationship * > (current->second.get());
    }
    else {
        IfcAppliedValueRelationship *ret = static_cast< IfcAppliedValueRelationship * > (allocateIfcAppliedValueRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAppliedValueRelationship(IfcAppliedValueRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAppliedValueRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAppliedValueRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAppliedValueRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAppliedValueRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAppliedValueRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAppliedValueRelationship > ExpressDataSet::createIfcAppliedValueRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcAppliedValueRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAppliedValueRelationship * > (allocateIfcAppliedValueRelationship(this, Step::Id_UNSET));
    }
}

IfcAppliedValueRelationship *ExpressDataSet::cloneIfcAppliedValueRelationship(ExpressDataSet *expressDataSet, const IfcAppliedValueRelationship &obj, const CopyOp &copyop) {
    IfcAppliedValueRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAppliedValueRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAppliedValueRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAppliedValueRelationship *ExpressDataSet::cloneIfcAppliedValueRelationship(const IfcAppliedValueRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAppliedValueRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAppliedValueRelationship(this, obj, copyop);
    }
}

IfcApproval *ExpressDataSet::getIfcApproval(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcApproval * > (current->second.get());
    }
    else {
        IfcApproval *ret = static_cast< IfcApproval * > (allocateIfcApproval(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcApproval(IfcApproval *arg) {
    getAll().erase(arg->getKey());
    return m_IfcApproval_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApproval(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcApproval *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApproval(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApproval_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApproval > ExpressDataSet::createIfcApproval(bool isVolatile) {
    if (isVolatile) {
        return new IfcApproval(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcApproval * > (allocateIfcApproval(this, Step::Id_UNSET));
    }
}

IfcApproval *ExpressDataSet::cloneIfcApproval(ExpressDataSet *expressDataSet, const IfcApproval &obj, const CopyOp &copyop) {
    IfcApproval *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApproval(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApproval_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApproval *ExpressDataSet::cloneIfcApproval(const IfcApproval &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcApproval(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcApproval(this, obj, copyop);
    }
}

IfcApprovalActorRelationship *ExpressDataSet::getIfcApprovalActorRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcApprovalActorRelationship * > (current->second.get());
    }
    else {
        IfcApprovalActorRelationship *ret = static_cast< IfcApprovalActorRelationship * > (allocateIfcApprovalActorRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcApprovalActorRelationship(IfcApprovalActorRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcApprovalActorRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalActorRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcApprovalActorRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalActorRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalActorRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalActorRelationship > ExpressDataSet::createIfcApprovalActorRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcApprovalActorRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcApprovalActorRelationship * > (allocateIfcApprovalActorRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalActorRelationship *ExpressDataSet::cloneIfcApprovalActorRelationship(ExpressDataSet *expressDataSet, const IfcApprovalActorRelationship &obj, const CopyOp &copyop) {
    IfcApprovalActorRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalActorRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalActorRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalActorRelationship *ExpressDataSet::cloneIfcApprovalActorRelationship(const IfcApprovalActorRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcApprovalActorRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcApprovalActorRelationship(this, obj, copyop);
    }
}

IfcApprovalPropertyRelationship *ExpressDataSet::getIfcApprovalPropertyRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcApprovalPropertyRelationship * > (current->second.get());
    }
    else {
        IfcApprovalPropertyRelationship *ret = static_cast< IfcApprovalPropertyRelationship * > (allocateIfcApprovalPropertyRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcApprovalPropertyRelationship(IfcApprovalPropertyRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcApprovalPropertyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalPropertyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcApprovalPropertyRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalPropertyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalPropertyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalPropertyRelationship > ExpressDataSet::createIfcApprovalPropertyRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcApprovalPropertyRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcApprovalPropertyRelationship * > (allocateIfcApprovalPropertyRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalPropertyRelationship *ExpressDataSet::cloneIfcApprovalPropertyRelationship(ExpressDataSet *expressDataSet, const IfcApprovalPropertyRelationship &obj, const CopyOp &copyop) {
    IfcApprovalPropertyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalPropertyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalPropertyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalPropertyRelationship *ExpressDataSet::cloneIfcApprovalPropertyRelationship(const IfcApprovalPropertyRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcApprovalPropertyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcApprovalPropertyRelationship(this, obj, copyop);
    }
}

IfcApprovalRelationship *ExpressDataSet::getIfcApprovalRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcApprovalRelationship * > (current->second.get());
    }
    else {
        IfcApprovalRelationship *ret = static_cast< IfcApprovalRelationship * > (allocateIfcApprovalRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcApprovalRelationship(IfcApprovalRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcApprovalRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcApprovalRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcApprovalRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcApprovalRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcApprovalRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcApprovalRelationship > ExpressDataSet::createIfcApprovalRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcApprovalRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcApprovalRelationship * > (allocateIfcApprovalRelationship(this, Step::Id_UNSET));
    }
}

IfcApprovalRelationship *ExpressDataSet::cloneIfcApprovalRelationship(ExpressDataSet *expressDataSet, const IfcApprovalRelationship &obj, const CopyOp &copyop) {
    IfcApprovalRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcApprovalRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcApprovalRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcApprovalRelationship *ExpressDataSet::cloneIfcApprovalRelationship(const IfcApprovalRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcApprovalRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcApprovalRelationship(this, obj, copyop);
    }
}

IfcArbitraryClosedProfileDef *ExpressDataSet::getIfcArbitraryClosedProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcArbitraryClosedProfileDef * > (current->second.get());
    }
    else {
        IfcArbitraryClosedProfileDef *ret = static_cast< IfcArbitraryClosedProfileDef * > (allocateIfcArbitraryClosedProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcArbitraryClosedProfileDef(IfcArbitraryClosedProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcArbitraryClosedProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryClosedProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcArbitraryClosedProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryClosedProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryClosedProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryClosedProfileDef > ExpressDataSet::createIfcArbitraryClosedProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcArbitraryClosedProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcArbitraryClosedProfileDef * > (allocateIfcArbitraryClosedProfileDef(this, Step::Id_UNSET));
    }
}

IfcArbitraryClosedProfileDef *ExpressDataSet::cloneIfcArbitraryClosedProfileDef(ExpressDataSet *expressDataSet, const IfcArbitraryClosedProfileDef &obj, const CopyOp &copyop) {
    IfcArbitraryClosedProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryClosedProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryClosedProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryClosedProfileDef *ExpressDataSet::cloneIfcArbitraryClosedProfileDef(const IfcArbitraryClosedProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcArbitraryClosedProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcArbitraryClosedProfileDef(this, obj, copyop);
    }
}

IfcArbitraryOpenProfileDef *ExpressDataSet::getIfcArbitraryOpenProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcArbitraryOpenProfileDef * > (current->second.get());
    }
    else {
        IfcArbitraryOpenProfileDef *ret = static_cast< IfcArbitraryOpenProfileDef * > (allocateIfcArbitraryOpenProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcArbitraryOpenProfileDef(IfcArbitraryOpenProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcArbitraryOpenProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryOpenProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcArbitraryOpenProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryOpenProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryOpenProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryOpenProfileDef > ExpressDataSet::createIfcArbitraryOpenProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcArbitraryOpenProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcArbitraryOpenProfileDef * > (allocateIfcArbitraryOpenProfileDef(this, Step::Id_UNSET));
    }
}

IfcArbitraryOpenProfileDef *ExpressDataSet::cloneIfcArbitraryOpenProfileDef(ExpressDataSet *expressDataSet, const IfcArbitraryOpenProfileDef &obj, const CopyOp &copyop) {
    IfcArbitraryOpenProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryOpenProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryOpenProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryOpenProfileDef *ExpressDataSet::cloneIfcArbitraryOpenProfileDef(const IfcArbitraryOpenProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcArbitraryOpenProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcArbitraryOpenProfileDef(this, obj, copyop);
    }
}

IfcArbitraryProfileDefWithVoids *ExpressDataSet::getIfcArbitraryProfileDefWithVoids(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcArbitraryProfileDefWithVoids * > (current->second.get());
    }
    else {
        IfcArbitraryProfileDefWithVoids *ret = static_cast< IfcArbitraryProfileDefWithVoids * > (allocateIfcArbitraryProfileDefWithVoids(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcArbitraryProfileDefWithVoids(IfcArbitraryProfileDefWithVoids *arg) {
    getAll().erase(arg->getKey());
    return m_IfcArbitraryProfileDefWithVoids_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcArbitraryProfileDefWithVoids(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcArbitraryProfileDefWithVoids *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcArbitraryProfileDefWithVoids(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcArbitraryProfileDefWithVoids_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcArbitraryProfileDefWithVoids > ExpressDataSet::createIfcArbitraryProfileDefWithVoids(bool isVolatile) {
    if (isVolatile) {
        return new IfcArbitraryProfileDefWithVoids(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcArbitraryProfileDefWithVoids * > (allocateIfcArbitraryProfileDefWithVoids(this, Step::Id_UNSET));
    }
}

IfcArbitraryProfileDefWithVoids *ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(ExpressDataSet *expressDataSet, const IfcArbitraryProfileDefWithVoids &obj, const CopyOp &copyop) {
    IfcArbitraryProfileDefWithVoids *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcArbitraryProfileDefWithVoids(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcArbitraryProfileDefWithVoids_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcArbitraryProfileDefWithVoids *ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(const IfcArbitraryProfileDefWithVoids &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcArbitraryProfileDefWithVoids(this, obj, copyop);
    }
}

IfcAsset *ExpressDataSet::getIfcAsset(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAsset * > (current->second.get());
    }
    else {
        IfcAsset *ret = static_cast< IfcAsset * > (allocateIfcAsset(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAsset(IfcAsset *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAsset_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAsset(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAsset *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAsset(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAsset_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAsset > ExpressDataSet::createIfcAsset(bool isVolatile) {
    if (isVolatile) {
        return new IfcAsset(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAsset * > (allocateIfcAsset(this, Step::Id_UNSET));
    }
}

IfcAsset *ExpressDataSet::cloneIfcAsset(ExpressDataSet *expressDataSet, const IfcAsset &obj, const CopyOp &copyop) {
    IfcAsset *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAsset(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAsset_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAsset *ExpressDataSet::cloneIfcAsset(const IfcAsset &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAsset(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAsset(this, obj, copyop);
    }
}

IfcAsymmetricIShapeProfileDef *ExpressDataSet::getIfcAsymmetricIShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAsymmetricIShapeProfileDef * > (current->second.get());
    }
    else {
        IfcAsymmetricIShapeProfileDef *ret = static_cast< IfcAsymmetricIShapeProfileDef * > (allocateIfcAsymmetricIShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAsymmetricIShapeProfileDef(IfcAsymmetricIShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAsymmetricIShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAsymmetricIShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAsymmetricIShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAsymmetricIShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAsymmetricIShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAsymmetricIShapeProfileDef > ExpressDataSet::createIfcAsymmetricIShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcAsymmetricIShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAsymmetricIShapeProfileDef * > (allocateIfcAsymmetricIShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcAsymmetricIShapeProfileDef *ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(ExpressDataSet *expressDataSet, const IfcAsymmetricIShapeProfileDef &obj, const CopyOp &copyop) {
    IfcAsymmetricIShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAsymmetricIShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAsymmetricIShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAsymmetricIShapeProfileDef *ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(const IfcAsymmetricIShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAsymmetricIShapeProfileDef(this, obj, copyop);
    }
}

IfcAxis1Placement *ExpressDataSet::getIfcAxis1Placement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAxis1Placement * > (current->second.get());
    }
    else {
        IfcAxis1Placement *ret = static_cast< IfcAxis1Placement * > (allocateIfcAxis1Placement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAxis1Placement(IfcAxis1Placement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAxis1Placement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis1Placement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAxis1Placement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis1Placement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis1Placement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis1Placement > ExpressDataSet::createIfcAxis1Placement(bool isVolatile) {
    if (isVolatile) {
        return new IfcAxis1Placement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAxis1Placement * > (allocateIfcAxis1Placement(this, Step::Id_UNSET));
    }
}

IfcAxis1Placement *ExpressDataSet::cloneIfcAxis1Placement(ExpressDataSet *expressDataSet, const IfcAxis1Placement &obj, const CopyOp &copyop) {
    IfcAxis1Placement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis1Placement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis1Placement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis1Placement *ExpressDataSet::cloneIfcAxis1Placement(const IfcAxis1Placement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAxis1Placement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAxis1Placement(this, obj, copyop);
    }
}

IfcAxis2Placement2D *ExpressDataSet::getIfcAxis2Placement2D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAxis2Placement2D * > (current->second.get());
    }
    else {
        IfcAxis2Placement2D *ret = static_cast< IfcAxis2Placement2D * > (allocateIfcAxis2Placement2D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAxis2Placement2D(IfcAxis2Placement2D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAxis2Placement2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis2Placement2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAxis2Placement2D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis2Placement2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis2Placement2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis2Placement2D > ExpressDataSet::createIfcAxis2Placement2D(bool isVolatile) {
    if (isVolatile) {
        return new IfcAxis2Placement2D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAxis2Placement2D * > (allocateIfcAxis2Placement2D(this, Step::Id_UNSET));
    }
}

IfcAxis2Placement2D *ExpressDataSet::cloneIfcAxis2Placement2D(ExpressDataSet *expressDataSet, const IfcAxis2Placement2D &obj, const CopyOp &copyop) {
    IfcAxis2Placement2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis2Placement2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis2Placement2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis2Placement2D *ExpressDataSet::cloneIfcAxis2Placement2D(const IfcAxis2Placement2D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAxis2Placement2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAxis2Placement2D(this, obj, copyop);
    }
}

IfcAxis2Placement3D *ExpressDataSet::getIfcAxis2Placement3D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcAxis2Placement3D * > (current->second.get());
    }
    else {
        IfcAxis2Placement3D *ret = static_cast< IfcAxis2Placement3D * > (allocateIfcAxis2Placement3D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcAxis2Placement3D(IfcAxis2Placement3D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcAxis2Placement3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcAxis2Placement3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcAxis2Placement3D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcAxis2Placement3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcAxis2Placement3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcAxis2Placement3D > ExpressDataSet::createIfcAxis2Placement3D(bool isVolatile) {
    if (isVolatile) {
        return new IfcAxis2Placement3D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcAxis2Placement3D * > (allocateIfcAxis2Placement3D(this, Step::Id_UNSET));
    }
}

IfcAxis2Placement3D *ExpressDataSet::cloneIfcAxis2Placement3D(ExpressDataSet *expressDataSet, const IfcAxis2Placement3D &obj, const CopyOp &copyop) {
    IfcAxis2Placement3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcAxis2Placement3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcAxis2Placement3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcAxis2Placement3D *ExpressDataSet::cloneIfcAxis2Placement3D(const IfcAxis2Placement3D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcAxis2Placement3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcAxis2Placement3D(this, obj, copyop);
    }
}

IfcBeam *ExpressDataSet::getIfcBeam(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBeam * > (current->second.get());
    }
    else {
        IfcBeam *ret = static_cast< IfcBeam * > (allocateIfcBeam(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBeam(IfcBeam *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBeam_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBeam(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBeam *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBeam(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBeam_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBeam > ExpressDataSet::createIfcBeam(bool isVolatile) {
    if (isVolatile) {
        return new IfcBeam(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBeam * > (allocateIfcBeam(this, Step::Id_UNSET));
    }
}

IfcBeam *ExpressDataSet::cloneIfcBeam(ExpressDataSet *expressDataSet, const IfcBeam &obj, const CopyOp &copyop) {
    IfcBeam *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBeam(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBeam_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBeam *ExpressDataSet::cloneIfcBeam(const IfcBeam &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBeam(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBeam(this, obj, copyop);
    }
}

IfcBeamType *ExpressDataSet::getIfcBeamType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBeamType * > (current->second.get());
    }
    else {
        IfcBeamType *ret = static_cast< IfcBeamType * > (allocateIfcBeamType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBeamType(IfcBeamType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBeamType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBeamType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBeamType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBeamType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBeamType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBeamType > ExpressDataSet::createIfcBeamType(bool isVolatile) {
    if (isVolatile) {
        return new IfcBeamType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBeamType * > (allocateIfcBeamType(this, Step::Id_UNSET));
    }
}

IfcBeamType *ExpressDataSet::cloneIfcBeamType(ExpressDataSet *expressDataSet, const IfcBeamType &obj, const CopyOp &copyop) {
    IfcBeamType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBeamType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBeamType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBeamType *ExpressDataSet::cloneIfcBeamType(const IfcBeamType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBeamType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBeamType(this, obj, copyop);
    }
}

IfcBezierCurve *ExpressDataSet::getIfcBezierCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBezierCurve * > (current->second.get());
    }
    else {
        IfcBezierCurve *ret = static_cast< IfcBezierCurve * > (allocateIfcBezierCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBezierCurve(IfcBezierCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBezierCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBezierCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBezierCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBezierCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBezierCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBezierCurve > ExpressDataSet::createIfcBezierCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcBezierCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBezierCurve * > (allocateIfcBezierCurve(this, Step::Id_UNSET));
    }
}

IfcBezierCurve *ExpressDataSet::cloneIfcBezierCurve(ExpressDataSet *expressDataSet, const IfcBezierCurve &obj, const CopyOp &copyop) {
    IfcBezierCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBezierCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBezierCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBezierCurve *ExpressDataSet::cloneIfcBezierCurve(const IfcBezierCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBezierCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBezierCurve(this, obj, copyop);
    }
}

IfcBlobTexture *ExpressDataSet::getIfcBlobTexture(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBlobTexture * > (current->second.get());
    }
    else {
        IfcBlobTexture *ret = static_cast< IfcBlobTexture * > (allocateIfcBlobTexture(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBlobTexture(IfcBlobTexture *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBlobTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBlobTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBlobTexture *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBlobTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBlobTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBlobTexture > ExpressDataSet::createIfcBlobTexture(bool isVolatile) {
    if (isVolatile) {
        return new IfcBlobTexture(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBlobTexture * > (allocateIfcBlobTexture(this, Step::Id_UNSET));
    }
}

IfcBlobTexture *ExpressDataSet::cloneIfcBlobTexture(ExpressDataSet *expressDataSet, const IfcBlobTexture &obj, const CopyOp &copyop) {
    IfcBlobTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBlobTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBlobTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBlobTexture *ExpressDataSet::cloneIfcBlobTexture(const IfcBlobTexture &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBlobTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBlobTexture(this, obj, copyop);
    }
}

IfcBlock *ExpressDataSet::getIfcBlock(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBlock * > (current->second.get());
    }
    else {
        IfcBlock *ret = static_cast< IfcBlock * > (allocateIfcBlock(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBlock(IfcBlock *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBlock_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBlock(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBlock *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBlock(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBlock_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBlock > ExpressDataSet::createIfcBlock(bool isVolatile) {
    if (isVolatile) {
        return new IfcBlock(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBlock * > (allocateIfcBlock(this, Step::Id_UNSET));
    }
}

IfcBlock *ExpressDataSet::cloneIfcBlock(ExpressDataSet *expressDataSet, const IfcBlock &obj, const CopyOp &copyop) {
    IfcBlock *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBlock(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBlock_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBlock *ExpressDataSet::cloneIfcBlock(const IfcBlock &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBlock(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBlock(this, obj, copyop);
    }
}

IfcBoilerType *ExpressDataSet::getIfcBoilerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoilerType * > (current->second.get());
    }
    else {
        IfcBoilerType *ret = static_cast< IfcBoilerType * > (allocateIfcBoilerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoilerType(IfcBoilerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoilerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoilerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoilerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoilerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoilerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoilerType > ExpressDataSet::createIfcBoilerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoilerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoilerType * > (allocateIfcBoilerType(this, Step::Id_UNSET));
    }
}

IfcBoilerType *ExpressDataSet::cloneIfcBoilerType(ExpressDataSet *expressDataSet, const IfcBoilerType &obj, const CopyOp &copyop) {
    IfcBoilerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoilerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoilerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoilerType *ExpressDataSet::cloneIfcBoilerType(const IfcBoilerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoilerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoilerType(this, obj, copyop);
    }
}

IfcBooleanClippingResult *ExpressDataSet::getIfcBooleanClippingResult(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBooleanClippingResult * > (current->second.get());
    }
    else {
        IfcBooleanClippingResult *ret = static_cast< IfcBooleanClippingResult * > (allocateIfcBooleanClippingResult(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBooleanClippingResult(IfcBooleanClippingResult *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBooleanClippingResult_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBooleanClippingResult(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBooleanClippingResult *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBooleanClippingResult(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBooleanClippingResult_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBooleanClippingResult > ExpressDataSet::createIfcBooleanClippingResult(bool isVolatile) {
    if (isVolatile) {
        return new IfcBooleanClippingResult(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBooleanClippingResult * > (allocateIfcBooleanClippingResult(this, Step::Id_UNSET));
    }
}

IfcBooleanClippingResult *ExpressDataSet::cloneIfcBooleanClippingResult(ExpressDataSet *expressDataSet, const IfcBooleanClippingResult &obj, const CopyOp &copyop) {
    IfcBooleanClippingResult *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBooleanClippingResult(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBooleanClippingResult_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBooleanClippingResult *ExpressDataSet::cloneIfcBooleanClippingResult(const IfcBooleanClippingResult &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBooleanClippingResult(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBooleanClippingResult(this, obj, copyop);
    }
}

IfcBooleanResult *ExpressDataSet::getIfcBooleanResult(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBooleanResult * > (current->second.get());
    }
    else {
        IfcBooleanResult *ret = static_cast< IfcBooleanResult * > (allocateIfcBooleanResult(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBooleanResult(IfcBooleanResult *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBooleanResult_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBooleanResult(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBooleanResult *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBooleanResult(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBooleanResult_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBooleanResult > ExpressDataSet::createIfcBooleanResult(bool isVolatile) {
    if (isVolatile) {
        return new IfcBooleanResult(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBooleanResult * > (allocateIfcBooleanResult(this, Step::Id_UNSET));
    }
}

IfcBooleanResult *ExpressDataSet::cloneIfcBooleanResult(ExpressDataSet *expressDataSet, const IfcBooleanResult &obj, const CopyOp &copyop) {
    IfcBooleanResult *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBooleanResult(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBooleanResult_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBooleanResult *ExpressDataSet::cloneIfcBooleanResult(const IfcBooleanResult &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBooleanResult(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBooleanResult(this, obj, copyop);
    }
}

IfcBoundaryEdgeCondition *ExpressDataSet::getIfcBoundaryEdgeCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundaryEdgeCondition * > (current->second.get());
    }
    else {
        IfcBoundaryEdgeCondition *ret = static_cast< IfcBoundaryEdgeCondition * > (allocateIfcBoundaryEdgeCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundaryEdgeCondition(IfcBoundaryEdgeCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundaryEdgeCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryEdgeCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundaryEdgeCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryEdgeCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryEdgeCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryEdgeCondition > ExpressDataSet::createIfcBoundaryEdgeCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundaryEdgeCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundaryEdgeCondition * > (allocateIfcBoundaryEdgeCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryEdgeCondition *ExpressDataSet::cloneIfcBoundaryEdgeCondition(ExpressDataSet *expressDataSet, const IfcBoundaryEdgeCondition &obj, const CopyOp &copyop) {
    IfcBoundaryEdgeCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryEdgeCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryEdgeCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryEdgeCondition *ExpressDataSet::cloneIfcBoundaryEdgeCondition(const IfcBoundaryEdgeCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundaryEdgeCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundaryEdgeCondition(this, obj, copyop);
    }
}

IfcBoundaryFaceCondition *ExpressDataSet::getIfcBoundaryFaceCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundaryFaceCondition * > (current->second.get());
    }
    else {
        IfcBoundaryFaceCondition *ret = static_cast< IfcBoundaryFaceCondition * > (allocateIfcBoundaryFaceCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundaryFaceCondition(IfcBoundaryFaceCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundaryFaceCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryFaceCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundaryFaceCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryFaceCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryFaceCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryFaceCondition > ExpressDataSet::createIfcBoundaryFaceCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundaryFaceCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundaryFaceCondition * > (allocateIfcBoundaryFaceCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryFaceCondition *ExpressDataSet::cloneIfcBoundaryFaceCondition(ExpressDataSet *expressDataSet, const IfcBoundaryFaceCondition &obj, const CopyOp &copyop) {
    IfcBoundaryFaceCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryFaceCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryFaceCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryFaceCondition *ExpressDataSet::cloneIfcBoundaryFaceCondition(const IfcBoundaryFaceCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundaryFaceCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundaryFaceCondition(this, obj, copyop);
    }
}

IfcBoundaryNodeCondition *ExpressDataSet::getIfcBoundaryNodeCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundaryNodeCondition * > (current->second.get());
    }
    else {
        IfcBoundaryNodeCondition *ret = static_cast< IfcBoundaryNodeCondition * > (allocateIfcBoundaryNodeCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundaryNodeCondition(IfcBoundaryNodeCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundaryNodeCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryNodeCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundaryNodeCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryNodeCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryNodeCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryNodeCondition > ExpressDataSet::createIfcBoundaryNodeCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundaryNodeCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundaryNodeCondition * > (allocateIfcBoundaryNodeCondition(this, Step::Id_UNSET));
    }
}

IfcBoundaryNodeCondition *ExpressDataSet::cloneIfcBoundaryNodeCondition(ExpressDataSet *expressDataSet, const IfcBoundaryNodeCondition &obj, const CopyOp &copyop) {
    IfcBoundaryNodeCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryNodeCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryNodeCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryNodeCondition *ExpressDataSet::cloneIfcBoundaryNodeCondition(const IfcBoundaryNodeCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundaryNodeCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundaryNodeCondition(this, obj, copyop);
    }
}

IfcBoundaryNodeConditionWarping *ExpressDataSet::getIfcBoundaryNodeConditionWarping(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundaryNodeConditionWarping * > (current->second.get());
    }
    else {
        IfcBoundaryNodeConditionWarping *ret = static_cast< IfcBoundaryNodeConditionWarping * > (allocateIfcBoundaryNodeConditionWarping(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundaryNodeConditionWarping(IfcBoundaryNodeConditionWarping *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundaryNodeConditionWarping_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundaryNodeConditionWarping(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundaryNodeConditionWarping *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundaryNodeConditionWarping(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundaryNodeConditionWarping_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundaryNodeConditionWarping > ExpressDataSet::createIfcBoundaryNodeConditionWarping(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundaryNodeConditionWarping(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundaryNodeConditionWarping * > (allocateIfcBoundaryNodeConditionWarping(this, Step::Id_UNSET));
    }
}

IfcBoundaryNodeConditionWarping *ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(ExpressDataSet *expressDataSet, const IfcBoundaryNodeConditionWarping &obj, const CopyOp &copyop) {
    IfcBoundaryNodeConditionWarping *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundaryNodeConditionWarping(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundaryNodeConditionWarping_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundaryNodeConditionWarping *ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(const IfcBoundaryNodeConditionWarping &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundaryNodeConditionWarping(this, obj, copyop);
    }
}

IfcBoundedSurface *ExpressDataSet::getIfcBoundedSurface(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundedSurface * > (current->second.get());
    }
    else {
        IfcBoundedSurface *ret = static_cast< IfcBoundedSurface * > (allocateIfcBoundedSurface(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundedSurface(IfcBoundedSurface *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundedSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundedSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundedSurface *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundedSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundedSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundedSurface > ExpressDataSet::createIfcBoundedSurface(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundedSurface(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundedSurface * > (allocateIfcBoundedSurface(this, Step::Id_UNSET));
    }
}

IfcBoundedSurface *ExpressDataSet::cloneIfcBoundedSurface(ExpressDataSet *expressDataSet, const IfcBoundedSurface &obj, const CopyOp &copyop) {
    IfcBoundedSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundedSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundedSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundedSurface *ExpressDataSet::cloneIfcBoundedSurface(const IfcBoundedSurface &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundedSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundedSurface(this, obj, copyop);
    }
}

IfcBoundingBox *ExpressDataSet::getIfcBoundingBox(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoundingBox * > (current->second.get());
    }
    else {
        IfcBoundingBox *ret = static_cast< IfcBoundingBox * > (allocateIfcBoundingBox(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoundingBox(IfcBoundingBox *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoundingBox_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoundingBox(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoundingBox *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoundingBox(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoundingBox_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoundingBox > ExpressDataSet::createIfcBoundingBox(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoundingBox(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoundingBox * > (allocateIfcBoundingBox(this, Step::Id_UNSET));
    }
}

IfcBoundingBox *ExpressDataSet::cloneIfcBoundingBox(ExpressDataSet *expressDataSet, const IfcBoundingBox &obj, const CopyOp &copyop) {
    IfcBoundingBox *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoundingBox(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoundingBox_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoundingBox *ExpressDataSet::cloneIfcBoundingBox(const IfcBoundingBox &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoundingBox(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoundingBox(this, obj, copyop);
    }
}

IfcBoxedHalfSpace *ExpressDataSet::getIfcBoxedHalfSpace(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBoxedHalfSpace * > (current->second.get());
    }
    else {
        IfcBoxedHalfSpace *ret = static_cast< IfcBoxedHalfSpace * > (allocateIfcBoxedHalfSpace(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBoxedHalfSpace(IfcBoxedHalfSpace *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBoxedHalfSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBoxedHalfSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBoxedHalfSpace *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBoxedHalfSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBoxedHalfSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBoxedHalfSpace > ExpressDataSet::createIfcBoxedHalfSpace(bool isVolatile) {
    if (isVolatile) {
        return new IfcBoxedHalfSpace(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBoxedHalfSpace * > (allocateIfcBoxedHalfSpace(this, Step::Id_UNSET));
    }
}

IfcBoxedHalfSpace *ExpressDataSet::cloneIfcBoxedHalfSpace(ExpressDataSet *expressDataSet, const IfcBoxedHalfSpace &obj, const CopyOp &copyop) {
    IfcBoxedHalfSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBoxedHalfSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBoxedHalfSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBoxedHalfSpace *ExpressDataSet::cloneIfcBoxedHalfSpace(const IfcBoxedHalfSpace &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBoxedHalfSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBoxedHalfSpace(this, obj, copyop);
    }
}

IfcBuilding *ExpressDataSet::getIfcBuilding(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBuilding * > (current->second.get());
    }
    else {
        IfcBuilding *ret = static_cast< IfcBuilding * > (allocateIfcBuilding(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBuilding(IfcBuilding *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBuilding_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuilding(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBuilding *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuilding(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuilding_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuilding > ExpressDataSet::createIfcBuilding(bool isVolatile) {
    if (isVolatile) {
        return new IfcBuilding(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBuilding * > (allocateIfcBuilding(this, Step::Id_UNSET));
    }
}

IfcBuilding *ExpressDataSet::cloneIfcBuilding(ExpressDataSet *expressDataSet, const IfcBuilding &obj, const CopyOp &copyop) {
    IfcBuilding *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuilding(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuilding_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuilding *ExpressDataSet::cloneIfcBuilding(const IfcBuilding &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBuilding(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBuilding(this, obj, copyop);
    }
}

IfcBuildingElementPart *ExpressDataSet::getIfcBuildingElementPart(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBuildingElementPart * > (current->second.get());
    }
    else {
        IfcBuildingElementPart *ret = static_cast< IfcBuildingElementPart * > (allocateIfcBuildingElementPart(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBuildingElementPart(IfcBuildingElementPart *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementPart_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementPart(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBuildingElementPart *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementPart(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementPart_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementPart > ExpressDataSet::createIfcBuildingElementPart(bool isVolatile) {
    if (isVolatile) {
        return new IfcBuildingElementPart(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBuildingElementPart * > (allocateIfcBuildingElementPart(this, Step::Id_UNSET));
    }
}

IfcBuildingElementPart *ExpressDataSet::cloneIfcBuildingElementPart(ExpressDataSet *expressDataSet, const IfcBuildingElementPart &obj, const CopyOp &copyop) {
    IfcBuildingElementPart *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementPart(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementPart_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementPart *ExpressDataSet::cloneIfcBuildingElementPart(const IfcBuildingElementPart &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBuildingElementPart(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBuildingElementPart(this, obj, copyop);
    }
}

IfcBuildingElementProxy *ExpressDataSet::getIfcBuildingElementProxy(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBuildingElementProxy * > (current->second.get());
    }
    else {
        IfcBuildingElementProxy *ret = static_cast< IfcBuildingElementProxy * > (allocateIfcBuildingElementProxy(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBuildingElementProxy(IfcBuildingElementProxy *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementProxy_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementProxy(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBuildingElementProxy *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementProxy(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementProxy_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementProxy > ExpressDataSet::createIfcBuildingElementProxy(bool isVolatile) {
    if (isVolatile) {
        return new IfcBuildingElementProxy(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBuildingElementProxy * > (allocateIfcBuildingElementProxy(this, Step::Id_UNSET));
    }
}

IfcBuildingElementProxy *ExpressDataSet::cloneIfcBuildingElementProxy(ExpressDataSet *expressDataSet, const IfcBuildingElementProxy &obj, const CopyOp &copyop) {
    IfcBuildingElementProxy *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementProxy(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementProxy_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementProxy *ExpressDataSet::cloneIfcBuildingElementProxy(const IfcBuildingElementProxy &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBuildingElementProxy(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBuildingElementProxy(this, obj, copyop);
    }
}

IfcBuildingElementProxyType *ExpressDataSet::getIfcBuildingElementProxyType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBuildingElementProxyType * > (current->second.get());
    }
    else {
        IfcBuildingElementProxyType *ret = static_cast< IfcBuildingElementProxyType * > (allocateIfcBuildingElementProxyType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBuildingElementProxyType(IfcBuildingElementProxyType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBuildingElementProxyType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingElementProxyType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBuildingElementProxyType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingElementProxyType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingElementProxyType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingElementProxyType > ExpressDataSet::createIfcBuildingElementProxyType(bool isVolatile) {
    if (isVolatile) {
        return new IfcBuildingElementProxyType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBuildingElementProxyType * > (allocateIfcBuildingElementProxyType(this, Step::Id_UNSET));
    }
}

IfcBuildingElementProxyType *ExpressDataSet::cloneIfcBuildingElementProxyType(ExpressDataSet *expressDataSet, const IfcBuildingElementProxyType &obj, const CopyOp &copyop) {
    IfcBuildingElementProxyType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingElementProxyType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingElementProxyType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingElementProxyType *ExpressDataSet::cloneIfcBuildingElementProxyType(const IfcBuildingElementProxyType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBuildingElementProxyType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBuildingElementProxyType(this, obj, copyop);
    }
}

IfcBuildingStorey *ExpressDataSet::getIfcBuildingStorey(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcBuildingStorey * > (current->second.get());
    }
    else {
        IfcBuildingStorey *ret = static_cast< IfcBuildingStorey * > (allocateIfcBuildingStorey(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcBuildingStorey(IfcBuildingStorey *arg) {
    getAll().erase(arg->getKey());
    return m_IfcBuildingStorey_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcBuildingStorey(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcBuildingStorey *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcBuildingStorey(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcBuildingStorey_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcBuildingStorey > ExpressDataSet::createIfcBuildingStorey(bool isVolatile) {
    if (isVolatile) {
        return new IfcBuildingStorey(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcBuildingStorey * > (allocateIfcBuildingStorey(this, Step::Id_UNSET));
    }
}

IfcBuildingStorey *ExpressDataSet::cloneIfcBuildingStorey(ExpressDataSet *expressDataSet, const IfcBuildingStorey &obj, const CopyOp &copyop) {
    IfcBuildingStorey *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcBuildingStorey(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcBuildingStorey_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcBuildingStorey *ExpressDataSet::cloneIfcBuildingStorey(const IfcBuildingStorey &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcBuildingStorey(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcBuildingStorey(this, obj, copyop);
    }
}

IfcCShapeProfileDef *ExpressDataSet::getIfcCShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCShapeProfileDef * > (current->second.get());
    }
    else {
        IfcCShapeProfileDef *ret = static_cast< IfcCShapeProfileDef * > (allocateIfcCShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCShapeProfileDef(IfcCShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCShapeProfileDef > ExpressDataSet::createIfcCShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCShapeProfileDef * > (allocateIfcCShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCShapeProfileDef *ExpressDataSet::cloneIfcCShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCShapeProfileDef &obj, const CopyOp &copyop) {
    IfcCShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCShapeProfileDef *ExpressDataSet::cloneIfcCShapeProfileDef(const IfcCShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCShapeProfileDef(this, obj, copyop);
    }
}

IfcCableCarrierFittingType *ExpressDataSet::getIfcCableCarrierFittingType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCableCarrierFittingType * > (current->second.get());
    }
    else {
        IfcCableCarrierFittingType *ret = static_cast< IfcCableCarrierFittingType * > (allocateIfcCableCarrierFittingType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCableCarrierFittingType(IfcCableCarrierFittingType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCableCarrierFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableCarrierFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCableCarrierFittingType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableCarrierFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableCarrierFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableCarrierFittingType > ExpressDataSet::createIfcCableCarrierFittingType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCableCarrierFittingType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCableCarrierFittingType * > (allocateIfcCableCarrierFittingType(this, Step::Id_UNSET));
    }
}

IfcCableCarrierFittingType *ExpressDataSet::cloneIfcCableCarrierFittingType(ExpressDataSet *expressDataSet, const IfcCableCarrierFittingType &obj, const CopyOp &copyop) {
    IfcCableCarrierFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableCarrierFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableCarrierFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableCarrierFittingType *ExpressDataSet::cloneIfcCableCarrierFittingType(const IfcCableCarrierFittingType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCableCarrierFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCableCarrierFittingType(this, obj, copyop);
    }
}

IfcCableCarrierSegmentType *ExpressDataSet::getIfcCableCarrierSegmentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCableCarrierSegmentType * > (current->second.get());
    }
    else {
        IfcCableCarrierSegmentType *ret = static_cast< IfcCableCarrierSegmentType * > (allocateIfcCableCarrierSegmentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCableCarrierSegmentType(IfcCableCarrierSegmentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCableCarrierSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableCarrierSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCableCarrierSegmentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableCarrierSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableCarrierSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableCarrierSegmentType > ExpressDataSet::createIfcCableCarrierSegmentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCableCarrierSegmentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCableCarrierSegmentType * > (allocateIfcCableCarrierSegmentType(this, Step::Id_UNSET));
    }
}

IfcCableCarrierSegmentType *ExpressDataSet::cloneIfcCableCarrierSegmentType(ExpressDataSet *expressDataSet, const IfcCableCarrierSegmentType &obj, const CopyOp &copyop) {
    IfcCableCarrierSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableCarrierSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableCarrierSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableCarrierSegmentType *ExpressDataSet::cloneIfcCableCarrierSegmentType(const IfcCableCarrierSegmentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCableCarrierSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCableCarrierSegmentType(this, obj, copyop);
    }
}

IfcCableSegmentType *ExpressDataSet::getIfcCableSegmentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCableSegmentType * > (current->second.get());
    }
    else {
        IfcCableSegmentType *ret = static_cast< IfcCableSegmentType * > (allocateIfcCableSegmentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCableSegmentType(IfcCableSegmentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCableSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCableSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCableSegmentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCableSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCableSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCableSegmentType > ExpressDataSet::createIfcCableSegmentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCableSegmentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCableSegmentType * > (allocateIfcCableSegmentType(this, Step::Id_UNSET));
    }
}

IfcCableSegmentType *ExpressDataSet::cloneIfcCableSegmentType(ExpressDataSet *expressDataSet, const IfcCableSegmentType &obj, const CopyOp &copyop) {
    IfcCableSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCableSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCableSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCableSegmentType *ExpressDataSet::cloneIfcCableSegmentType(const IfcCableSegmentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCableSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCableSegmentType(this, obj, copyop);
    }
}

IfcCalendarDate *ExpressDataSet::getIfcCalendarDate(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCalendarDate * > (current->second.get());
    }
    else {
        IfcCalendarDate *ret = static_cast< IfcCalendarDate * > (allocateIfcCalendarDate(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCalendarDate(IfcCalendarDate *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCalendarDate_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCalendarDate(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCalendarDate *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCalendarDate(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCalendarDate_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCalendarDate > ExpressDataSet::createIfcCalendarDate(bool isVolatile) {
    if (isVolatile) {
        return new IfcCalendarDate(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCalendarDate * > (allocateIfcCalendarDate(this, Step::Id_UNSET));
    }
}

IfcCalendarDate *ExpressDataSet::cloneIfcCalendarDate(ExpressDataSet *expressDataSet, const IfcCalendarDate &obj, const CopyOp &copyop) {
    IfcCalendarDate *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCalendarDate(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCalendarDate_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCalendarDate *ExpressDataSet::cloneIfcCalendarDate(const IfcCalendarDate &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCalendarDate(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCalendarDate(this, obj, copyop);
    }
}

IfcCartesianPoint *ExpressDataSet::getIfcCartesianPoint(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCartesianPoint * > (current->second.get());
    }
    else {
        IfcCartesianPoint *ret = static_cast< IfcCartesianPoint * > (allocateIfcCartesianPoint(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCartesianPoint(IfcCartesianPoint *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCartesianPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCartesianPoint *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianPoint > ExpressDataSet::createIfcCartesianPoint(bool isVolatile) {
    if (isVolatile) {
        return new IfcCartesianPoint(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCartesianPoint * > (allocateIfcCartesianPoint(this, Step::Id_UNSET));
    }
}

IfcCartesianPoint *ExpressDataSet::cloneIfcCartesianPoint(ExpressDataSet *expressDataSet, const IfcCartesianPoint &obj, const CopyOp &copyop) {
    IfcCartesianPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianPoint *ExpressDataSet::cloneIfcCartesianPoint(const IfcCartesianPoint &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCartesianPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCartesianPoint(this, obj, copyop);
    }
}

IfcCartesianTransformationOperator2D *ExpressDataSet::getIfcCartesianTransformationOperator2D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCartesianTransformationOperator2D * > (current->second.get());
    }
    else {
        IfcCartesianTransformationOperator2D *ret = static_cast< IfcCartesianTransformationOperator2D * > (allocateIfcCartesianTransformationOperator2D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator2D(IfcCartesianTransformationOperator2D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCartesianTransformationOperator2D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator2D > ExpressDataSet::createIfcCartesianTransformationOperator2D(bool isVolatile) {
    if (isVolatile) {
        return new IfcCartesianTransformationOperator2D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCartesianTransformationOperator2D * > (allocateIfcCartesianTransformationOperator2D(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator2D *ExpressDataSet::cloneIfcCartesianTransformationOperator2D(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator2D &obj, const CopyOp &copyop) {
    IfcCartesianTransformationOperator2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator2D *ExpressDataSet::cloneIfcCartesianTransformationOperator2D(const IfcCartesianTransformationOperator2D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2D(this, obj, copyop);
    }
}

IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::getIfcCartesianTransformationOperator2DnonUniform(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCartesianTransformationOperator2DnonUniform * > (current->second.get());
    }
    else {
        IfcCartesianTransformationOperator2DnonUniform *ret = static_cast< IfcCartesianTransformationOperator2DnonUniform * > (allocateIfcCartesianTransformationOperator2DnonUniform(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator2DnonUniform(IfcCartesianTransformationOperator2DnonUniform *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator2DnonUniform_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator2DnonUniform(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCartesianTransformationOperator2DnonUniform *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator2DnonUniform(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator2DnonUniform_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator2DnonUniform > ExpressDataSet::createIfcCartesianTransformationOperator2DnonUniform(bool isVolatile) {
    if (isVolatile) {
        return new IfcCartesianTransformationOperator2DnonUniform(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCartesianTransformationOperator2DnonUniform * > (allocateIfcCartesianTransformationOperator2DnonUniform(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator2DnonUniform &obj, const CopyOp &copyop) {
    IfcCartesianTransformationOperator2DnonUniform *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator2DnonUniform(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator2DnonUniform_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator2DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(const IfcCartesianTransformationOperator2DnonUniform &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator2DnonUniform(this, obj, copyop);
    }
}

IfcCartesianTransformationOperator3D *ExpressDataSet::getIfcCartesianTransformationOperator3D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCartesianTransformationOperator3D * > (current->second.get());
    }
    else {
        IfcCartesianTransformationOperator3D *ret = static_cast< IfcCartesianTransformationOperator3D * > (allocateIfcCartesianTransformationOperator3D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator3D(IfcCartesianTransformationOperator3D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCartesianTransformationOperator3D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator3D > ExpressDataSet::createIfcCartesianTransformationOperator3D(bool isVolatile) {
    if (isVolatile) {
        return new IfcCartesianTransformationOperator3D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCartesianTransformationOperator3D * > (allocateIfcCartesianTransformationOperator3D(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator3D *ExpressDataSet::cloneIfcCartesianTransformationOperator3D(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator3D &obj, const CopyOp &copyop) {
    IfcCartesianTransformationOperator3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator3D *ExpressDataSet::cloneIfcCartesianTransformationOperator3D(const IfcCartesianTransformationOperator3D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3D(this, obj, copyop);
    }
}

IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::getIfcCartesianTransformationOperator3DnonUniform(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCartesianTransformationOperator3DnonUniform * > (current->second.get());
    }
    else {
        IfcCartesianTransformationOperator3DnonUniform *ret = static_cast< IfcCartesianTransformationOperator3DnonUniform * > (allocateIfcCartesianTransformationOperator3DnonUniform(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCartesianTransformationOperator3DnonUniform(IfcCartesianTransformationOperator3DnonUniform *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCartesianTransformationOperator3DnonUniform_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCartesianTransformationOperator3DnonUniform(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCartesianTransformationOperator3DnonUniform *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCartesianTransformationOperator3DnonUniform(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCartesianTransformationOperator3DnonUniform_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCartesianTransformationOperator3DnonUniform > ExpressDataSet::createIfcCartesianTransformationOperator3DnonUniform(bool isVolatile) {
    if (isVolatile) {
        return new IfcCartesianTransformationOperator3DnonUniform(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCartesianTransformationOperator3DnonUniform * > (allocateIfcCartesianTransformationOperator3DnonUniform(this, Step::Id_UNSET));
    }
}

IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(ExpressDataSet *expressDataSet, const IfcCartesianTransformationOperator3DnonUniform &obj, const CopyOp &copyop) {
    IfcCartesianTransformationOperator3DnonUniform *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCartesianTransformationOperator3DnonUniform(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCartesianTransformationOperator3DnonUniform_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCartesianTransformationOperator3DnonUniform *ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(const IfcCartesianTransformationOperator3DnonUniform &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCartesianTransformationOperator3DnonUniform(this, obj, copyop);
    }
}

IfcCenterLineProfileDef *ExpressDataSet::getIfcCenterLineProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCenterLineProfileDef * > (current->second.get());
    }
    else {
        IfcCenterLineProfileDef *ret = static_cast< IfcCenterLineProfileDef * > (allocateIfcCenterLineProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCenterLineProfileDef(IfcCenterLineProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCenterLineProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCenterLineProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCenterLineProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCenterLineProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCenterLineProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCenterLineProfileDef > ExpressDataSet::createIfcCenterLineProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCenterLineProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCenterLineProfileDef * > (allocateIfcCenterLineProfileDef(this, Step::Id_UNSET));
    }
}

IfcCenterLineProfileDef *ExpressDataSet::cloneIfcCenterLineProfileDef(ExpressDataSet *expressDataSet, const IfcCenterLineProfileDef &obj, const CopyOp &copyop) {
    IfcCenterLineProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCenterLineProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCenterLineProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCenterLineProfileDef *ExpressDataSet::cloneIfcCenterLineProfileDef(const IfcCenterLineProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCenterLineProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCenterLineProfileDef(this, obj, copyop);
    }
}

IfcChamferEdgeFeature *ExpressDataSet::getIfcChamferEdgeFeature(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcChamferEdgeFeature * > (current->second.get());
    }
    else {
        IfcChamferEdgeFeature *ret = static_cast< IfcChamferEdgeFeature * > (allocateIfcChamferEdgeFeature(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcChamferEdgeFeature(IfcChamferEdgeFeature *arg) {
    getAll().erase(arg->getKey());
    return m_IfcChamferEdgeFeature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcChamferEdgeFeature(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcChamferEdgeFeature *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcChamferEdgeFeature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcChamferEdgeFeature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcChamferEdgeFeature > ExpressDataSet::createIfcChamferEdgeFeature(bool isVolatile) {
    if (isVolatile) {
        return new IfcChamferEdgeFeature(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcChamferEdgeFeature * > (allocateIfcChamferEdgeFeature(this, Step::Id_UNSET));
    }
}

IfcChamferEdgeFeature *ExpressDataSet::cloneIfcChamferEdgeFeature(ExpressDataSet *expressDataSet, const IfcChamferEdgeFeature &obj, const CopyOp &copyop) {
    IfcChamferEdgeFeature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcChamferEdgeFeature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcChamferEdgeFeature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcChamferEdgeFeature *ExpressDataSet::cloneIfcChamferEdgeFeature(const IfcChamferEdgeFeature &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcChamferEdgeFeature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcChamferEdgeFeature(this, obj, copyop);
    }
}

IfcChillerType *ExpressDataSet::getIfcChillerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcChillerType * > (current->second.get());
    }
    else {
        IfcChillerType *ret = static_cast< IfcChillerType * > (allocateIfcChillerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcChillerType(IfcChillerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcChillerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcChillerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcChillerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcChillerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcChillerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcChillerType > ExpressDataSet::createIfcChillerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcChillerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcChillerType * > (allocateIfcChillerType(this, Step::Id_UNSET));
    }
}

IfcChillerType *ExpressDataSet::cloneIfcChillerType(ExpressDataSet *expressDataSet, const IfcChillerType &obj, const CopyOp &copyop) {
    IfcChillerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcChillerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcChillerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcChillerType *ExpressDataSet::cloneIfcChillerType(const IfcChillerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcChillerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcChillerType(this, obj, copyop);
    }
}

IfcCircle *ExpressDataSet::getIfcCircle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCircle * > (current->second.get());
    }
    else {
        IfcCircle *ret = static_cast< IfcCircle * > (allocateIfcCircle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCircle(IfcCircle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCircle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCircle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircle > ExpressDataSet::createIfcCircle(bool isVolatile) {
    if (isVolatile) {
        return new IfcCircle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCircle * > (allocateIfcCircle(this, Step::Id_UNSET));
    }
}

IfcCircle *ExpressDataSet::cloneIfcCircle(ExpressDataSet *expressDataSet, const IfcCircle &obj, const CopyOp &copyop) {
    IfcCircle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircle *ExpressDataSet::cloneIfcCircle(const IfcCircle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCircle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCircle(this, obj, copyop);
    }
}

IfcCircleHollowProfileDef *ExpressDataSet::getIfcCircleHollowProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCircleHollowProfileDef * > (current->second.get());
    }
    else {
        IfcCircleHollowProfileDef *ret = static_cast< IfcCircleHollowProfileDef * > (allocateIfcCircleHollowProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCircleHollowProfileDef(IfcCircleHollowProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCircleHollowProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircleHollowProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCircleHollowProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircleHollowProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircleHollowProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircleHollowProfileDef > ExpressDataSet::createIfcCircleHollowProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCircleHollowProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCircleHollowProfileDef * > (allocateIfcCircleHollowProfileDef(this, Step::Id_UNSET));
    }
}

IfcCircleHollowProfileDef *ExpressDataSet::cloneIfcCircleHollowProfileDef(ExpressDataSet *expressDataSet, const IfcCircleHollowProfileDef &obj, const CopyOp &copyop) {
    IfcCircleHollowProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircleHollowProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircleHollowProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircleHollowProfileDef *ExpressDataSet::cloneIfcCircleHollowProfileDef(const IfcCircleHollowProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCircleHollowProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCircleHollowProfileDef(this, obj, copyop);
    }
}

IfcCircleProfileDef *ExpressDataSet::getIfcCircleProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCircleProfileDef * > (current->second.get());
    }
    else {
        IfcCircleProfileDef *ret = static_cast< IfcCircleProfileDef * > (allocateIfcCircleProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCircleProfileDef(IfcCircleProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCircleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCircleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCircleProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCircleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCircleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCircleProfileDef > ExpressDataSet::createIfcCircleProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCircleProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCircleProfileDef * > (allocateIfcCircleProfileDef(this, Step::Id_UNSET));
    }
}

IfcCircleProfileDef *ExpressDataSet::cloneIfcCircleProfileDef(ExpressDataSet *expressDataSet, const IfcCircleProfileDef &obj, const CopyOp &copyop) {
    IfcCircleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCircleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCircleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCircleProfileDef *ExpressDataSet::cloneIfcCircleProfileDef(const IfcCircleProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCircleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCircleProfileDef(this, obj, copyop);
    }
}

IfcClassification *ExpressDataSet::getIfcClassification(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassification * > (current->second.get());
    }
    else {
        IfcClassification *ret = static_cast< IfcClassification * > (allocateIfcClassification(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassification(IfcClassification *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassification_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassification(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassification *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassification(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassification_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassification > ExpressDataSet::createIfcClassification(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassification(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassification * > (allocateIfcClassification(this, Step::Id_UNSET));
    }
}

IfcClassification *ExpressDataSet::cloneIfcClassification(ExpressDataSet *expressDataSet, const IfcClassification &obj, const CopyOp &copyop) {
    IfcClassification *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassification(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassification_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassification *ExpressDataSet::cloneIfcClassification(const IfcClassification &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassification(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassification(this, obj, copyop);
    }
}

IfcClassificationItem *ExpressDataSet::getIfcClassificationItem(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassificationItem * > (current->second.get());
    }
    else {
        IfcClassificationItem *ret = static_cast< IfcClassificationItem * > (allocateIfcClassificationItem(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassificationItem(IfcClassificationItem *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassificationItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassificationItem *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationItem > ExpressDataSet::createIfcClassificationItem(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassificationItem(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassificationItem * > (allocateIfcClassificationItem(this, Step::Id_UNSET));
    }
}

IfcClassificationItem *ExpressDataSet::cloneIfcClassificationItem(ExpressDataSet *expressDataSet, const IfcClassificationItem &obj, const CopyOp &copyop) {
    IfcClassificationItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationItem *ExpressDataSet::cloneIfcClassificationItem(const IfcClassificationItem &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassificationItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassificationItem(this, obj, copyop);
    }
}

IfcClassificationItemRelationship *ExpressDataSet::getIfcClassificationItemRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassificationItemRelationship * > (current->second.get());
    }
    else {
        IfcClassificationItemRelationship *ret = static_cast< IfcClassificationItemRelationship * > (allocateIfcClassificationItemRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassificationItemRelationship(IfcClassificationItemRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassificationItemRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationItemRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassificationItemRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationItemRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationItemRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationItemRelationship > ExpressDataSet::createIfcClassificationItemRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassificationItemRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassificationItemRelationship * > (allocateIfcClassificationItemRelationship(this, Step::Id_UNSET));
    }
}

IfcClassificationItemRelationship *ExpressDataSet::cloneIfcClassificationItemRelationship(ExpressDataSet *expressDataSet, const IfcClassificationItemRelationship &obj, const CopyOp &copyop) {
    IfcClassificationItemRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationItemRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationItemRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationItemRelationship *ExpressDataSet::cloneIfcClassificationItemRelationship(const IfcClassificationItemRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassificationItemRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassificationItemRelationship(this, obj, copyop);
    }
}

IfcClassificationNotation *ExpressDataSet::getIfcClassificationNotation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassificationNotation * > (current->second.get());
    }
    else {
        IfcClassificationNotation *ret = static_cast< IfcClassificationNotation * > (allocateIfcClassificationNotation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassificationNotation(IfcClassificationNotation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassificationNotation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationNotation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassificationNotation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationNotation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationNotation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationNotation > ExpressDataSet::createIfcClassificationNotation(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassificationNotation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassificationNotation * > (allocateIfcClassificationNotation(this, Step::Id_UNSET));
    }
}

IfcClassificationNotation *ExpressDataSet::cloneIfcClassificationNotation(ExpressDataSet *expressDataSet, const IfcClassificationNotation &obj, const CopyOp &copyop) {
    IfcClassificationNotation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationNotation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationNotation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationNotation *ExpressDataSet::cloneIfcClassificationNotation(const IfcClassificationNotation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassificationNotation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassificationNotation(this, obj, copyop);
    }
}

IfcClassificationNotationFacet *ExpressDataSet::getIfcClassificationNotationFacet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassificationNotationFacet * > (current->second.get());
    }
    else {
        IfcClassificationNotationFacet *ret = static_cast< IfcClassificationNotationFacet * > (allocateIfcClassificationNotationFacet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassificationNotationFacet(IfcClassificationNotationFacet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassificationNotationFacet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationNotationFacet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassificationNotationFacet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationNotationFacet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationNotationFacet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationNotationFacet > ExpressDataSet::createIfcClassificationNotationFacet(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassificationNotationFacet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassificationNotationFacet * > (allocateIfcClassificationNotationFacet(this, Step::Id_UNSET));
    }
}

IfcClassificationNotationFacet *ExpressDataSet::cloneIfcClassificationNotationFacet(ExpressDataSet *expressDataSet, const IfcClassificationNotationFacet &obj, const CopyOp &copyop) {
    IfcClassificationNotationFacet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationNotationFacet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationNotationFacet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationNotationFacet *ExpressDataSet::cloneIfcClassificationNotationFacet(const IfcClassificationNotationFacet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassificationNotationFacet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassificationNotationFacet(this, obj, copyop);
    }
}

IfcClassificationReference *ExpressDataSet::getIfcClassificationReference(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClassificationReference * > (current->second.get());
    }
    else {
        IfcClassificationReference *ret = static_cast< IfcClassificationReference * > (allocateIfcClassificationReference(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClassificationReference(IfcClassificationReference *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClassificationReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClassificationReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClassificationReference *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClassificationReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClassificationReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClassificationReference > ExpressDataSet::createIfcClassificationReference(bool isVolatile) {
    if (isVolatile) {
        return new IfcClassificationReference(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClassificationReference * > (allocateIfcClassificationReference(this, Step::Id_UNSET));
    }
}

IfcClassificationReference *ExpressDataSet::cloneIfcClassificationReference(ExpressDataSet *expressDataSet, const IfcClassificationReference &obj, const CopyOp &copyop) {
    IfcClassificationReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClassificationReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClassificationReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClassificationReference *ExpressDataSet::cloneIfcClassificationReference(const IfcClassificationReference &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClassificationReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClassificationReference(this, obj, copyop);
    }
}

IfcClosedShell *ExpressDataSet::getIfcClosedShell(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcClosedShell * > (current->second.get());
    }
    else {
        IfcClosedShell *ret = static_cast< IfcClosedShell * > (allocateIfcClosedShell(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcClosedShell(IfcClosedShell *arg) {
    getAll().erase(arg->getKey());
    return m_IfcClosedShell_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcClosedShell(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcClosedShell *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcClosedShell(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcClosedShell_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcClosedShell > ExpressDataSet::createIfcClosedShell(bool isVolatile) {
    if (isVolatile) {
        return new IfcClosedShell(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcClosedShell * > (allocateIfcClosedShell(this, Step::Id_UNSET));
    }
}

IfcClosedShell *ExpressDataSet::cloneIfcClosedShell(ExpressDataSet *expressDataSet, const IfcClosedShell &obj, const CopyOp &copyop) {
    IfcClosedShell *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcClosedShell(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcClosedShell_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcClosedShell *ExpressDataSet::cloneIfcClosedShell(const IfcClosedShell &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcClosedShell(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcClosedShell(this, obj, copyop);
    }
}

IfcCoilType *ExpressDataSet::getIfcCoilType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCoilType * > (current->second.get());
    }
    else {
        IfcCoilType *ret = static_cast< IfcCoilType * > (allocateIfcCoilType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCoilType(IfcCoilType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCoilType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoilType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCoilType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoilType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoilType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoilType > ExpressDataSet::createIfcCoilType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCoilType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCoilType * > (allocateIfcCoilType(this, Step::Id_UNSET));
    }
}

IfcCoilType *ExpressDataSet::cloneIfcCoilType(ExpressDataSet *expressDataSet, const IfcCoilType &obj, const CopyOp &copyop) {
    IfcCoilType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoilType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoilType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoilType *ExpressDataSet::cloneIfcCoilType(const IfcCoilType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCoilType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCoilType(this, obj, copyop);
    }
}

IfcColourRgb *ExpressDataSet::getIfcColourRgb(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcColourRgb * > (current->second.get());
    }
    else {
        IfcColourRgb *ret = static_cast< IfcColourRgb * > (allocateIfcColourRgb(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcColourRgb(IfcColourRgb *arg) {
    getAll().erase(arg->getKey());
    return m_IfcColourRgb_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColourRgb(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcColourRgb *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColourRgb(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColourRgb_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColourRgb > ExpressDataSet::createIfcColourRgb(bool isVolatile) {
    if (isVolatile) {
        return new IfcColourRgb(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcColourRgb * > (allocateIfcColourRgb(this, Step::Id_UNSET));
    }
}

IfcColourRgb *ExpressDataSet::cloneIfcColourRgb(ExpressDataSet *expressDataSet, const IfcColourRgb &obj, const CopyOp &copyop) {
    IfcColourRgb *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColourRgb(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColourRgb_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColourRgb *ExpressDataSet::cloneIfcColourRgb(const IfcColourRgb &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcColourRgb(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcColourRgb(this, obj, copyop);
    }
}

IfcColumn *ExpressDataSet::getIfcColumn(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcColumn * > (current->second.get());
    }
    else {
        IfcColumn *ret = static_cast< IfcColumn * > (allocateIfcColumn(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcColumn(IfcColumn *arg) {
    getAll().erase(arg->getKey());
    return m_IfcColumn_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColumn(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcColumn *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColumn(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColumn_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColumn > ExpressDataSet::createIfcColumn(bool isVolatile) {
    if (isVolatile) {
        return new IfcColumn(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcColumn * > (allocateIfcColumn(this, Step::Id_UNSET));
    }
}

IfcColumn *ExpressDataSet::cloneIfcColumn(ExpressDataSet *expressDataSet, const IfcColumn &obj, const CopyOp &copyop) {
    IfcColumn *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColumn(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColumn_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColumn *ExpressDataSet::cloneIfcColumn(const IfcColumn &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcColumn(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcColumn(this, obj, copyop);
    }
}

IfcColumnType *ExpressDataSet::getIfcColumnType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcColumnType * > (current->second.get());
    }
    else {
        IfcColumnType *ret = static_cast< IfcColumnType * > (allocateIfcColumnType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcColumnType(IfcColumnType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcColumnType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcColumnType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcColumnType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcColumnType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcColumnType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcColumnType > ExpressDataSet::createIfcColumnType(bool isVolatile) {
    if (isVolatile) {
        return new IfcColumnType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcColumnType * > (allocateIfcColumnType(this, Step::Id_UNSET));
    }
}

IfcColumnType *ExpressDataSet::cloneIfcColumnType(ExpressDataSet *expressDataSet, const IfcColumnType &obj, const CopyOp &copyop) {
    IfcColumnType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcColumnType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcColumnType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcColumnType *ExpressDataSet::cloneIfcColumnType(const IfcColumnType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcColumnType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcColumnType(this, obj, copyop);
    }
}

IfcComplexProperty *ExpressDataSet::getIfcComplexProperty(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcComplexProperty * > (current->second.get());
    }
    else {
        IfcComplexProperty *ret = static_cast< IfcComplexProperty * > (allocateIfcComplexProperty(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcComplexProperty(IfcComplexProperty *arg) {
    getAll().erase(arg->getKey());
    return m_IfcComplexProperty_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcComplexProperty(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcComplexProperty *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcComplexProperty(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcComplexProperty_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcComplexProperty > ExpressDataSet::createIfcComplexProperty(bool isVolatile) {
    if (isVolatile) {
        return new IfcComplexProperty(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcComplexProperty * > (allocateIfcComplexProperty(this, Step::Id_UNSET));
    }
}

IfcComplexProperty *ExpressDataSet::cloneIfcComplexProperty(ExpressDataSet *expressDataSet, const IfcComplexProperty &obj, const CopyOp &copyop) {
    IfcComplexProperty *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcComplexProperty(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcComplexProperty_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcComplexProperty *ExpressDataSet::cloneIfcComplexProperty(const IfcComplexProperty &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcComplexProperty(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcComplexProperty(this, obj, copyop);
    }
}

IfcCompositeCurve *ExpressDataSet::getIfcCompositeCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCompositeCurve * > (current->second.get());
    }
    else {
        IfcCompositeCurve *ret = static_cast< IfcCompositeCurve * > (allocateIfcCompositeCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCompositeCurve(IfcCompositeCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCompositeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCompositeCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeCurve > ExpressDataSet::createIfcCompositeCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcCompositeCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCompositeCurve * > (allocateIfcCompositeCurve(this, Step::Id_UNSET));
    }
}

IfcCompositeCurve *ExpressDataSet::cloneIfcCompositeCurve(ExpressDataSet *expressDataSet, const IfcCompositeCurve &obj, const CopyOp &copyop) {
    IfcCompositeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeCurve *ExpressDataSet::cloneIfcCompositeCurve(const IfcCompositeCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCompositeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCompositeCurve(this, obj, copyop);
    }
}

IfcCompositeCurveSegment *ExpressDataSet::getIfcCompositeCurveSegment(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCompositeCurveSegment * > (current->second.get());
    }
    else {
        IfcCompositeCurveSegment *ret = static_cast< IfcCompositeCurveSegment * > (allocateIfcCompositeCurveSegment(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCompositeCurveSegment(IfcCompositeCurveSegment *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCompositeCurveSegment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeCurveSegment(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCompositeCurveSegment *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeCurveSegment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeCurveSegment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeCurveSegment > ExpressDataSet::createIfcCompositeCurveSegment(bool isVolatile) {
    if (isVolatile) {
        return new IfcCompositeCurveSegment(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCompositeCurveSegment * > (allocateIfcCompositeCurveSegment(this, Step::Id_UNSET));
    }
}

IfcCompositeCurveSegment *ExpressDataSet::cloneIfcCompositeCurveSegment(ExpressDataSet *expressDataSet, const IfcCompositeCurveSegment &obj, const CopyOp &copyop) {
    IfcCompositeCurveSegment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeCurveSegment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeCurveSegment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeCurveSegment *ExpressDataSet::cloneIfcCompositeCurveSegment(const IfcCompositeCurveSegment &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCompositeCurveSegment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCompositeCurveSegment(this, obj, copyop);
    }
}

IfcCompositeProfileDef *ExpressDataSet::getIfcCompositeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCompositeProfileDef * > (current->second.get());
    }
    else {
        IfcCompositeProfileDef *ret = static_cast< IfcCompositeProfileDef * > (allocateIfcCompositeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCompositeProfileDef(IfcCompositeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCompositeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompositeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCompositeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompositeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompositeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompositeProfileDef > ExpressDataSet::createIfcCompositeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCompositeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCompositeProfileDef * > (allocateIfcCompositeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCompositeProfileDef *ExpressDataSet::cloneIfcCompositeProfileDef(ExpressDataSet *expressDataSet, const IfcCompositeProfileDef &obj, const CopyOp &copyop) {
    IfcCompositeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompositeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompositeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompositeProfileDef *ExpressDataSet::cloneIfcCompositeProfileDef(const IfcCompositeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCompositeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCompositeProfileDef(this, obj, copyop);
    }
}

IfcCompressorType *ExpressDataSet::getIfcCompressorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCompressorType * > (current->second.get());
    }
    else {
        IfcCompressorType *ret = static_cast< IfcCompressorType * > (allocateIfcCompressorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCompressorType(IfcCompressorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCompressorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCompressorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCompressorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCompressorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCompressorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCompressorType > ExpressDataSet::createIfcCompressorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCompressorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCompressorType * > (allocateIfcCompressorType(this, Step::Id_UNSET));
    }
}

IfcCompressorType *ExpressDataSet::cloneIfcCompressorType(ExpressDataSet *expressDataSet, const IfcCompressorType &obj, const CopyOp &copyop) {
    IfcCompressorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCompressorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCompressorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCompressorType *ExpressDataSet::cloneIfcCompressorType(const IfcCompressorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCompressorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCompressorType(this, obj, copyop);
    }
}

IfcCondenserType *ExpressDataSet::getIfcCondenserType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCondenserType * > (current->second.get());
    }
    else {
        IfcCondenserType *ret = static_cast< IfcCondenserType * > (allocateIfcCondenserType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCondenserType(IfcCondenserType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCondenserType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCondenserType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCondenserType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCondenserType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCondenserType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCondenserType > ExpressDataSet::createIfcCondenserType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCondenserType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCondenserType * > (allocateIfcCondenserType(this, Step::Id_UNSET));
    }
}

IfcCondenserType *ExpressDataSet::cloneIfcCondenserType(ExpressDataSet *expressDataSet, const IfcCondenserType &obj, const CopyOp &copyop) {
    IfcCondenserType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCondenserType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCondenserType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCondenserType *ExpressDataSet::cloneIfcCondenserType(const IfcCondenserType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCondenserType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCondenserType(this, obj, copyop);
    }
}

IfcCondition *ExpressDataSet::getIfcCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCondition * > (current->second.get());
    }
    else {
        IfcCondition *ret = static_cast< IfcCondition * > (allocateIfcCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCondition(IfcCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCondition > ExpressDataSet::createIfcCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCondition * > (allocateIfcCondition(this, Step::Id_UNSET));
    }
}

IfcCondition *ExpressDataSet::cloneIfcCondition(ExpressDataSet *expressDataSet, const IfcCondition &obj, const CopyOp &copyop) {
    IfcCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCondition *ExpressDataSet::cloneIfcCondition(const IfcCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCondition(this, obj, copyop);
    }
}

IfcConditionCriterion *ExpressDataSet::getIfcConditionCriterion(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConditionCriterion * > (current->second.get());
    }
    else {
        IfcConditionCriterion *ret = static_cast< IfcConditionCriterion * > (allocateIfcConditionCriterion(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConditionCriterion(IfcConditionCriterion *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConditionCriterion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConditionCriterion(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConditionCriterion *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConditionCriterion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConditionCriterion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConditionCriterion > ExpressDataSet::createIfcConditionCriterion(bool isVolatile) {
    if (isVolatile) {
        return new IfcConditionCriterion(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConditionCriterion * > (allocateIfcConditionCriterion(this, Step::Id_UNSET));
    }
}

IfcConditionCriterion *ExpressDataSet::cloneIfcConditionCriterion(ExpressDataSet *expressDataSet, const IfcConditionCriterion &obj, const CopyOp &copyop) {
    IfcConditionCriterion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConditionCriterion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConditionCriterion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConditionCriterion *ExpressDataSet::cloneIfcConditionCriterion(const IfcConditionCriterion &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConditionCriterion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConditionCriterion(this, obj, copyop);
    }
}

IfcConnectedFaceSet *ExpressDataSet::getIfcConnectedFaceSet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectedFaceSet * > (current->second.get());
    }
    else {
        IfcConnectedFaceSet *ret = static_cast< IfcConnectedFaceSet * > (allocateIfcConnectedFaceSet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectedFaceSet(IfcConnectedFaceSet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectedFaceSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectedFaceSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectedFaceSet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectedFaceSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectedFaceSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectedFaceSet > ExpressDataSet::createIfcConnectedFaceSet(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectedFaceSet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectedFaceSet * > (allocateIfcConnectedFaceSet(this, Step::Id_UNSET));
    }
}

IfcConnectedFaceSet *ExpressDataSet::cloneIfcConnectedFaceSet(ExpressDataSet *expressDataSet, const IfcConnectedFaceSet &obj, const CopyOp &copyop) {
    IfcConnectedFaceSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectedFaceSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectedFaceSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectedFaceSet *ExpressDataSet::cloneIfcConnectedFaceSet(const IfcConnectedFaceSet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectedFaceSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectedFaceSet(this, obj, copyop);
    }
}

IfcConnectionCurveGeometry *ExpressDataSet::getIfcConnectionCurveGeometry(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectionCurveGeometry * > (current->second.get());
    }
    else {
        IfcConnectionCurveGeometry *ret = static_cast< IfcConnectionCurveGeometry * > (allocateIfcConnectionCurveGeometry(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectionCurveGeometry(IfcConnectionCurveGeometry *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectionCurveGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionCurveGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectionCurveGeometry *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionCurveGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionCurveGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionCurveGeometry > ExpressDataSet::createIfcConnectionCurveGeometry(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectionCurveGeometry(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectionCurveGeometry * > (allocateIfcConnectionCurveGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionCurveGeometry *ExpressDataSet::cloneIfcConnectionCurveGeometry(ExpressDataSet *expressDataSet, const IfcConnectionCurveGeometry &obj, const CopyOp &copyop) {
    IfcConnectionCurveGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionCurveGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionCurveGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionCurveGeometry *ExpressDataSet::cloneIfcConnectionCurveGeometry(const IfcConnectionCurveGeometry &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectionCurveGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectionCurveGeometry(this, obj, copyop);
    }
}

IfcConnectionPointEccentricity *ExpressDataSet::getIfcConnectionPointEccentricity(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectionPointEccentricity * > (current->second.get());
    }
    else {
        IfcConnectionPointEccentricity *ret = static_cast< IfcConnectionPointEccentricity * > (allocateIfcConnectionPointEccentricity(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectionPointEccentricity(IfcConnectionPointEccentricity *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectionPointEccentricity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPointEccentricity(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectionPointEccentricity *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPointEccentricity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPointEccentricity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPointEccentricity > ExpressDataSet::createIfcConnectionPointEccentricity(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectionPointEccentricity(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectionPointEccentricity * > (allocateIfcConnectionPointEccentricity(this, Step::Id_UNSET));
    }
}

IfcConnectionPointEccentricity *ExpressDataSet::cloneIfcConnectionPointEccentricity(ExpressDataSet *expressDataSet, const IfcConnectionPointEccentricity &obj, const CopyOp &copyop) {
    IfcConnectionPointEccentricity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPointEccentricity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPointEccentricity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPointEccentricity *ExpressDataSet::cloneIfcConnectionPointEccentricity(const IfcConnectionPointEccentricity &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectionPointEccentricity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectionPointEccentricity(this, obj, copyop);
    }
}

IfcConnectionPointGeometry *ExpressDataSet::getIfcConnectionPointGeometry(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectionPointGeometry * > (current->second.get());
    }
    else {
        IfcConnectionPointGeometry *ret = static_cast< IfcConnectionPointGeometry * > (allocateIfcConnectionPointGeometry(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectionPointGeometry(IfcConnectionPointGeometry *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectionPointGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPointGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectionPointGeometry *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPointGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPointGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPointGeometry > ExpressDataSet::createIfcConnectionPointGeometry(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectionPointGeometry(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectionPointGeometry * > (allocateIfcConnectionPointGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionPointGeometry *ExpressDataSet::cloneIfcConnectionPointGeometry(ExpressDataSet *expressDataSet, const IfcConnectionPointGeometry &obj, const CopyOp &copyop) {
    IfcConnectionPointGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPointGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPointGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPointGeometry *ExpressDataSet::cloneIfcConnectionPointGeometry(const IfcConnectionPointGeometry &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectionPointGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectionPointGeometry(this, obj, copyop);
    }
}

IfcConnectionPortGeometry *ExpressDataSet::getIfcConnectionPortGeometry(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectionPortGeometry * > (current->second.get());
    }
    else {
        IfcConnectionPortGeometry *ret = static_cast< IfcConnectionPortGeometry * > (allocateIfcConnectionPortGeometry(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectionPortGeometry(IfcConnectionPortGeometry *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectionPortGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionPortGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectionPortGeometry *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionPortGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionPortGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionPortGeometry > ExpressDataSet::createIfcConnectionPortGeometry(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectionPortGeometry(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectionPortGeometry * > (allocateIfcConnectionPortGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionPortGeometry *ExpressDataSet::cloneIfcConnectionPortGeometry(ExpressDataSet *expressDataSet, const IfcConnectionPortGeometry &obj, const CopyOp &copyop) {
    IfcConnectionPortGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionPortGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionPortGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionPortGeometry *ExpressDataSet::cloneIfcConnectionPortGeometry(const IfcConnectionPortGeometry &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectionPortGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectionPortGeometry(this, obj, copyop);
    }
}

IfcConnectionSurfaceGeometry *ExpressDataSet::getIfcConnectionSurfaceGeometry(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConnectionSurfaceGeometry * > (current->second.get());
    }
    else {
        IfcConnectionSurfaceGeometry *ret = static_cast< IfcConnectionSurfaceGeometry * > (allocateIfcConnectionSurfaceGeometry(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConnectionSurfaceGeometry(IfcConnectionSurfaceGeometry *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConnectionSurfaceGeometry_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConnectionSurfaceGeometry(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConnectionSurfaceGeometry *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConnectionSurfaceGeometry(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConnectionSurfaceGeometry_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConnectionSurfaceGeometry > ExpressDataSet::createIfcConnectionSurfaceGeometry(bool isVolatile) {
    if (isVolatile) {
        return new IfcConnectionSurfaceGeometry(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConnectionSurfaceGeometry * > (allocateIfcConnectionSurfaceGeometry(this, Step::Id_UNSET));
    }
}

IfcConnectionSurfaceGeometry *ExpressDataSet::cloneIfcConnectionSurfaceGeometry(ExpressDataSet *expressDataSet, const IfcConnectionSurfaceGeometry &obj, const CopyOp &copyop) {
    IfcConnectionSurfaceGeometry *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConnectionSurfaceGeometry(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConnectionSurfaceGeometry_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConnectionSurfaceGeometry *ExpressDataSet::cloneIfcConnectionSurfaceGeometry(const IfcConnectionSurfaceGeometry &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConnectionSurfaceGeometry(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConnectionSurfaceGeometry(this, obj, copyop);
    }
}

IfcConstraintAggregationRelationship *ExpressDataSet::getIfcConstraintAggregationRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstraintAggregationRelationship * > (current->second.get());
    }
    else {
        IfcConstraintAggregationRelationship *ret = static_cast< IfcConstraintAggregationRelationship * > (allocateIfcConstraintAggregationRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstraintAggregationRelationship(IfcConstraintAggregationRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstraintAggregationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintAggregationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstraintAggregationRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintAggregationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintAggregationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintAggregationRelationship > ExpressDataSet::createIfcConstraintAggregationRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstraintAggregationRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstraintAggregationRelationship * > (allocateIfcConstraintAggregationRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintAggregationRelationship *ExpressDataSet::cloneIfcConstraintAggregationRelationship(ExpressDataSet *expressDataSet, const IfcConstraintAggregationRelationship &obj, const CopyOp &copyop) {
    IfcConstraintAggregationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintAggregationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintAggregationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintAggregationRelationship *ExpressDataSet::cloneIfcConstraintAggregationRelationship(const IfcConstraintAggregationRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstraintAggregationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstraintAggregationRelationship(this, obj, copyop);
    }
}

IfcConstraintClassificationRelationship *ExpressDataSet::getIfcConstraintClassificationRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstraintClassificationRelationship * > (current->second.get());
    }
    else {
        IfcConstraintClassificationRelationship *ret = static_cast< IfcConstraintClassificationRelationship * > (allocateIfcConstraintClassificationRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstraintClassificationRelationship(IfcConstraintClassificationRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstraintClassificationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintClassificationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstraintClassificationRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintClassificationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintClassificationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintClassificationRelationship > ExpressDataSet::createIfcConstraintClassificationRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstraintClassificationRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstraintClassificationRelationship * > (allocateIfcConstraintClassificationRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintClassificationRelationship *ExpressDataSet::cloneIfcConstraintClassificationRelationship(ExpressDataSet *expressDataSet, const IfcConstraintClassificationRelationship &obj, const CopyOp &copyop) {
    IfcConstraintClassificationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintClassificationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintClassificationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintClassificationRelationship *ExpressDataSet::cloneIfcConstraintClassificationRelationship(const IfcConstraintClassificationRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstraintClassificationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstraintClassificationRelationship(this, obj, copyop);
    }
}

IfcConstraintRelationship *ExpressDataSet::getIfcConstraintRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstraintRelationship * > (current->second.get());
    }
    else {
        IfcConstraintRelationship *ret = static_cast< IfcConstraintRelationship * > (allocateIfcConstraintRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstraintRelationship(IfcConstraintRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstraintRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstraintRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstraintRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstraintRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstraintRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstraintRelationship > ExpressDataSet::createIfcConstraintRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstraintRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstraintRelationship * > (allocateIfcConstraintRelationship(this, Step::Id_UNSET));
    }
}

IfcConstraintRelationship *ExpressDataSet::cloneIfcConstraintRelationship(ExpressDataSet *expressDataSet, const IfcConstraintRelationship &obj, const CopyOp &copyop) {
    IfcConstraintRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstraintRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstraintRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstraintRelationship *ExpressDataSet::cloneIfcConstraintRelationship(const IfcConstraintRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstraintRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstraintRelationship(this, obj, copyop);
    }
}

IfcConstructionEquipmentResource *ExpressDataSet::getIfcConstructionEquipmentResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstructionEquipmentResource * > (current->second.get());
    }
    else {
        IfcConstructionEquipmentResource *ret = static_cast< IfcConstructionEquipmentResource * > (allocateIfcConstructionEquipmentResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstructionEquipmentResource(IfcConstructionEquipmentResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstructionEquipmentResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionEquipmentResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstructionEquipmentResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionEquipmentResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionEquipmentResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionEquipmentResource > ExpressDataSet::createIfcConstructionEquipmentResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstructionEquipmentResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstructionEquipmentResource * > (allocateIfcConstructionEquipmentResource(this, Step::Id_UNSET));
    }
}

IfcConstructionEquipmentResource *ExpressDataSet::cloneIfcConstructionEquipmentResource(ExpressDataSet *expressDataSet, const IfcConstructionEquipmentResource &obj, const CopyOp &copyop) {
    IfcConstructionEquipmentResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionEquipmentResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionEquipmentResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionEquipmentResource *ExpressDataSet::cloneIfcConstructionEquipmentResource(const IfcConstructionEquipmentResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstructionEquipmentResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstructionEquipmentResource(this, obj, copyop);
    }
}

IfcConstructionMaterialResource *ExpressDataSet::getIfcConstructionMaterialResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstructionMaterialResource * > (current->second.get());
    }
    else {
        IfcConstructionMaterialResource *ret = static_cast< IfcConstructionMaterialResource * > (allocateIfcConstructionMaterialResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstructionMaterialResource(IfcConstructionMaterialResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstructionMaterialResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionMaterialResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstructionMaterialResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionMaterialResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionMaterialResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionMaterialResource > ExpressDataSet::createIfcConstructionMaterialResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstructionMaterialResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstructionMaterialResource * > (allocateIfcConstructionMaterialResource(this, Step::Id_UNSET));
    }
}

IfcConstructionMaterialResource *ExpressDataSet::cloneIfcConstructionMaterialResource(ExpressDataSet *expressDataSet, const IfcConstructionMaterialResource &obj, const CopyOp &copyop) {
    IfcConstructionMaterialResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionMaterialResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionMaterialResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionMaterialResource *ExpressDataSet::cloneIfcConstructionMaterialResource(const IfcConstructionMaterialResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstructionMaterialResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstructionMaterialResource(this, obj, copyop);
    }
}

IfcConstructionProductResource *ExpressDataSet::getIfcConstructionProductResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConstructionProductResource * > (current->second.get());
    }
    else {
        IfcConstructionProductResource *ret = static_cast< IfcConstructionProductResource * > (allocateIfcConstructionProductResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConstructionProductResource(IfcConstructionProductResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConstructionProductResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConstructionProductResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConstructionProductResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConstructionProductResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConstructionProductResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConstructionProductResource > ExpressDataSet::createIfcConstructionProductResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcConstructionProductResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConstructionProductResource * > (allocateIfcConstructionProductResource(this, Step::Id_UNSET));
    }
}

IfcConstructionProductResource *ExpressDataSet::cloneIfcConstructionProductResource(ExpressDataSet *expressDataSet, const IfcConstructionProductResource &obj, const CopyOp &copyop) {
    IfcConstructionProductResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConstructionProductResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConstructionProductResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConstructionProductResource *ExpressDataSet::cloneIfcConstructionProductResource(const IfcConstructionProductResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConstructionProductResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConstructionProductResource(this, obj, copyop);
    }
}

IfcContextDependentUnit *ExpressDataSet::getIfcContextDependentUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcContextDependentUnit * > (current->second.get());
    }
    else {
        IfcContextDependentUnit *ret = static_cast< IfcContextDependentUnit * > (allocateIfcContextDependentUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcContextDependentUnit(IfcContextDependentUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcContextDependentUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcContextDependentUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcContextDependentUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcContextDependentUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcContextDependentUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcContextDependentUnit > ExpressDataSet::createIfcContextDependentUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcContextDependentUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcContextDependentUnit * > (allocateIfcContextDependentUnit(this, Step::Id_UNSET));
    }
}

IfcContextDependentUnit *ExpressDataSet::cloneIfcContextDependentUnit(ExpressDataSet *expressDataSet, const IfcContextDependentUnit &obj, const CopyOp &copyop) {
    IfcContextDependentUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcContextDependentUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcContextDependentUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcContextDependentUnit *ExpressDataSet::cloneIfcContextDependentUnit(const IfcContextDependentUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcContextDependentUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcContextDependentUnit(this, obj, copyop);
    }
}

IfcControllerType *ExpressDataSet::getIfcControllerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcControllerType * > (current->second.get());
    }
    else {
        IfcControllerType *ret = static_cast< IfcControllerType * > (allocateIfcControllerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcControllerType(IfcControllerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcControllerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcControllerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcControllerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcControllerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcControllerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcControllerType > ExpressDataSet::createIfcControllerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcControllerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcControllerType * > (allocateIfcControllerType(this, Step::Id_UNSET));
    }
}

IfcControllerType *ExpressDataSet::cloneIfcControllerType(ExpressDataSet *expressDataSet, const IfcControllerType &obj, const CopyOp &copyop) {
    IfcControllerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcControllerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcControllerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcControllerType *ExpressDataSet::cloneIfcControllerType(const IfcControllerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcControllerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcControllerType(this, obj, copyop);
    }
}

IfcConversionBasedUnit *ExpressDataSet::getIfcConversionBasedUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcConversionBasedUnit * > (current->second.get());
    }
    else {
        IfcConversionBasedUnit *ret = static_cast< IfcConversionBasedUnit * > (allocateIfcConversionBasedUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcConversionBasedUnit(IfcConversionBasedUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcConversionBasedUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcConversionBasedUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcConversionBasedUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcConversionBasedUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcConversionBasedUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcConversionBasedUnit > ExpressDataSet::createIfcConversionBasedUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcConversionBasedUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcConversionBasedUnit * > (allocateIfcConversionBasedUnit(this, Step::Id_UNSET));
    }
}

IfcConversionBasedUnit *ExpressDataSet::cloneIfcConversionBasedUnit(ExpressDataSet *expressDataSet, const IfcConversionBasedUnit &obj, const CopyOp &copyop) {
    IfcConversionBasedUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcConversionBasedUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcConversionBasedUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcConversionBasedUnit *ExpressDataSet::cloneIfcConversionBasedUnit(const IfcConversionBasedUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcConversionBasedUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcConversionBasedUnit(this, obj, copyop);
    }
}

IfcCooledBeamType *ExpressDataSet::getIfcCooledBeamType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCooledBeamType * > (current->second.get());
    }
    else {
        IfcCooledBeamType *ret = static_cast< IfcCooledBeamType * > (allocateIfcCooledBeamType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCooledBeamType(IfcCooledBeamType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCooledBeamType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCooledBeamType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCooledBeamType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCooledBeamType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCooledBeamType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCooledBeamType > ExpressDataSet::createIfcCooledBeamType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCooledBeamType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCooledBeamType * > (allocateIfcCooledBeamType(this, Step::Id_UNSET));
    }
}

IfcCooledBeamType *ExpressDataSet::cloneIfcCooledBeamType(ExpressDataSet *expressDataSet, const IfcCooledBeamType &obj, const CopyOp &copyop) {
    IfcCooledBeamType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCooledBeamType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCooledBeamType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCooledBeamType *ExpressDataSet::cloneIfcCooledBeamType(const IfcCooledBeamType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCooledBeamType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCooledBeamType(this, obj, copyop);
    }
}

IfcCoolingTowerType *ExpressDataSet::getIfcCoolingTowerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCoolingTowerType * > (current->second.get());
    }
    else {
        IfcCoolingTowerType *ret = static_cast< IfcCoolingTowerType * > (allocateIfcCoolingTowerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCoolingTowerType(IfcCoolingTowerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCoolingTowerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoolingTowerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCoolingTowerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoolingTowerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoolingTowerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoolingTowerType > ExpressDataSet::createIfcCoolingTowerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCoolingTowerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCoolingTowerType * > (allocateIfcCoolingTowerType(this, Step::Id_UNSET));
    }
}

IfcCoolingTowerType *ExpressDataSet::cloneIfcCoolingTowerType(ExpressDataSet *expressDataSet, const IfcCoolingTowerType &obj, const CopyOp &copyop) {
    IfcCoolingTowerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoolingTowerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoolingTowerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoolingTowerType *ExpressDataSet::cloneIfcCoolingTowerType(const IfcCoolingTowerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCoolingTowerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCoolingTowerType(this, obj, copyop);
    }
}

IfcCoordinatedUniversalTimeOffset *ExpressDataSet::getIfcCoordinatedUniversalTimeOffset(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCoordinatedUniversalTimeOffset * > (current->second.get());
    }
    else {
        IfcCoordinatedUniversalTimeOffset *ret = static_cast< IfcCoordinatedUniversalTimeOffset * > (allocateIfcCoordinatedUniversalTimeOffset(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCoordinatedUniversalTimeOffset(IfcCoordinatedUniversalTimeOffset *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCoordinatedUniversalTimeOffset_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoordinatedUniversalTimeOffset(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCoordinatedUniversalTimeOffset *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoordinatedUniversalTimeOffset(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoordinatedUniversalTimeOffset_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoordinatedUniversalTimeOffset > ExpressDataSet::createIfcCoordinatedUniversalTimeOffset(bool isVolatile) {
    if (isVolatile) {
        return new IfcCoordinatedUniversalTimeOffset(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCoordinatedUniversalTimeOffset * > (allocateIfcCoordinatedUniversalTimeOffset(this, Step::Id_UNSET));
    }
}

IfcCoordinatedUniversalTimeOffset *ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(ExpressDataSet *expressDataSet, const IfcCoordinatedUniversalTimeOffset &obj, const CopyOp &copyop) {
    IfcCoordinatedUniversalTimeOffset *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoordinatedUniversalTimeOffset(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoordinatedUniversalTimeOffset_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoordinatedUniversalTimeOffset *ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(const IfcCoordinatedUniversalTimeOffset &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCoordinatedUniversalTimeOffset(this, obj, copyop);
    }
}

IfcCostItem *ExpressDataSet::getIfcCostItem(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCostItem * > (current->second.get());
    }
    else {
        IfcCostItem *ret = static_cast< IfcCostItem * > (allocateIfcCostItem(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCostItem(IfcCostItem *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCostItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCostItem *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostItem > ExpressDataSet::createIfcCostItem(bool isVolatile) {
    if (isVolatile) {
        return new IfcCostItem(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCostItem * > (allocateIfcCostItem(this, Step::Id_UNSET));
    }
}

IfcCostItem *ExpressDataSet::cloneIfcCostItem(ExpressDataSet *expressDataSet, const IfcCostItem &obj, const CopyOp &copyop) {
    IfcCostItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostItem *ExpressDataSet::cloneIfcCostItem(const IfcCostItem &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCostItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCostItem(this, obj, copyop);
    }
}

IfcCostSchedule *ExpressDataSet::getIfcCostSchedule(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCostSchedule * > (current->second.get());
    }
    else {
        IfcCostSchedule *ret = static_cast< IfcCostSchedule * > (allocateIfcCostSchedule(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCostSchedule(IfcCostSchedule *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCostSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCostSchedule *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostSchedule > ExpressDataSet::createIfcCostSchedule(bool isVolatile) {
    if (isVolatile) {
        return new IfcCostSchedule(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCostSchedule * > (allocateIfcCostSchedule(this, Step::Id_UNSET));
    }
}

IfcCostSchedule *ExpressDataSet::cloneIfcCostSchedule(ExpressDataSet *expressDataSet, const IfcCostSchedule &obj, const CopyOp &copyop) {
    IfcCostSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostSchedule *ExpressDataSet::cloneIfcCostSchedule(const IfcCostSchedule &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCostSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCostSchedule(this, obj, copyop);
    }
}

IfcCostValue *ExpressDataSet::getIfcCostValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCostValue * > (current->second.get());
    }
    else {
        IfcCostValue *ret = static_cast< IfcCostValue * > (allocateIfcCostValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCostValue(IfcCostValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCostValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCostValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCostValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCostValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCostValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCostValue > ExpressDataSet::createIfcCostValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcCostValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCostValue * > (allocateIfcCostValue(this, Step::Id_UNSET));
    }
}

IfcCostValue *ExpressDataSet::cloneIfcCostValue(ExpressDataSet *expressDataSet, const IfcCostValue &obj, const CopyOp &copyop) {
    IfcCostValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCostValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCostValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCostValue *ExpressDataSet::cloneIfcCostValue(const IfcCostValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCostValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCostValue(this, obj, copyop);
    }
}

IfcCovering *ExpressDataSet::getIfcCovering(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCovering * > (current->second.get());
    }
    else {
        IfcCovering *ret = static_cast< IfcCovering * > (allocateIfcCovering(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCovering(IfcCovering *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCovering_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCovering(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCovering *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCovering(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCovering_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCovering > ExpressDataSet::createIfcCovering(bool isVolatile) {
    if (isVolatile) {
        return new IfcCovering(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCovering * > (allocateIfcCovering(this, Step::Id_UNSET));
    }
}

IfcCovering *ExpressDataSet::cloneIfcCovering(ExpressDataSet *expressDataSet, const IfcCovering &obj, const CopyOp &copyop) {
    IfcCovering *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCovering(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCovering_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCovering *ExpressDataSet::cloneIfcCovering(const IfcCovering &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCovering(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCovering(this, obj, copyop);
    }
}

IfcCoveringType *ExpressDataSet::getIfcCoveringType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCoveringType * > (current->second.get());
    }
    else {
        IfcCoveringType *ret = static_cast< IfcCoveringType * > (allocateIfcCoveringType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCoveringType(IfcCoveringType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCoveringType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCoveringType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCoveringType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCoveringType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCoveringType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCoveringType > ExpressDataSet::createIfcCoveringType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCoveringType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCoveringType * > (allocateIfcCoveringType(this, Step::Id_UNSET));
    }
}

IfcCoveringType *ExpressDataSet::cloneIfcCoveringType(ExpressDataSet *expressDataSet, const IfcCoveringType &obj, const CopyOp &copyop) {
    IfcCoveringType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCoveringType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCoveringType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCoveringType *ExpressDataSet::cloneIfcCoveringType(const IfcCoveringType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCoveringType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCoveringType(this, obj, copyop);
    }
}

IfcCraneRailAShapeProfileDef *ExpressDataSet::getIfcCraneRailAShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCraneRailAShapeProfileDef * > (current->second.get());
    }
    else {
        IfcCraneRailAShapeProfileDef *ret = static_cast< IfcCraneRailAShapeProfileDef * > (allocateIfcCraneRailAShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCraneRailAShapeProfileDef(IfcCraneRailAShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCraneRailAShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCraneRailAShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCraneRailAShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCraneRailAShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCraneRailAShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCraneRailAShapeProfileDef > ExpressDataSet::createIfcCraneRailAShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCraneRailAShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCraneRailAShapeProfileDef * > (allocateIfcCraneRailAShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCraneRailAShapeProfileDef *ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCraneRailAShapeProfileDef &obj, const CopyOp &copyop) {
    IfcCraneRailAShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCraneRailAShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCraneRailAShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCraneRailAShapeProfileDef *ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(const IfcCraneRailAShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCraneRailAShapeProfileDef(this, obj, copyop);
    }
}

IfcCraneRailFShapeProfileDef *ExpressDataSet::getIfcCraneRailFShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCraneRailFShapeProfileDef * > (current->second.get());
    }
    else {
        IfcCraneRailFShapeProfileDef *ret = static_cast< IfcCraneRailFShapeProfileDef * > (allocateIfcCraneRailFShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCraneRailFShapeProfileDef(IfcCraneRailFShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCraneRailFShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCraneRailFShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCraneRailFShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCraneRailFShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCraneRailFShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCraneRailFShapeProfileDef > ExpressDataSet::createIfcCraneRailFShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcCraneRailFShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCraneRailFShapeProfileDef * > (allocateIfcCraneRailFShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcCraneRailFShapeProfileDef *ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(ExpressDataSet *expressDataSet, const IfcCraneRailFShapeProfileDef &obj, const CopyOp &copyop) {
    IfcCraneRailFShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCraneRailFShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCraneRailFShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCraneRailFShapeProfileDef *ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(const IfcCraneRailFShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCraneRailFShapeProfileDef(this, obj, copyop);
    }
}

IfcCrewResource *ExpressDataSet::getIfcCrewResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCrewResource * > (current->second.get());
    }
    else {
        IfcCrewResource *ret = static_cast< IfcCrewResource * > (allocateIfcCrewResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCrewResource(IfcCrewResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCrewResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCrewResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCrewResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCrewResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCrewResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCrewResource > ExpressDataSet::createIfcCrewResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcCrewResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCrewResource * > (allocateIfcCrewResource(this, Step::Id_UNSET));
    }
}

IfcCrewResource *ExpressDataSet::cloneIfcCrewResource(ExpressDataSet *expressDataSet, const IfcCrewResource &obj, const CopyOp &copyop) {
    IfcCrewResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCrewResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCrewResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCrewResource *ExpressDataSet::cloneIfcCrewResource(const IfcCrewResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCrewResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCrewResource(this, obj, copyop);
    }
}

IfcCsgSolid *ExpressDataSet::getIfcCsgSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCsgSolid * > (current->second.get());
    }
    else {
        IfcCsgSolid *ret = static_cast< IfcCsgSolid * > (allocateIfcCsgSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCsgSolid(IfcCsgSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCsgSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCsgSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCsgSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCsgSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCsgSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCsgSolid > ExpressDataSet::createIfcCsgSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcCsgSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCsgSolid * > (allocateIfcCsgSolid(this, Step::Id_UNSET));
    }
}

IfcCsgSolid *ExpressDataSet::cloneIfcCsgSolid(ExpressDataSet *expressDataSet, const IfcCsgSolid &obj, const CopyOp &copyop) {
    IfcCsgSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCsgSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCsgSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCsgSolid *ExpressDataSet::cloneIfcCsgSolid(const IfcCsgSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCsgSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCsgSolid(this, obj, copyop);
    }
}

IfcCurrencyRelationship *ExpressDataSet::getIfcCurrencyRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurrencyRelationship * > (current->second.get());
    }
    else {
        IfcCurrencyRelationship *ret = static_cast< IfcCurrencyRelationship * > (allocateIfcCurrencyRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurrencyRelationship(IfcCurrencyRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurrencyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurrencyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurrencyRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurrencyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurrencyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurrencyRelationship > ExpressDataSet::createIfcCurrencyRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurrencyRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurrencyRelationship * > (allocateIfcCurrencyRelationship(this, Step::Id_UNSET));
    }
}

IfcCurrencyRelationship *ExpressDataSet::cloneIfcCurrencyRelationship(ExpressDataSet *expressDataSet, const IfcCurrencyRelationship &obj, const CopyOp &copyop) {
    IfcCurrencyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurrencyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurrencyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurrencyRelationship *ExpressDataSet::cloneIfcCurrencyRelationship(const IfcCurrencyRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurrencyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurrencyRelationship(this, obj, copyop);
    }
}

IfcCurtainWall *ExpressDataSet::getIfcCurtainWall(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurtainWall * > (current->second.get());
    }
    else {
        IfcCurtainWall *ret = static_cast< IfcCurtainWall * > (allocateIfcCurtainWall(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurtainWall(IfcCurtainWall *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurtainWall_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurtainWall(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurtainWall *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurtainWall(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurtainWall_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurtainWall > ExpressDataSet::createIfcCurtainWall(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurtainWall(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurtainWall * > (allocateIfcCurtainWall(this, Step::Id_UNSET));
    }
}

IfcCurtainWall *ExpressDataSet::cloneIfcCurtainWall(ExpressDataSet *expressDataSet, const IfcCurtainWall &obj, const CopyOp &copyop) {
    IfcCurtainWall *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurtainWall(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurtainWall_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurtainWall *ExpressDataSet::cloneIfcCurtainWall(const IfcCurtainWall &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurtainWall(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurtainWall(this, obj, copyop);
    }
}

IfcCurtainWallType *ExpressDataSet::getIfcCurtainWallType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurtainWallType * > (current->second.get());
    }
    else {
        IfcCurtainWallType *ret = static_cast< IfcCurtainWallType * > (allocateIfcCurtainWallType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurtainWallType(IfcCurtainWallType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurtainWallType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurtainWallType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurtainWallType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurtainWallType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurtainWallType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurtainWallType > ExpressDataSet::createIfcCurtainWallType(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurtainWallType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurtainWallType * > (allocateIfcCurtainWallType(this, Step::Id_UNSET));
    }
}

IfcCurtainWallType *ExpressDataSet::cloneIfcCurtainWallType(ExpressDataSet *expressDataSet, const IfcCurtainWallType &obj, const CopyOp &copyop) {
    IfcCurtainWallType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurtainWallType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurtainWallType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurtainWallType *ExpressDataSet::cloneIfcCurtainWallType(const IfcCurtainWallType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurtainWallType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurtainWallType(this, obj, copyop);
    }
}

IfcCurveBoundedPlane *ExpressDataSet::getIfcCurveBoundedPlane(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurveBoundedPlane * > (current->second.get());
    }
    else {
        IfcCurveBoundedPlane *ret = static_cast< IfcCurveBoundedPlane * > (allocateIfcCurveBoundedPlane(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurveBoundedPlane(IfcCurveBoundedPlane *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurveBoundedPlane_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveBoundedPlane(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurveBoundedPlane *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveBoundedPlane(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveBoundedPlane_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveBoundedPlane > ExpressDataSet::createIfcCurveBoundedPlane(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurveBoundedPlane(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurveBoundedPlane * > (allocateIfcCurveBoundedPlane(this, Step::Id_UNSET));
    }
}

IfcCurveBoundedPlane *ExpressDataSet::cloneIfcCurveBoundedPlane(ExpressDataSet *expressDataSet, const IfcCurveBoundedPlane &obj, const CopyOp &copyop) {
    IfcCurveBoundedPlane *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveBoundedPlane(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveBoundedPlane_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveBoundedPlane *ExpressDataSet::cloneIfcCurveBoundedPlane(const IfcCurveBoundedPlane &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurveBoundedPlane(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurveBoundedPlane(this, obj, copyop);
    }
}

IfcCurveStyle *ExpressDataSet::getIfcCurveStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurveStyle * > (current->second.get());
    }
    else {
        IfcCurveStyle *ret = static_cast< IfcCurveStyle * > (allocateIfcCurveStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurveStyle(IfcCurveStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurveStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurveStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyle > ExpressDataSet::createIfcCurveStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurveStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurveStyle * > (allocateIfcCurveStyle(this, Step::Id_UNSET));
    }
}

IfcCurveStyle *ExpressDataSet::cloneIfcCurveStyle(ExpressDataSet *expressDataSet, const IfcCurveStyle &obj, const CopyOp &copyop) {
    IfcCurveStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyle *ExpressDataSet::cloneIfcCurveStyle(const IfcCurveStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurveStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurveStyle(this, obj, copyop);
    }
}

IfcCurveStyleFont *ExpressDataSet::getIfcCurveStyleFont(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurveStyleFont * > (current->second.get());
    }
    else {
        IfcCurveStyleFont *ret = static_cast< IfcCurveStyleFont * > (allocateIfcCurveStyleFont(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurveStyleFont(IfcCurveStyleFont *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurveStyleFont *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFont > ExpressDataSet::createIfcCurveStyleFont(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurveStyleFont(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurveStyleFont * > (allocateIfcCurveStyleFont(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFont *ExpressDataSet::cloneIfcCurveStyleFont(ExpressDataSet *expressDataSet, const IfcCurveStyleFont &obj, const CopyOp &copyop) {
    IfcCurveStyleFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFont *ExpressDataSet::cloneIfcCurveStyleFont(const IfcCurveStyleFont &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurveStyleFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurveStyleFont(this, obj, copyop);
    }
}

IfcCurveStyleFontAndScaling *ExpressDataSet::getIfcCurveStyleFontAndScaling(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurveStyleFontAndScaling * > (current->second.get());
    }
    else {
        IfcCurveStyleFontAndScaling *ret = static_cast< IfcCurveStyleFontAndScaling * > (allocateIfcCurveStyleFontAndScaling(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurveStyleFontAndScaling(IfcCurveStyleFontAndScaling *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFontAndScaling_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFontAndScaling(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurveStyleFontAndScaling *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFontAndScaling(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFontAndScaling_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFontAndScaling > ExpressDataSet::createIfcCurveStyleFontAndScaling(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurveStyleFontAndScaling(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurveStyleFontAndScaling * > (allocateIfcCurveStyleFontAndScaling(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFontAndScaling *ExpressDataSet::cloneIfcCurveStyleFontAndScaling(ExpressDataSet *expressDataSet, const IfcCurveStyleFontAndScaling &obj, const CopyOp &copyop) {
    IfcCurveStyleFontAndScaling *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFontAndScaling(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFontAndScaling_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFontAndScaling *ExpressDataSet::cloneIfcCurveStyleFontAndScaling(const IfcCurveStyleFontAndScaling &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurveStyleFontAndScaling(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurveStyleFontAndScaling(this, obj, copyop);
    }
}

IfcCurveStyleFontPattern *ExpressDataSet::getIfcCurveStyleFontPattern(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcCurveStyleFontPattern * > (current->second.get());
    }
    else {
        IfcCurveStyleFontPattern *ret = static_cast< IfcCurveStyleFontPattern * > (allocateIfcCurveStyleFontPattern(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcCurveStyleFontPattern(IfcCurveStyleFontPattern *arg) {
    getAll().erase(arg->getKey());
    return m_IfcCurveStyleFontPattern_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcCurveStyleFontPattern(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcCurveStyleFontPattern *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcCurveStyleFontPattern(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcCurveStyleFontPattern_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcCurveStyleFontPattern > ExpressDataSet::createIfcCurveStyleFontPattern(bool isVolatile) {
    if (isVolatile) {
        return new IfcCurveStyleFontPattern(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcCurveStyleFontPattern * > (allocateIfcCurveStyleFontPattern(this, Step::Id_UNSET));
    }
}

IfcCurveStyleFontPattern *ExpressDataSet::cloneIfcCurveStyleFontPattern(ExpressDataSet *expressDataSet, const IfcCurveStyleFontPattern &obj, const CopyOp &copyop) {
    IfcCurveStyleFontPattern *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcCurveStyleFontPattern(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcCurveStyleFontPattern_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcCurveStyleFontPattern *ExpressDataSet::cloneIfcCurveStyleFontPattern(const IfcCurveStyleFontPattern &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcCurveStyleFontPattern(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcCurveStyleFontPattern(this, obj, copyop);
    }
}

IfcDamperType *ExpressDataSet::getIfcDamperType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDamperType * > (current->second.get());
    }
    else {
        IfcDamperType *ret = static_cast< IfcDamperType * > (allocateIfcDamperType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDamperType(IfcDamperType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDamperType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDamperType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDamperType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDamperType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDamperType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDamperType > ExpressDataSet::createIfcDamperType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDamperType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDamperType * > (allocateIfcDamperType(this, Step::Id_UNSET));
    }
}

IfcDamperType *ExpressDataSet::cloneIfcDamperType(ExpressDataSet *expressDataSet, const IfcDamperType &obj, const CopyOp &copyop) {
    IfcDamperType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDamperType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDamperType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDamperType *ExpressDataSet::cloneIfcDamperType(const IfcDamperType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDamperType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDamperType(this, obj, copyop);
    }
}

IfcDateAndTime *ExpressDataSet::getIfcDateAndTime(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDateAndTime * > (current->second.get());
    }
    else {
        IfcDateAndTime *ret = static_cast< IfcDateAndTime * > (allocateIfcDateAndTime(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDateAndTime(IfcDateAndTime *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDateAndTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDateAndTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDateAndTime *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDateAndTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDateAndTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDateAndTime > ExpressDataSet::createIfcDateAndTime(bool isVolatile) {
    if (isVolatile) {
        return new IfcDateAndTime(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDateAndTime * > (allocateIfcDateAndTime(this, Step::Id_UNSET));
    }
}

IfcDateAndTime *ExpressDataSet::cloneIfcDateAndTime(ExpressDataSet *expressDataSet, const IfcDateAndTime &obj, const CopyOp &copyop) {
    IfcDateAndTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDateAndTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDateAndTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDateAndTime *ExpressDataSet::cloneIfcDateAndTime(const IfcDateAndTime &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDateAndTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDateAndTime(this, obj, copyop);
    }
}

IfcDefinedSymbol *ExpressDataSet::getIfcDefinedSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDefinedSymbol * > (current->second.get());
    }
    else {
        IfcDefinedSymbol *ret = static_cast< IfcDefinedSymbol * > (allocateIfcDefinedSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDefinedSymbol(IfcDefinedSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDefinedSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDefinedSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDefinedSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDefinedSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDefinedSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDefinedSymbol > ExpressDataSet::createIfcDefinedSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcDefinedSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDefinedSymbol * > (allocateIfcDefinedSymbol(this, Step::Id_UNSET));
    }
}

IfcDefinedSymbol *ExpressDataSet::cloneIfcDefinedSymbol(ExpressDataSet *expressDataSet, const IfcDefinedSymbol &obj, const CopyOp &copyop) {
    IfcDefinedSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDefinedSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDefinedSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDefinedSymbol *ExpressDataSet::cloneIfcDefinedSymbol(const IfcDefinedSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDefinedSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDefinedSymbol(this, obj, copyop);
    }
}

IfcDerivedProfileDef *ExpressDataSet::getIfcDerivedProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDerivedProfileDef * > (current->second.get());
    }
    else {
        IfcDerivedProfileDef *ret = static_cast< IfcDerivedProfileDef * > (allocateIfcDerivedProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDerivedProfileDef(IfcDerivedProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDerivedProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDerivedProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedProfileDef > ExpressDataSet::createIfcDerivedProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcDerivedProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDerivedProfileDef * > (allocateIfcDerivedProfileDef(this, Step::Id_UNSET));
    }
}

IfcDerivedProfileDef *ExpressDataSet::cloneIfcDerivedProfileDef(ExpressDataSet *expressDataSet, const IfcDerivedProfileDef &obj, const CopyOp &copyop) {
    IfcDerivedProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedProfileDef *ExpressDataSet::cloneIfcDerivedProfileDef(const IfcDerivedProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDerivedProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDerivedProfileDef(this, obj, copyop);
    }
}

IfcDerivedUnit *ExpressDataSet::getIfcDerivedUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDerivedUnit * > (current->second.get());
    }
    else {
        IfcDerivedUnit *ret = static_cast< IfcDerivedUnit * > (allocateIfcDerivedUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDerivedUnit(IfcDerivedUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDerivedUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDerivedUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedUnit > ExpressDataSet::createIfcDerivedUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcDerivedUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDerivedUnit * > (allocateIfcDerivedUnit(this, Step::Id_UNSET));
    }
}

IfcDerivedUnit *ExpressDataSet::cloneIfcDerivedUnit(ExpressDataSet *expressDataSet, const IfcDerivedUnit &obj, const CopyOp &copyop) {
    IfcDerivedUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedUnit *ExpressDataSet::cloneIfcDerivedUnit(const IfcDerivedUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDerivedUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDerivedUnit(this, obj, copyop);
    }
}

IfcDerivedUnitElement *ExpressDataSet::getIfcDerivedUnitElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDerivedUnitElement * > (current->second.get());
    }
    else {
        IfcDerivedUnitElement *ret = static_cast< IfcDerivedUnitElement * > (allocateIfcDerivedUnitElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDerivedUnitElement(IfcDerivedUnitElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDerivedUnitElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDerivedUnitElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDerivedUnitElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDerivedUnitElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDerivedUnitElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDerivedUnitElement > ExpressDataSet::createIfcDerivedUnitElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcDerivedUnitElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDerivedUnitElement * > (allocateIfcDerivedUnitElement(this, Step::Id_UNSET));
    }
}

IfcDerivedUnitElement *ExpressDataSet::cloneIfcDerivedUnitElement(ExpressDataSet *expressDataSet, const IfcDerivedUnitElement &obj, const CopyOp &copyop) {
    IfcDerivedUnitElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDerivedUnitElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDerivedUnitElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDerivedUnitElement *ExpressDataSet::cloneIfcDerivedUnitElement(const IfcDerivedUnitElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDerivedUnitElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDerivedUnitElement(this, obj, copyop);
    }
}

IfcDiameterDimension *ExpressDataSet::getIfcDiameterDimension(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDiameterDimension * > (current->second.get());
    }
    else {
        IfcDiameterDimension *ret = static_cast< IfcDiameterDimension * > (allocateIfcDiameterDimension(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDiameterDimension(IfcDiameterDimension *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDiameterDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiameterDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDiameterDimension *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiameterDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiameterDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiameterDimension > ExpressDataSet::createIfcDiameterDimension(bool isVolatile) {
    if (isVolatile) {
        return new IfcDiameterDimension(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDiameterDimension * > (allocateIfcDiameterDimension(this, Step::Id_UNSET));
    }
}

IfcDiameterDimension *ExpressDataSet::cloneIfcDiameterDimension(ExpressDataSet *expressDataSet, const IfcDiameterDimension &obj, const CopyOp &copyop) {
    IfcDiameterDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiameterDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiameterDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiameterDimension *ExpressDataSet::cloneIfcDiameterDimension(const IfcDiameterDimension &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDiameterDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDiameterDimension(this, obj, copyop);
    }
}

IfcDimensionCalloutRelationship *ExpressDataSet::getIfcDimensionCalloutRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionCalloutRelationship * > (current->second.get());
    }
    else {
        IfcDimensionCalloutRelationship *ret = static_cast< IfcDimensionCalloutRelationship * > (allocateIfcDimensionCalloutRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionCalloutRelationship(IfcDimensionCalloutRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionCalloutRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCalloutRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionCalloutRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCalloutRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCalloutRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCalloutRelationship > ExpressDataSet::createIfcDimensionCalloutRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionCalloutRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionCalloutRelationship * > (allocateIfcDimensionCalloutRelationship(this, Step::Id_UNSET));
    }
}

IfcDimensionCalloutRelationship *ExpressDataSet::cloneIfcDimensionCalloutRelationship(ExpressDataSet *expressDataSet, const IfcDimensionCalloutRelationship &obj, const CopyOp &copyop) {
    IfcDimensionCalloutRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCalloutRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCalloutRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCalloutRelationship *ExpressDataSet::cloneIfcDimensionCalloutRelationship(const IfcDimensionCalloutRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionCalloutRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionCalloutRelationship(this, obj, copyop);
    }
}

IfcDimensionCurve *ExpressDataSet::getIfcDimensionCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionCurve * > (current->second.get());
    }
    else {
        IfcDimensionCurve *ret = static_cast< IfcDimensionCurve * > (allocateIfcDimensionCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionCurve(IfcDimensionCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurve > ExpressDataSet::createIfcDimensionCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionCurve * > (allocateIfcDimensionCurve(this, Step::Id_UNSET));
    }
}

IfcDimensionCurve *ExpressDataSet::cloneIfcDimensionCurve(ExpressDataSet *expressDataSet, const IfcDimensionCurve &obj, const CopyOp &copyop) {
    IfcDimensionCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurve *ExpressDataSet::cloneIfcDimensionCurve(const IfcDimensionCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionCurve(this, obj, copyop);
    }
}

IfcDimensionCurveDirectedCallout *ExpressDataSet::getIfcDimensionCurveDirectedCallout(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionCurveDirectedCallout * > (current->second.get());
    }
    else {
        IfcDimensionCurveDirectedCallout *ret = static_cast< IfcDimensionCurveDirectedCallout * > (allocateIfcDimensionCurveDirectedCallout(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionCurveDirectedCallout(IfcDimensionCurveDirectedCallout *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurveDirectedCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurveDirectedCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionCurveDirectedCallout *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurveDirectedCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurveDirectedCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurveDirectedCallout > ExpressDataSet::createIfcDimensionCurveDirectedCallout(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionCurveDirectedCallout(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionCurveDirectedCallout * > (allocateIfcDimensionCurveDirectedCallout(this, Step::Id_UNSET));
    }
}

IfcDimensionCurveDirectedCallout *ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(ExpressDataSet *expressDataSet, const IfcDimensionCurveDirectedCallout &obj, const CopyOp &copyop) {
    IfcDimensionCurveDirectedCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurveDirectedCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurveDirectedCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurveDirectedCallout *ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(const IfcDimensionCurveDirectedCallout &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionCurveDirectedCallout(this, obj, copyop);
    }
}

IfcDimensionCurveTerminator *ExpressDataSet::getIfcDimensionCurveTerminator(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionCurveTerminator * > (current->second.get());
    }
    else {
        IfcDimensionCurveTerminator *ret = static_cast< IfcDimensionCurveTerminator * > (allocateIfcDimensionCurveTerminator(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionCurveTerminator(IfcDimensionCurveTerminator *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionCurveTerminator_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionCurveTerminator(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionCurveTerminator *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionCurveTerminator(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionCurveTerminator_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionCurveTerminator > ExpressDataSet::createIfcDimensionCurveTerminator(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionCurveTerminator(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionCurveTerminator * > (allocateIfcDimensionCurveTerminator(this, Step::Id_UNSET));
    }
}

IfcDimensionCurveTerminator *ExpressDataSet::cloneIfcDimensionCurveTerminator(ExpressDataSet *expressDataSet, const IfcDimensionCurveTerminator &obj, const CopyOp &copyop) {
    IfcDimensionCurveTerminator *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionCurveTerminator(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionCurveTerminator_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionCurveTerminator *ExpressDataSet::cloneIfcDimensionCurveTerminator(const IfcDimensionCurveTerminator &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionCurveTerminator(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionCurveTerminator(this, obj, copyop);
    }
}

IfcDimensionPair *ExpressDataSet::getIfcDimensionPair(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionPair * > (current->second.get());
    }
    else {
        IfcDimensionPair *ret = static_cast< IfcDimensionPair * > (allocateIfcDimensionPair(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionPair(IfcDimensionPair *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionPair_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionPair(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionPair *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionPair(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionPair_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionPair > ExpressDataSet::createIfcDimensionPair(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionPair(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionPair * > (allocateIfcDimensionPair(this, Step::Id_UNSET));
    }
}

IfcDimensionPair *ExpressDataSet::cloneIfcDimensionPair(ExpressDataSet *expressDataSet, const IfcDimensionPair &obj, const CopyOp &copyop) {
    IfcDimensionPair *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionPair(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionPair_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionPair *ExpressDataSet::cloneIfcDimensionPair(const IfcDimensionPair &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionPair(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionPair(this, obj, copyop);
    }
}

IfcDimensionalExponents *ExpressDataSet::getIfcDimensionalExponents(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDimensionalExponents * > (current->second.get());
    }
    else {
        IfcDimensionalExponents *ret = static_cast< IfcDimensionalExponents * > (allocateIfcDimensionalExponents(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDimensionalExponents(IfcDimensionalExponents *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDimensionalExponents_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDimensionalExponents(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDimensionalExponents *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDimensionalExponents(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDimensionalExponents_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDimensionalExponents > ExpressDataSet::createIfcDimensionalExponents(bool isVolatile) {
    if (isVolatile) {
        return new IfcDimensionalExponents(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDimensionalExponents * > (allocateIfcDimensionalExponents(this, Step::Id_UNSET));
    }
}

IfcDimensionalExponents *ExpressDataSet::cloneIfcDimensionalExponents(ExpressDataSet *expressDataSet, const IfcDimensionalExponents &obj, const CopyOp &copyop) {
    IfcDimensionalExponents *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDimensionalExponents(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDimensionalExponents_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDimensionalExponents *ExpressDataSet::cloneIfcDimensionalExponents(const IfcDimensionalExponents &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDimensionalExponents(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDimensionalExponents(this, obj, copyop);
    }
}

IfcDirection *ExpressDataSet::getIfcDirection(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDirection * > (current->second.get());
    }
    else {
        IfcDirection *ret = static_cast< IfcDirection * > (allocateIfcDirection(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDirection(IfcDirection *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDirection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDirection(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDirection *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDirection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDirection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDirection > ExpressDataSet::createIfcDirection(bool isVolatile) {
    if (isVolatile) {
        return new IfcDirection(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDirection * > (allocateIfcDirection(this, Step::Id_UNSET));
    }
}

IfcDirection *ExpressDataSet::cloneIfcDirection(ExpressDataSet *expressDataSet, const IfcDirection &obj, const CopyOp &copyop) {
    IfcDirection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDirection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDirection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDirection *ExpressDataSet::cloneIfcDirection(const IfcDirection &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDirection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDirection(this, obj, copyop);
    }
}

IfcDiscreteAccessory *ExpressDataSet::getIfcDiscreteAccessory(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDiscreteAccessory * > (current->second.get());
    }
    else {
        IfcDiscreteAccessory *ret = static_cast< IfcDiscreteAccessory * > (allocateIfcDiscreteAccessory(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDiscreteAccessory(IfcDiscreteAccessory *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDiscreteAccessory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiscreteAccessory(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDiscreteAccessory *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiscreteAccessory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiscreteAccessory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiscreteAccessory > ExpressDataSet::createIfcDiscreteAccessory(bool isVolatile) {
    if (isVolatile) {
        return new IfcDiscreteAccessory(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDiscreteAccessory * > (allocateIfcDiscreteAccessory(this, Step::Id_UNSET));
    }
}

IfcDiscreteAccessory *ExpressDataSet::cloneIfcDiscreteAccessory(ExpressDataSet *expressDataSet, const IfcDiscreteAccessory &obj, const CopyOp &copyop) {
    IfcDiscreteAccessory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiscreteAccessory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiscreteAccessory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiscreteAccessory *ExpressDataSet::cloneIfcDiscreteAccessory(const IfcDiscreteAccessory &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDiscreteAccessory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDiscreteAccessory(this, obj, copyop);
    }
}

IfcDiscreteAccessoryType *ExpressDataSet::getIfcDiscreteAccessoryType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDiscreteAccessoryType * > (current->second.get());
    }
    else {
        IfcDiscreteAccessoryType *ret = static_cast< IfcDiscreteAccessoryType * > (allocateIfcDiscreteAccessoryType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDiscreteAccessoryType(IfcDiscreteAccessoryType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDiscreteAccessoryType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDiscreteAccessoryType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDiscreteAccessoryType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDiscreteAccessoryType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDiscreteAccessoryType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDiscreteAccessoryType > ExpressDataSet::createIfcDiscreteAccessoryType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDiscreteAccessoryType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDiscreteAccessoryType * > (allocateIfcDiscreteAccessoryType(this, Step::Id_UNSET));
    }
}

IfcDiscreteAccessoryType *ExpressDataSet::cloneIfcDiscreteAccessoryType(ExpressDataSet *expressDataSet, const IfcDiscreteAccessoryType &obj, const CopyOp &copyop) {
    IfcDiscreteAccessoryType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDiscreteAccessoryType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDiscreteAccessoryType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDiscreteAccessoryType *ExpressDataSet::cloneIfcDiscreteAccessoryType(const IfcDiscreteAccessoryType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDiscreteAccessoryType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDiscreteAccessoryType(this, obj, copyop);
    }
}

IfcDistributionChamberElement *ExpressDataSet::getIfcDistributionChamberElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionChamberElement * > (current->second.get());
    }
    else {
        IfcDistributionChamberElement *ret = static_cast< IfcDistributionChamberElement * > (allocateIfcDistributionChamberElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionChamberElement(IfcDistributionChamberElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionChamberElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionChamberElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionChamberElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionChamberElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionChamberElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionChamberElement > ExpressDataSet::createIfcDistributionChamberElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionChamberElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionChamberElement * > (allocateIfcDistributionChamberElement(this, Step::Id_UNSET));
    }
}

IfcDistributionChamberElement *ExpressDataSet::cloneIfcDistributionChamberElement(ExpressDataSet *expressDataSet, const IfcDistributionChamberElement &obj, const CopyOp &copyop) {
    IfcDistributionChamberElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionChamberElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionChamberElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionChamberElement *ExpressDataSet::cloneIfcDistributionChamberElement(const IfcDistributionChamberElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionChamberElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionChamberElement(this, obj, copyop);
    }
}

IfcDistributionChamberElementType *ExpressDataSet::getIfcDistributionChamberElementType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionChamberElementType * > (current->second.get());
    }
    else {
        IfcDistributionChamberElementType *ret = static_cast< IfcDistributionChamberElementType * > (allocateIfcDistributionChamberElementType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionChamberElementType(IfcDistributionChamberElementType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionChamberElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionChamberElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionChamberElementType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionChamberElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionChamberElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionChamberElementType > ExpressDataSet::createIfcDistributionChamberElementType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionChamberElementType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionChamberElementType * > (allocateIfcDistributionChamberElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionChamberElementType *ExpressDataSet::cloneIfcDistributionChamberElementType(ExpressDataSet *expressDataSet, const IfcDistributionChamberElementType &obj, const CopyOp &copyop) {
    IfcDistributionChamberElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionChamberElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionChamberElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionChamberElementType *ExpressDataSet::cloneIfcDistributionChamberElementType(const IfcDistributionChamberElementType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionChamberElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionChamberElementType(this, obj, copyop);
    }
}

IfcDistributionControlElement *ExpressDataSet::getIfcDistributionControlElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionControlElement * > (current->second.get());
    }
    else {
        IfcDistributionControlElement *ret = static_cast< IfcDistributionControlElement * > (allocateIfcDistributionControlElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionControlElement(IfcDistributionControlElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionControlElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionControlElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionControlElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionControlElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionControlElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionControlElement > ExpressDataSet::createIfcDistributionControlElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionControlElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionControlElement * > (allocateIfcDistributionControlElement(this, Step::Id_UNSET));
    }
}

IfcDistributionControlElement *ExpressDataSet::cloneIfcDistributionControlElement(ExpressDataSet *expressDataSet, const IfcDistributionControlElement &obj, const CopyOp &copyop) {
    IfcDistributionControlElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionControlElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionControlElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionControlElement *ExpressDataSet::cloneIfcDistributionControlElement(const IfcDistributionControlElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionControlElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionControlElement(this, obj, copyop);
    }
}

IfcDistributionElement *ExpressDataSet::getIfcDistributionElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionElement * > (current->second.get());
    }
    else {
        IfcDistributionElement *ret = static_cast< IfcDistributionElement * > (allocateIfcDistributionElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionElement(IfcDistributionElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionElement > ExpressDataSet::createIfcDistributionElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionElement * > (allocateIfcDistributionElement(this, Step::Id_UNSET));
    }
}

IfcDistributionElement *ExpressDataSet::cloneIfcDistributionElement(ExpressDataSet *expressDataSet, const IfcDistributionElement &obj, const CopyOp &copyop) {
    IfcDistributionElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionElement *ExpressDataSet::cloneIfcDistributionElement(const IfcDistributionElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionElement(this, obj, copyop);
    }
}

IfcDistributionElementType *ExpressDataSet::getIfcDistributionElementType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionElementType * > (current->second.get());
    }
    else {
        IfcDistributionElementType *ret = static_cast< IfcDistributionElementType * > (allocateIfcDistributionElementType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionElementType(IfcDistributionElementType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionElementType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionElementType > ExpressDataSet::createIfcDistributionElementType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionElementType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionElementType * > (allocateIfcDistributionElementType(this, Step::Id_UNSET));
    }
}

IfcDistributionElementType *ExpressDataSet::cloneIfcDistributionElementType(ExpressDataSet *expressDataSet, const IfcDistributionElementType &obj, const CopyOp &copyop) {
    IfcDistributionElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionElementType *ExpressDataSet::cloneIfcDistributionElementType(const IfcDistributionElementType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionElementType(this, obj, copyop);
    }
}

IfcDistributionFlowElement *ExpressDataSet::getIfcDistributionFlowElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionFlowElement * > (current->second.get());
    }
    else {
        IfcDistributionFlowElement *ret = static_cast< IfcDistributionFlowElement * > (allocateIfcDistributionFlowElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionFlowElement(IfcDistributionFlowElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionFlowElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionFlowElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionFlowElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionFlowElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionFlowElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionFlowElement > ExpressDataSet::createIfcDistributionFlowElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionFlowElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionFlowElement * > (allocateIfcDistributionFlowElement(this, Step::Id_UNSET));
    }
}

IfcDistributionFlowElement *ExpressDataSet::cloneIfcDistributionFlowElement(ExpressDataSet *expressDataSet, const IfcDistributionFlowElement &obj, const CopyOp &copyop) {
    IfcDistributionFlowElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionFlowElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionFlowElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionFlowElement *ExpressDataSet::cloneIfcDistributionFlowElement(const IfcDistributionFlowElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionFlowElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionFlowElement(this, obj, copyop);
    }
}

IfcDistributionPort *ExpressDataSet::getIfcDistributionPort(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDistributionPort * > (current->second.get());
    }
    else {
        IfcDistributionPort *ret = static_cast< IfcDistributionPort * > (allocateIfcDistributionPort(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDistributionPort(IfcDistributionPort *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDistributionPort_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDistributionPort(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDistributionPort *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDistributionPort(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDistributionPort_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDistributionPort > ExpressDataSet::createIfcDistributionPort(bool isVolatile) {
    if (isVolatile) {
        return new IfcDistributionPort(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDistributionPort * > (allocateIfcDistributionPort(this, Step::Id_UNSET));
    }
}

IfcDistributionPort *ExpressDataSet::cloneIfcDistributionPort(ExpressDataSet *expressDataSet, const IfcDistributionPort &obj, const CopyOp &copyop) {
    IfcDistributionPort *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDistributionPort(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDistributionPort_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDistributionPort *ExpressDataSet::cloneIfcDistributionPort(const IfcDistributionPort &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDistributionPort(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDistributionPort(this, obj, copyop);
    }
}

IfcDocumentElectronicFormat *ExpressDataSet::getIfcDocumentElectronicFormat(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDocumentElectronicFormat * > (current->second.get());
    }
    else {
        IfcDocumentElectronicFormat *ret = static_cast< IfcDocumentElectronicFormat * > (allocateIfcDocumentElectronicFormat(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDocumentElectronicFormat(IfcDocumentElectronicFormat *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDocumentElectronicFormat_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentElectronicFormat(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDocumentElectronicFormat *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentElectronicFormat(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentElectronicFormat_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentElectronicFormat > ExpressDataSet::createIfcDocumentElectronicFormat(bool isVolatile) {
    if (isVolatile) {
        return new IfcDocumentElectronicFormat(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDocumentElectronicFormat * > (allocateIfcDocumentElectronicFormat(this, Step::Id_UNSET));
    }
}

IfcDocumentElectronicFormat *ExpressDataSet::cloneIfcDocumentElectronicFormat(ExpressDataSet *expressDataSet, const IfcDocumentElectronicFormat &obj, const CopyOp &copyop) {
    IfcDocumentElectronicFormat *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentElectronicFormat(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentElectronicFormat_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentElectronicFormat *ExpressDataSet::cloneIfcDocumentElectronicFormat(const IfcDocumentElectronicFormat &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDocumentElectronicFormat(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDocumentElectronicFormat(this, obj, copyop);
    }
}

IfcDocumentInformation *ExpressDataSet::getIfcDocumentInformation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDocumentInformation * > (current->second.get());
    }
    else {
        IfcDocumentInformation *ret = static_cast< IfcDocumentInformation * > (allocateIfcDocumentInformation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDocumentInformation(IfcDocumentInformation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDocumentInformation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentInformation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDocumentInformation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentInformation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentInformation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentInformation > ExpressDataSet::createIfcDocumentInformation(bool isVolatile) {
    if (isVolatile) {
        return new IfcDocumentInformation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDocumentInformation * > (allocateIfcDocumentInformation(this, Step::Id_UNSET));
    }
}

IfcDocumentInformation *ExpressDataSet::cloneIfcDocumentInformation(ExpressDataSet *expressDataSet, const IfcDocumentInformation &obj, const CopyOp &copyop) {
    IfcDocumentInformation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentInformation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentInformation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentInformation *ExpressDataSet::cloneIfcDocumentInformation(const IfcDocumentInformation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDocumentInformation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDocumentInformation(this, obj, copyop);
    }
}

IfcDocumentInformationRelationship *ExpressDataSet::getIfcDocumentInformationRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDocumentInformationRelationship * > (current->second.get());
    }
    else {
        IfcDocumentInformationRelationship *ret = static_cast< IfcDocumentInformationRelationship * > (allocateIfcDocumentInformationRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDocumentInformationRelationship(IfcDocumentInformationRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDocumentInformationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentInformationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDocumentInformationRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentInformationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentInformationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentInformationRelationship > ExpressDataSet::createIfcDocumentInformationRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcDocumentInformationRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDocumentInformationRelationship * > (allocateIfcDocumentInformationRelationship(this, Step::Id_UNSET));
    }
}

IfcDocumentInformationRelationship *ExpressDataSet::cloneIfcDocumentInformationRelationship(ExpressDataSet *expressDataSet, const IfcDocumentInformationRelationship &obj, const CopyOp &copyop) {
    IfcDocumentInformationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentInformationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentInformationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentInformationRelationship *ExpressDataSet::cloneIfcDocumentInformationRelationship(const IfcDocumentInformationRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDocumentInformationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDocumentInformationRelationship(this, obj, copyop);
    }
}

IfcDocumentReference *ExpressDataSet::getIfcDocumentReference(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDocumentReference * > (current->second.get());
    }
    else {
        IfcDocumentReference *ret = static_cast< IfcDocumentReference * > (allocateIfcDocumentReference(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDocumentReference(IfcDocumentReference *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDocumentReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDocumentReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDocumentReference *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDocumentReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDocumentReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDocumentReference > ExpressDataSet::createIfcDocumentReference(bool isVolatile) {
    if (isVolatile) {
        return new IfcDocumentReference(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDocumentReference * > (allocateIfcDocumentReference(this, Step::Id_UNSET));
    }
}

IfcDocumentReference *ExpressDataSet::cloneIfcDocumentReference(ExpressDataSet *expressDataSet, const IfcDocumentReference &obj, const CopyOp &copyop) {
    IfcDocumentReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDocumentReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDocumentReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDocumentReference *ExpressDataSet::cloneIfcDocumentReference(const IfcDocumentReference &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDocumentReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDocumentReference(this, obj, copyop);
    }
}

IfcDoor *ExpressDataSet::getIfcDoor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDoor * > (current->second.get());
    }
    else {
        IfcDoor *ret = static_cast< IfcDoor * > (allocateIfcDoor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDoor(IfcDoor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDoor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDoor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoor > ExpressDataSet::createIfcDoor(bool isVolatile) {
    if (isVolatile) {
        return new IfcDoor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDoor * > (allocateIfcDoor(this, Step::Id_UNSET));
    }
}

IfcDoor *ExpressDataSet::cloneIfcDoor(ExpressDataSet *expressDataSet, const IfcDoor &obj, const CopyOp &copyop) {
    IfcDoor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoor *ExpressDataSet::cloneIfcDoor(const IfcDoor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDoor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDoor(this, obj, copyop);
    }
}

IfcDoorLiningProperties *ExpressDataSet::getIfcDoorLiningProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDoorLiningProperties * > (current->second.get());
    }
    else {
        IfcDoorLiningProperties *ret = static_cast< IfcDoorLiningProperties * > (allocateIfcDoorLiningProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDoorLiningProperties(IfcDoorLiningProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDoorLiningProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorLiningProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDoorLiningProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorLiningProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorLiningProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorLiningProperties > ExpressDataSet::createIfcDoorLiningProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcDoorLiningProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDoorLiningProperties * > (allocateIfcDoorLiningProperties(this, Step::Id_UNSET));
    }
}

IfcDoorLiningProperties *ExpressDataSet::cloneIfcDoorLiningProperties(ExpressDataSet *expressDataSet, const IfcDoorLiningProperties &obj, const CopyOp &copyop) {
    IfcDoorLiningProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorLiningProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorLiningProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorLiningProperties *ExpressDataSet::cloneIfcDoorLiningProperties(const IfcDoorLiningProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDoorLiningProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDoorLiningProperties(this, obj, copyop);
    }
}

IfcDoorPanelProperties *ExpressDataSet::getIfcDoorPanelProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDoorPanelProperties * > (current->second.get());
    }
    else {
        IfcDoorPanelProperties *ret = static_cast< IfcDoorPanelProperties * > (allocateIfcDoorPanelProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDoorPanelProperties(IfcDoorPanelProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDoorPanelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorPanelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDoorPanelProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorPanelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorPanelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorPanelProperties > ExpressDataSet::createIfcDoorPanelProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcDoorPanelProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDoorPanelProperties * > (allocateIfcDoorPanelProperties(this, Step::Id_UNSET));
    }
}

IfcDoorPanelProperties *ExpressDataSet::cloneIfcDoorPanelProperties(ExpressDataSet *expressDataSet, const IfcDoorPanelProperties &obj, const CopyOp &copyop) {
    IfcDoorPanelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorPanelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorPanelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorPanelProperties *ExpressDataSet::cloneIfcDoorPanelProperties(const IfcDoorPanelProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDoorPanelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDoorPanelProperties(this, obj, copyop);
    }
}

IfcDoorStyle *ExpressDataSet::getIfcDoorStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDoorStyle * > (current->second.get());
    }
    else {
        IfcDoorStyle *ret = static_cast< IfcDoorStyle * > (allocateIfcDoorStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDoorStyle(IfcDoorStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDoorStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDoorStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDoorStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDoorStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDoorStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDoorStyle > ExpressDataSet::createIfcDoorStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcDoorStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDoorStyle * > (allocateIfcDoorStyle(this, Step::Id_UNSET));
    }
}

IfcDoorStyle *ExpressDataSet::cloneIfcDoorStyle(ExpressDataSet *expressDataSet, const IfcDoorStyle &obj, const CopyOp &copyop) {
    IfcDoorStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDoorStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDoorStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDoorStyle *ExpressDataSet::cloneIfcDoorStyle(const IfcDoorStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDoorStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDoorStyle(this, obj, copyop);
    }
}

IfcDraughtingCallout *ExpressDataSet::getIfcDraughtingCallout(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDraughtingCallout * > (current->second.get());
    }
    else {
        IfcDraughtingCallout *ret = static_cast< IfcDraughtingCallout * > (allocateIfcDraughtingCallout(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDraughtingCallout(IfcDraughtingCallout *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDraughtingCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDraughtingCallout *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingCallout > ExpressDataSet::createIfcDraughtingCallout(bool isVolatile) {
    if (isVolatile) {
        return new IfcDraughtingCallout(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDraughtingCallout * > (allocateIfcDraughtingCallout(this, Step::Id_UNSET));
    }
}

IfcDraughtingCallout *ExpressDataSet::cloneIfcDraughtingCallout(ExpressDataSet *expressDataSet, const IfcDraughtingCallout &obj, const CopyOp &copyop) {
    IfcDraughtingCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingCallout *ExpressDataSet::cloneIfcDraughtingCallout(const IfcDraughtingCallout &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDraughtingCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDraughtingCallout(this, obj, copyop);
    }
}

IfcDraughtingCalloutRelationship *ExpressDataSet::getIfcDraughtingCalloutRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDraughtingCalloutRelationship * > (current->second.get());
    }
    else {
        IfcDraughtingCalloutRelationship *ret = static_cast< IfcDraughtingCalloutRelationship * > (allocateIfcDraughtingCalloutRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDraughtingCalloutRelationship(IfcDraughtingCalloutRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDraughtingCalloutRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingCalloutRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDraughtingCalloutRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingCalloutRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingCalloutRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingCalloutRelationship > ExpressDataSet::createIfcDraughtingCalloutRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcDraughtingCalloutRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDraughtingCalloutRelationship * > (allocateIfcDraughtingCalloutRelationship(this, Step::Id_UNSET));
    }
}

IfcDraughtingCalloutRelationship *ExpressDataSet::cloneIfcDraughtingCalloutRelationship(ExpressDataSet *expressDataSet, const IfcDraughtingCalloutRelationship &obj, const CopyOp &copyop) {
    IfcDraughtingCalloutRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingCalloutRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingCalloutRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingCalloutRelationship *ExpressDataSet::cloneIfcDraughtingCalloutRelationship(const IfcDraughtingCalloutRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDraughtingCalloutRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDraughtingCalloutRelationship(this, obj, copyop);
    }
}

IfcDraughtingPreDefinedColour *ExpressDataSet::getIfcDraughtingPreDefinedColour(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDraughtingPreDefinedColour * > (current->second.get());
    }
    else {
        IfcDraughtingPreDefinedColour *ret = static_cast< IfcDraughtingPreDefinedColour * > (allocateIfcDraughtingPreDefinedColour(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedColour(IfcDraughtingPreDefinedColour *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedColour_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedColour(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDraughtingPreDefinedColour *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedColour(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedColour_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedColour > ExpressDataSet::createIfcDraughtingPreDefinedColour(bool isVolatile) {
    if (isVolatile) {
        return new IfcDraughtingPreDefinedColour(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDraughtingPreDefinedColour * > (allocateIfcDraughtingPreDefinedColour(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedColour *ExpressDataSet::cloneIfcDraughtingPreDefinedColour(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedColour &obj, const CopyOp &copyop) {
    IfcDraughtingPreDefinedColour *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedColour(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedColour_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedColour *ExpressDataSet::cloneIfcDraughtingPreDefinedColour(const IfcDraughtingPreDefinedColour &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedColour(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedColour(this, obj, copyop);
    }
}

IfcDraughtingPreDefinedCurveFont *ExpressDataSet::getIfcDraughtingPreDefinedCurveFont(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDraughtingPreDefinedCurveFont * > (current->second.get());
    }
    else {
        IfcDraughtingPreDefinedCurveFont *ret = static_cast< IfcDraughtingPreDefinedCurveFont * > (allocateIfcDraughtingPreDefinedCurveFont(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedCurveFont(IfcDraughtingPreDefinedCurveFont *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedCurveFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedCurveFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDraughtingPreDefinedCurveFont *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedCurveFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedCurveFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedCurveFont > ExpressDataSet::createIfcDraughtingPreDefinedCurveFont(bool isVolatile) {
    if (isVolatile) {
        return new IfcDraughtingPreDefinedCurveFont(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDraughtingPreDefinedCurveFont * > (allocateIfcDraughtingPreDefinedCurveFont(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedCurveFont *ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedCurveFont &obj, const CopyOp &copyop) {
    IfcDraughtingPreDefinedCurveFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedCurveFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedCurveFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedCurveFont *ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(const IfcDraughtingPreDefinedCurveFont &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedCurveFont(this, obj, copyop);
    }
}

IfcDraughtingPreDefinedTextFont *ExpressDataSet::getIfcDraughtingPreDefinedTextFont(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDraughtingPreDefinedTextFont * > (current->second.get());
    }
    else {
        IfcDraughtingPreDefinedTextFont *ret = static_cast< IfcDraughtingPreDefinedTextFont * > (allocateIfcDraughtingPreDefinedTextFont(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDraughtingPreDefinedTextFont(IfcDraughtingPreDefinedTextFont *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDraughtingPreDefinedTextFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDraughtingPreDefinedTextFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDraughtingPreDefinedTextFont *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDraughtingPreDefinedTextFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDraughtingPreDefinedTextFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDraughtingPreDefinedTextFont > ExpressDataSet::createIfcDraughtingPreDefinedTextFont(bool isVolatile) {
    if (isVolatile) {
        return new IfcDraughtingPreDefinedTextFont(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDraughtingPreDefinedTextFont * > (allocateIfcDraughtingPreDefinedTextFont(this, Step::Id_UNSET));
    }
}

IfcDraughtingPreDefinedTextFont *ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(ExpressDataSet *expressDataSet, const IfcDraughtingPreDefinedTextFont &obj, const CopyOp &copyop) {
    IfcDraughtingPreDefinedTextFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDraughtingPreDefinedTextFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDraughtingPreDefinedTextFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDraughtingPreDefinedTextFont *ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(const IfcDraughtingPreDefinedTextFont &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDraughtingPreDefinedTextFont(this, obj, copyop);
    }
}

IfcDuctFittingType *ExpressDataSet::getIfcDuctFittingType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDuctFittingType * > (current->second.get());
    }
    else {
        IfcDuctFittingType *ret = static_cast< IfcDuctFittingType * > (allocateIfcDuctFittingType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDuctFittingType(IfcDuctFittingType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDuctFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDuctFittingType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctFittingType > ExpressDataSet::createIfcDuctFittingType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDuctFittingType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDuctFittingType * > (allocateIfcDuctFittingType(this, Step::Id_UNSET));
    }
}

IfcDuctFittingType *ExpressDataSet::cloneIfcDuctFittingType(ExpressDataSet *expressDataSet, const IfcDuctFittingType &obj, const CopyOp &copyop) {
    IfcDuctFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctFittingType *ExpressDataSet::cloneIfcDuctFittingType(const IfcDuctFittingType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDuctFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDuctFittingType(this, obj, copyop);
    }
}

IfcDuctSegmentType *ExpressDataSet::getIfcDuctSegmentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDuctSegmentType * > (current->second.get());
    }
    else {
        IfcDuctSegmentType *ret = static_cast< IfcDuctSegmentType * > (allocateIfcDuctSegmentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDuctSegmentType(IfcDuctSegmentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDuctSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDuctSegmentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctSegmentType > ExpressDataSet::createIfcDuctSegmentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDuctSegmentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDuctSegmentType * > (allocateIfcDuctSegmentType(this, Step::Id_UNSET));
    }
}

IfcDuctSegmentType *ExpressDataSet::cloneIfcDuctSegmentType(ExpressDataSet *expressDataSet, const IfcDuctSegmentType &obj, const CopyOp &copyop) {
    IfcDuctSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctSegmentType *ExpressDataSet::cloneIfcDuctSegmentType(const IfcDuctSegmentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDuctSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDuctSegmentType(this, obj, copyop);
    }
}

IfcDuctSilencerType *ExpressDataSet::getIfcDuctSilencerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcDuctSilencerType * > (current->second.get());
    }
    else {
        IfcDuctSilencerType *ret = static_cast< IfcDuctSilencerType * > (allocateIfcDuctSilencerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcDuctSilencerType(IfcDuctSilencerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcDuctSilencerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcDuctSilencerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcDuctSilencerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcDuctSilencerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcDuctSilencerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcDuctSilencerType > ExpressDataSet::createIfcDuctSilencerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcDuctSilencerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcDuctSilencerType * > (allocateIfcDuctSilencerType(this, Step::Id_UNSET));
    }
}

IfcDuctSilencerType *ExpressDataSet::cloneIfcDuctSilencerType(ExpressDataSet *expressDataSet, const IfcDuctSilencerType &obj, const CopyOp &copyop) {
    IfcDuctSilencerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcDuctSilencerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcDuctSilencerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcDuctSilencerType *ExpressDataSet::cloneIfcDuctSilencerType(const IfcDuctSilencerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcDuctSilencerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcDuctSilencerType(this, obj, copyop);
    }
}

IfcEdge *ExpressDataSet::getIfcEdge(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEdge * > (current->second.get());
    }
    else {
        IfcEdge *ret = static_cast< IfcEdge * > (allocateIfcEdge(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEdge(IfcEdge *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEdge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdge(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEdge *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdge > ExpressDataSet::createIfcEdge(bool isVolatile) {
    if (isVolatile) {
        return new IfcEdge(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEdge * > (allocateIfcEdge(this, Step::Id_UNSET));
    }
}

IfcEdge *ExpressDataSet::cloneIfcEdge(ExpressDataSet *expressDataSet, const IfcEdge &obj, const CopyOp &copyop) {
    IfcEdge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdge *ExpressDataSet::cloneIfcEdge(const IfcEdge &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEdge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEdge(this, obj, copyop);
    }
}

IfcEdgeCurve *ExpressDataSet::getIfcEdgeCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEdgeCurve * > (current->second.get());
    }
    else {
        IfcEdgeCurve *ret = static_cast< IfcEdgeCurve * > (allocateIfcEdgeCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEdgeCurve(IfcEdgeCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEdgeCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdgeCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEdgeCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdgeCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdgeCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdgeCurve > ExpressDataSet::createIfcEdgeCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcEdgeCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEdgeCurve * > (allocateIfcEdgeCurve(this, Step::Id_UNSET));
    }
}

IfcEdgeCurve *ExpressDataSet::cloneIfcEdgeCurve(ExpressDataSet *expressDataSet, const IfcEdgeCurve &obj, const CopyOp &copyop) {
    IfcEdgeCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdgeCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdgeCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdgeCurve *ExpressDataSet::cloneIfcEdgeCurve(const IfcEdgeCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEdgeCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEdgeCurve(this, obj, copyop);
    }
}

IfcEdgeLoop *ExpressDataSet::getIfcEdgeLoop(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEdgeLoop * > (current->second.get());
    }
    else {
        IfcEdgeLoop *ret = static_cast< IfcEdgeLoop * > (allocateIfcEdgeLoop(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEdgeLoop(IfcEdgeLoop *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEdgeLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEdgeLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEdgeLoop *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEdgeLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEdgeLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEdgeLoop > ExpressDataSet::createIfcEdgeLoop(bool isVolatile) {
    if (isVolatile) {
        return new IfcEdgeLoop(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEdgeLoop * > (allocateIfcEdgeLoop(this, Step::Id_UNSET));
    }
}

IfcEdgeLoop *ExpressDataSet::cloneIfcEdgeLoop(ExpressDataSet *expressDataSet, const IfcEdgeLoop &obj, const CopyOp &copyop) {
    IfcEdgeLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEdgeLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEdgeLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEdgeLoop *ExpressDataSet::cloneIfcEdgeLoop(const IfcEdgeLoop &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEdgeLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEdgeLoop(this, obj, copyop);
    }
}

IfcElectricApplianceType *ExpressDataSet::getIfcElectricApplianceType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricApplianceType * > (current->second.get());
    }
    else {
        IfcElectricApplianceType *ret = static_cast< IfcElectricApplianceType * > (allocateIfcElectricApplianceType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricApplianceType(IfcElectricApplianceType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricApplianceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricApplianceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricApplianceType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricApplianceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricApplianceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricApplianceType > ExpressDataSet::createIfcElectricApplianceType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricApplianceType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricApplianceType * > (allocateIfcElectricApplianceType(this, Step::Id_UNSET));
    }
}

IfcElectricApplianceType *ExpressDataSet::cloneIfcElectricApplianceType(ExpressDataSet *expressDataSet, const IfcElectricApplianceType &obj, const CopyOp &copyop) {
    IfcElectricApplianceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricApplianceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricApplianceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricApplianceType *ExpressDataSet::cloneIfcElectricApplianceType(const IfcElectricApplianceType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricApplianceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricApplianceType(this, obj, copyop);
    }
}

IfcElectricDistributionPoint *ExpressDataSet::getIfcElectricDistributionPoint(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricDistributionPoint * > (current->second.get());
    }
    else {
        IfcElectricDistributionPoint *ret = static_cast< IfcElectricDistributionPoint * > (allocateIfcElectricDistributionPoint(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricDistributionPoint(IfcElectricDistributionPoint *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricDistributionPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricDistributionPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricDistributionPoint *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricDistributionPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricDistributionPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricDistributionPoint > ExpressDataSet::createIfcElectricDistributionPoint(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricDistributionPoint(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricDistributionPoint * > (allocateIfcElectricDistributionPoint(this, Step::Id_UNSET));
    }
}

IfcElectricDistributionPoint *ExpressDataSet::cloneIfcElectricDistributionPoint(ExpressDataSet *expressDataSet, const IfcElectricDistributionPoint &obj, const CopyOp &copyop) {
    IfcElectricDistributionPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricDistributionPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricDistributionPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricDistributionPoint *ExpressDataSet::cloneIfcElectricDistributionPoint(const IfcElectricDistributionPoint &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricDistributionPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricDistributionPoint(this, obj, copyop);
    }
}

IfcElectricFlowStorageDeviceType *ExpressDataSet::getIfcElectricFlowStorageDeviceType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricFlowStorageDeviceType * > (current->second.get());
    }
    else {
        IfcElectricFlowStorageDeviceType *ret = static_cast< IfcElectricFlowStorageDeviceType * > (allocateIfcElectricFlowStorageDeviceType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricFlowStorageDeviceType(IfcElectricFlowStorageDeviceType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricFlowStorageDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricFlowStorageDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricFlowStorageDeviceType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricFlowStorageDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricFlowStorageDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricFlowStorageDeviceType > ExpressDataSet::createIfcElectricFlowStorageDeviceType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricFlowStorageDeviceType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricFlowStorageDeviceType * > (allocateIfcElectricFlowStorageDeviceType(this, Step::Id_UNSET));
    }
}

IfcElectricFlowStorageDeviceType *ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(ExpressDataSet *expressDataSet, const IfcElectricFlowStorageDeviceType &obj, const CopyOp &copyop) {
    IfcElectricFlowStorageDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricFlowStorageDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricFlowStorageDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricFlowStorageDeviceType *ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(const IfcElectricFlowStorageDeviceType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricFlowStorageDeviceType(this, obj, copyop);
    }
}

IfcElectricGeneratorType *ExpressDataSet::getIfcElectricGeneratorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricGeneratorType * > (current->second.get());
    }
    else {
        IfcElectricGeneratorType *ret = static_cast< IfcElectricGeneratorType * > (allocateIfcElectricGeneratorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricGeneratorType(IfcElectricGeneratorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricGeneratorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricGeneratorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricGeneratorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricGeneratorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricGeneratorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricGeneratorType > ExpressDataSet::createIfcElectricGeneratorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricGeneratorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricGeneratorType * > (allocateIfcElectricGeneratorType(this, Step::Id_UNSET));
    }
}

IfcElectricGeneratorType *ExpressDataSet::cloneIfcElectricGeneratorType(ExpressDataSet *expressDataSet, const IfcElectricGeneratorType &obj, const CopyOp &copyop) {
    IfcElectricGeneratorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricGeneratorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricGeneratorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricGeneratorType *ExpressDataSet::cloneIfcElectricGeneratorType(const IfcElectricGeneratorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricGeneratorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricGeneratorType(this, obj, copyop);
    }
}

IfcElectricHeaterType *ExpressDataSet::getIfcElectricHeaterType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricHeaterType * > (current->second.get());
    }
    else {
        IfcElectricHeaterType *ret = static_cast< IfcElectricHeaterType * > (allocateIfcElectricHeaterType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricHeaterType(IfcElectricHeaterType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricHeaterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricHeaterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricHeaterType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricHeaterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricHeaterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricHeaterType > ExpressDataSet::createIfcElectricHeaterType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricHeaterType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricHeaterType * > (allocateIfcElectricHeaterType(this, Step::Id_UNSET));
    }
}

IfcElectricHeaterType *ExpressDataSet::cloneIfcElectricHeaterType(ExpressDataSet *expressDataSet, const IfcElectricHeaterType &obj, const CopyOp &copyop) {
    IfcElectricHeaterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricHeaterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricHeaterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricHeaterType *ExpressDataSet::cloneIfcElectricHeaterType(const IfcElectricHeaterType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricHeaterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricHeaterType(this, obj, copyop);
    }
}

IfcElectricMotorType *ExpressDataSet::getIfcElectricMotorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricMotorType * > (current->second.get());
    }
    else {
        IfcElectricMotorType *ret = static_cast< IfcElectricMotorType * > (allocateIfcElectricMotorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricMotorType(IfcElectricMotorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricMotorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricMotorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricMotorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricMotorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricMotorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricMotorType > ExpressDataSet::createIfcElectricMotorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricMotorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricMotorType * > (allocateIfcElectricMotorType(this, Step::Id_UNSET));
    }
}

IfcElectricMotorType *ExpressDataSet::cloneIfcElectricMotorType(ExpressDataSet *expressDataSet, const IfcElectricMotorType &obj, const CopyOp &copyop) {
    IfcElectricMotorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricMotorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricMotorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricMotorType *ExpressDataSet::cloneIfcElectricMotorType(const IfcElectricMotorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricMotorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricMotorType(this, obj, copyop);
    }
}

IfcElectricTimeControlType *ExpressDataSet::getIfcElectricTimeControlType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricTimeControlType * > (current->second.get());
    }
    else {
        IfcElectricTimeControlType *ret = static_cast< IfcElectricTimeControlType * > (allocateIfcElectricTimeControlType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricTimeControlType(IfcElectricTimeControlType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricTimeControlType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricTimeControlType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricTimeControlType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricTimeControlType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricTimeControlType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricTimeControlType > ExpressDataSet::createIfcElectricTimeControlType(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricTimeControlType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricTimeControlType * > (allocateIfcElectricTimeControlType(this, Step::Id_UNSET));
    }
}

IfcElectricTimeControlType *ExpressDataSet::cloneIfcElectricTimeControlType(ExpressDataSet *expressDataSet, const IfcElectricTimeControlType &obj, const CopyOp &copyop) {
    IfcElectricTimeControlType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricTimeControlType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricTimeControlType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricTimeControlType *ExpressDataSet::cloneIfcElectricTimeControlType(const IfcElectricTimeControlType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricTimeControlType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricTimeControlType(this, obj, copyop);
    }
}

IfcElectricalBaseProperties *ExpressDataSet::getIfcElectricalBaseProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricalBaseProperties * > (current->second.get());
    }
    else {
        IfcElectricalBaseProperties *ret = static_cast< IfcElectricalBaseProperties * > (allocateIfcElectricalBaseProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricalBaseProperties(IfcElectricalBaseProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricalBaseProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalBaseProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricalBaseProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalBaseProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalBaseProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalBaseProperties > ExpressDataSet::createIfcElectricalBaseProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricalBaseProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricalBaseProperties * > (allocateIfcElectricalBaseProperties(this, Step::Id_UNSET));
    }
}

IfcElectricalBaseProperties *ExpressDataSet::cloneIfcElectricalBaseProperties(ExpressDataSet *expressDataSet, const IfcElectricalBaseProperties &obj, const CopyOp &copyop) {
    IfcElectricalBaseProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalBaseProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalBaseProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalBaseProperties *ExpressDataSet::cloneIfcElectricalBaseProperties(const IfcElectricalBaseProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricalBaseProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricalBaseProperties(this, obj, copyop);
    }
}

IfcElectricalCircuit *ExpressDataSet::getIfcElectricalCircuit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricalCircuit * > (current->second.get());
    }
    else {
        IfcElectricalCircuit *ret = static_cast< IfcElectricalCircuit * > (allocateIfcElectricalCircuit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricalCircuit(IfcElectricalCircuit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricalCircuit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalCircuit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricalCircuit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalCircuit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalCircuit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalCircuit > ExpressDataSet::createIfcElectricalCircuit(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricalCircuit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricalCircuit * > (allocateIfcElectricalCircuit(this, Step::Id_UNSET));
    }
}

IfcElectricalCircuit *ExpressDataSet::cloneIfcElectricalCircuit(ExpressDataSet *expressDataSet, const IfcElectricalCircuit &obj, const CopyOp &copyop) {
    IfcElectricalCircuit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalCircuit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalCircuit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalCircuit *ExpressDataSet::cloneIfcElectricalCircuit(const IfcElectricalCircuit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricalCircuit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricalCircuit(this, obj, copyop);
    }
}

IfcElectricalElement *ExpressDataSet::getIfcElectricalElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElectricalElement * > (current->second.get());
    }
    else {
        IfcElectricalElement *ret = static_cast< IfcElectricalElement * > (allocateIfcElectricalElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElectricalElement(IfcElectricalElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElectricalElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElectricalElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElectricalElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElectricalElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElectricalElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElectricalElement > ExpressDataSet::createIfcElectricalElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcElectricalElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElectricalElement * > (allocateIfcElectricalElement(this, Step::Id_UNSET));
    }
}

IfcElectricalElement *ExpressDataSet::cloneIfcElectricalElement(ExpressDataSet *expressDataSet, const IfcElectricalElement &obj, const CopyOp &copyop) {
    IfcElectricalElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElectricalElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElectricalElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElectricalElement *ExpressDataSet::cloneIfcElectricalElement(const IfcElectricalElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElectricalElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElectricalElement(this, obj, copyop);
    }
}

IfcElementAssembly *ExpressDataSet::getIfcElementAssembly(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElementAssembly * > (current->second.get());
    }
    else {
        IfcElementAssembly *ret = static_cast< IfcElementAssembly * > (allocateIfcElementAssembly(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElementAssembly(IfcElementAssembly *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElementAssembly_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementAssembly(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElementAssembly *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementAssembly(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementAssembly_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementAssembly > ExpressDataSet::createIfcElementAssembly(bool isVolatile) {
    if (isVolatile) {
        return new IfcElementAssembly(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElementAssembly * > (allocateIfcElementAssembly(this, Step::Id_UNSET));
    }
}

IfcElementAssembly *ExpressDataSet::cloneIfcElementAssembly(ExpressDataSet *expressDataSet, const IfcElementAssembly &obj, const CopyOp &copyop) {
    IfcElementAssembly *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementAssembly(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementAssembly_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementAssembly *ExpressDataSet::cloneIfcElementAssembly(const IfcElementAssembly &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElementAssembly(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElementAssembly(this, obj, copyop);
    }
}

IfcElementQuantity *ExpressDataSet::getIfcElementQuantity(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcElementQuantity * > (current->second.get());
    }
    else {
        IfcElementQuantity *ret = static_cast< IfcElementQuantity * > (allocateIfcElementQuantity(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcElementQuantity(IfcElementQuantity *arg) {
    getAll().erase(arg->getKey());
    return m_IfcElementQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcElementQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcElementQuantity *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcElementQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcElementQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcElementQuantity > ExpressDataSet::createIfcElementQuantity(bool isVolatile) {
    if (isVolatile) {
        return new IfcElementQuantity(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcElementQuantity * > (allocateIfcElementQuantity(this, Step::Id_UNSET));
    }
}

IfcElementQuantity *ExpressDataSet::cloneIfcElementQuantity(ExpressDataSet *expressDataSet, const IfcElementQuantity &obj, const CopyOp &copyop) {
    IfcElementQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcElementQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcElementQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcElementQuantity *ExpressDataSet::cloneIfcElementQuantity(const IfcElementQuantity &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcElementQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcElementQuantity(this, obj, copyop);
    }
}

IfcEllipse *ExpressDataSet::getIfcEllipse(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEllipse * > (current->second.get());
    }
    else {
        IfcEllipse *ret = static_cast< IfcEllipse * > (allocateIfcEllipse(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEllipse(IfcEllipse *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEllipse_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEllipse(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEllipse *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEllipse(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEllipse_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEllipse > ExpressDataSet::createIfcEllipse(bool isVolatile) {
    if (isVolatile) {
        return new IfcEllipse(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEllipse * > (allocateIfcEllipse(this, Step::Id_UNSET));
    }
}

IfcEllipse *ExpressDataSet::cloneIfcEllipse(ExpressDataSet *expressDataSet, const IfcEllipse &obj, const CopyOp &copyop) {
    IfcEllipse *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEllipse(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEllipse_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEllipse *ExpressDataSet::cloneIfcEllipse(const IfcEllipse &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEllipse(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEllipse(this, obj, copyop);
    }
}

IfcEllipseProfileDef *ExpressDataSet::getIfcEllipseProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEllipseProfileDef * > (current->second.get());
    }
    else {
        IfcEllipseProfileDef *ret = static_cast< IfcEllipseProfileDef * > (allocateIfcEllipseProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEllipseProfileDef(IfcEllipseProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEllipseProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEllipseProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEllipseProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEllipseProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEllipseProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEllipseProfileDef > ExpressDataSet::createIfcEllipseProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcEllipseProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEllipseProfileDef * > (allocateIfcEllipseProfileDef(this, Step::Id_UNSET));
    }
}

IfcEllipseProfileDef *ExpressDataSet::cloneIfcEllipseProfileDef(ExpressDataSet *expressDataSet, const IfcEllipseProfileDef &obj, const CopyOp &copyop) {
    IfcEllipseProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEllipseProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEllipseProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEllipseProfileDef *ExpressDataSet::cloneIfcEllipseProfileDef(const IfcEllipseProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEllipseProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEllipseProfileDef(this, obj, copyop);
    }
}

IfcEnergyConversionDevice *ExpressDataSet::getIfcEnergyConversionDevice(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEnergyConversionDevice * > (current->second.get());
    }
    else {
        IfcEnergyConversionDevice *ret = static_cast< IfcEnergyConversionDevice * > (allocateIfcEnergyConversionDevice(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEnergyConversionDevice(IfcEnergyConversionDevice *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEnergyConversionDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnergyConversionDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEnergyConversionDevice *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnergyConversionDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnergyConversionDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnergyConversionDevice > ExpressDataSet::createIfcEnergyConversionDevice(bool isVolatile) {
    if (isVolatile) {
        return new IfcEnergyConversionDevice(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEnergyConversionDevice * > (allocateIfcEnergyConversionDevice(this, Step::Id_UNSET));
    }
}

IfcEnergyConversionDevice *ExpressDataSet::cloneIfcEnergyConversionDevice(ExpressDataSet *expressDataSet, const IfcEnergyConversionDevice &obj, const CopyOp &copyop) {
    IfcEnergyConversionDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnergyConversionDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnergyConversionDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnergyConversionDevice *ExpressDataSet::cloneIfcEnergyConversionDevice(const IfcEnergyConversionDevice &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEnergyConversionDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEnergyConversionDevice(this, obj, copyop);
    }
}

IfcEnergyProperties *ExpressDataSet::getIfcEnergyProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEnergyProperties * > (current->second.get());
    }
    else {
        IfcEnergyProperties *ret = static_cast< IfcEnergyProperties * > (allocateIfcEnergyProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEnergyProperties(IfcEnergyProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEnergyProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnergyProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEnergyProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnergyProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnergyProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnergyProperties > ExpressDataSet::createIfcEnergyProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcEnergyProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEnergyProperties * > (allocateIfcEnergyProperties(this, Step::Id_UNSET));
    }
}

IfcEnergyProperties *ExpressDataSet::cloneIfcEnergyProperties(ExpressDataSet *expressDataSet, const IfcEnergyProperties &obj, const CopyOp &copyop) {
    IfcEnergyProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnergyProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnergyProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnergyProperties *ExpressDataSet::cloneIfcEnergyProperties(const IfcEnergyProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEnergyProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEnergyProperties(this, obj, copyop);
    }
}

IfcEnvironmentalImpactValue *ExpressDataSet::getIfcEnvironmentalImpactValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEnvironmentalImpactValue * > (current->second.get());
    }
    else {
        IfcEnvironmentalImpactValue *ret = static_cast< IfcEnvironmentalImpactValue * > (allocateIfcEnvironmentalImpactValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEnvironmentalImpactValue(IfcEnvironmentalImpactValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEnvironmentalImpactValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEnvironmentalImpactValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEnvironmentalImpactValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEnvironmentalImpactValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEnvironmentalImpactValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEnvironmentalImpactValue > ExpressDataSet::createIfcEnvironmentalImpactValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcEnvironmentalImpactValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEnvironmentalImpactValue * > (allocateIfcEnvironmentalImpactValue(this, Step::Id_UNSET));
    }
}

IfcEnvironmentalImpactValue *ExpressDataSet::cloneIfcEnvironmentalImpactValue(ExpressDataSet *expressDataSet, const IfcEnvironmentalImpactValue &obj, const CopyOp &copyop) {
    IfcEnvironmentalImpactValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEnvironmentalImpactValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEnvironmentalImpactValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEnvironmentalImpactValue *ExpressDataSet::cloneIfcEnvironmentalImpactValue(const IfcEnvironmentalImpactValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEnvironmentalImpactValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEnvironmentalImpactValue(this, obj, copyop);
    }
}

IfcEquipmentElement *ExpressDataSet::getIfcEquipmentElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEquipmentElement * > (current->second.get());
    }
    else {
        IfcEquipmentElement *ret = static_cast< IfcEquipmentElement * > (allocateIfcEquipmentElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEquipmentElement(IfcEquipmentElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEquipmentElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEquipmentElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEquipmentElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEquipmentElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEquipmentElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEquipmentElement > ExpressDataSet::createIfcEquipmentElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcEquipmentElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEquipmentElement * > (allocateIfcEquipmentElement(this, Step::Id_UNSET));
    }
}

IfcEquipmentElement *ExpressDataSet::cloneIfcEquipmentElement(ExpressDataSet *expressDataSet, const IfcEquipmentElement &obj, const CopyOp &copyop) {
    IfcEquipmentElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEquipmentElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEquipmentElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEquipmentElement *ExpressDataSet::cloneIfcEquipmentElement(const IfcEquipmentElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEquipmentElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEquipmentElement(this, obj, copyop);
    }
}

IfcEquipmentStandard *ExpressDataSet::getIfcEquipmentStandard(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEquipmentStandard * > (current->second.get());
    }
    else {
        IfcEquipmentStandard *ret = static_cast< IfcEquipmentStandard * > (allocateIfcEquipmentStandard(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEquipmentStandard(IfcEquipmentStandard *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEquipmentStandard_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEquipmentStandard(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEquipmentStandard *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEquipmentStandard(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEquipmentStandard_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEquipmentStandard > ExpressDataSet::createIfcEquipmentStandard(bool isVolatile) {
    if (isVolatile) {
        return new IfcEquipmentStandard(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEquipmentStandard * > (allocateIfcEquipmentStandard(this, Step::Id_UNSET));
    }
}

IfcEquipmentStandard *ExpressDataSet::cloneIfcEquipmentStandard(ExpressDataSet *expressDataSet, const IfcEquipmentStandard &obj, const CopyOp &copyop) {
    IfcEquipmentStandard *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEquipmentStandard(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEquipmentStandard_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEquipmentStandard *ExpressDataSet::cloneIfcEquipmentStandard(const IfcEquipmentStandard &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEquipmentStandard(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEquipmentStandard(this, obj, copyop);
    }
}

IfcEvaporativeCoolerType *ExpressDataSet::getIfcEvaporativeCoolerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEvaporativeCoolerType * > (current->second.get());
    }
    else {
        IfcEvaporativeCoolerType *ret = static_cast< IfcEvaporativeCoolerType * > (allocateIfcEvaporativeCoolerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEvaporativeCoolerType(IfcEvaporativeCoolerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEvaporativeCoolerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEvaporativeCoolerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEvaporativeCoolerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEvaporativeCoolerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEvaporativeCoolerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEvaporativeCoolerType > ExpressDataSet::createIfcEvaporativeCoolerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcEvaporativeCoolerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEvaporativeCoolerType * > (allocateIfcEvaporativeCoolerType(this, Step::Id_UNSET));
    }
}

IfcEvaporativeCoolerType *ExpressDataSet::cloneIfcEvaporativeCoolerType(ExpressDataSet *expressDataSet, const IfcEvaporativeCoolerType &obj, const CopyOp &copyop) {
    IfcEvaporativeCoolerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEvaporativeCoolerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEvaporativeCoolerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEvaporativeCoolerType *ExpressDataSet::cloneIfcEvaporativeCoolerType(const IfcEvaporativeCoolerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEvaporativeCoolerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEvaporativeCoolerType(this, obj, copyop);
    }
}

IfcEvaporatorType *ExpressDataSet::getIfcEvaporatorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcEvaporatorType * > (current->second.get());
    }
    else {
        IfcEvaporatorType *ret = static_cast< IfcEvaporatorType * > (allocateIfcEvaporatorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcEvaporatorType(IfcEvaporatorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcEvaporatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcEvaporatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcEvaporatorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcEvaporatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcEvaporatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcEvaporatorType > ExpressDataSet::createIfcEvaporatorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcEvaporatorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcEvaporatorType * > (allocateIfcEvaporatorType(this, Step::Id_UNSET));
    }
}

IfcEvaporatorType *ExpressDataSet::cloneIfcEvaporatorType(ExpressDataSet *expressDataSet, const IfcEvaporatorType &obj, const CopyOp &copyop) {
    IfcEvaporatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcEvaporatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcEvaporatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcEvaporatorType *ExpressDataSet::cloneIfcEvaporatorType(const IfcEvaporatorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcEvaporatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcEvaporatorType(this, obj, copyop);
    }
}

IfcExtendedMaterialProperties *ExpressDataSet::getIfcExtendedMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExtendedMaterialProperties * > (current->second.get());
    }
    else {
        IfcExtendedMaterialProperties *ret = static_cast< IfcExtendedMaterialProperties * > (allocateIfcExtendedMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExtendedMaterialProperties(IfcExtendedMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExtendedMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExtendedMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExtendedMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExtendedMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExtendedMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExtendedMaterialProperties > ExpressDataSet::createIfcExtendedMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcExtendedMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExtendedMaterialProperties * > (allocateIfcExtendedMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcExtendedMaterialProperties *ExpressDataSet::cloneIfcExtendedMaterialProperties(ExpressDataSet *expressDataSet, const IfcExtendedMaterialProperties &obj, const CopyOp &copyop) {
    IfcExtendedMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExtendedMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExtendedMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExtendedMaterialProperties *ExpressDataSet::cloneIfcExtendedMaterialProperties(const IfcExtendedMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExtendedMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExtendedMaterialProperties(this, obj, copyop);
    }
}

IfcExternallyDefinedHatchStyle *ExpressDataSet::getIfcExternallyDefinedHatchStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExternallyDefinedHatchStyle * > (current->second.get());
    }
    else {
        IfcExternallyDefinedHatchStyle *ret = static_cast< IfcExternallyDefinedHatchStyle * > (allocateIfcExternallyDefinedHatchStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExternallyDefinedHatchStyle(IfcExternallyDefinedHatchStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedHatchStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedHatchStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExternallyDefinedHatchStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedHatchStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedHatchStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedHatchStyle > ExpressDataSet::createIfcExternallyDefinedHatchStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcExternallyDefinedHatchStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExternallyDefinedHatchStyle * > (allocateIfcExternallyDefinedHatchStyle(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedHatchStyle *ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(ExpressDataSet *expressDataSet, const IfcExternallyDefinedHatchStyle &obj, const CopyOp &copyop) {
    IfcExternallyDefinedHatchStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedHatchStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedHatchStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedHatchStyle *ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(const IfcExternallyDefinedHatchStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExternallyDefinedHatchStyle(this, obj, copyop);
    }
}

IfcExternallyDefinedSurfaceStyle *ExpressDataSet::getIfcExternallyDefinedSurfaceStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExternallyDefinedSurfaceStyle * > (current->second.get());
    }
    else {
        IfcExternallyDefinedSurfaceStyle *ret = static_cast< IfcExternallyDefinedSurfaceStyle * > (allocateIfcExternallyDefinedSurfaceStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExternallyDefinedSurfaceStyle(IfcExternallyDefinedSurfaceStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedSurfaceStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedSurfaceStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExternallyDefinedSurfaceStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedSurfaceStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedSurfaceStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedSurfaceStyle > ExpressDataSet::createIfcExternallyDefinedSurfaceStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcExternallyDefinedSurfaceStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExternallyDefinedSurfaceStyle * > (allocateIfcExternallyDefinedSurfaceStyle(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedSurfaceStyle *ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(ExpressDataSet *expressDataSet, const IfcExternallyDefinedSurfaceStyle &obj, const CopyOp &copyop) {
    IfcExternallyDefinedSurfaceStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedSurfaceStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedSurfaceStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedSurfaceStyle *ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(const IfcExternallyDefinedSurfaceStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExternallyDefinedSurfaceStyle(this, obj, copyop);
    }
}

IfcExternallyDefinedSymbol *ExpressDataSet::getIfcExternallyDefinedSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExternallyDefinedSymbol * > (current->second.get());
    }
    else {
        IfcExternallyDefinedSymbol *ret = static_cast< IfcExternallyDefinedSymbol * > (allocateIfcExternallyDefinedSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExternallyDefinedSymbol(IfcExternallyDefinedSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExternallyDefinedSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedSymbol > ExpressDataSet::createIfcExternallyDefinedSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcExternallyDefinedSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExternallyDefinedSymbol * > (allocateIfcExternallyDefinedSymbol(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedSymbol *ExpressDataSet::cloneIfcExternallyDefinedSymbol(ExpressDataSet *expressDataSet, const IfcExternallyDefinedSymbol &obj, const CopyOp &copyop) {
    IfcExternallyDefinedSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedSymbol *ExpressDataSet::cloneIfcExternallyDefinedSymbol(const IfcExternallyDefinedSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExternallyDefinedSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExternallyDefinedSymbol(this, obj, copyop);
    }
}

IfcExternallyDefinedTextFont *ExpressDataSet::getIfcExternallyDefinedTextFont(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExternallyDefinedTextFont * > (current->second.get());
    }
    else {
        IfcExternallyDefinedTextFont *ret = static_cast< IfcExternallyDefinedTextFont * > (allocateIfcExternallyDefinedTextFont(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExternallyDefinedTextFont(IfcExternallyDefinedTextFont *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExternallyDefinedTextFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExternallyDefinedTextFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExternallyDefinedTextFont *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExternallyDefinedTextFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExternallyDefinedTextFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExternallyDefinedTextFont > ExpressDataSet::createIfcExternallyDefinedTextFont(bool isVolatile) {
    if (isVolatile) {
        return new IfcExternallyDefinedTextFont(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExternallyDefinedTextFont * > (allocateIfcExternallyDefinedTextFont(this, Step::Id_UNSET));
    }
}

IfcExternallyDefinedTextFont *ExpressDataSet::cloneIfcExternallyDefinedTextFont(ExpressDataSet *expressDataSet, const IfcExternallyDefinedTextFont &obj, const CopyOp &copyop) {
    IfcExternallyDefinedTextFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExternallyDefinedTextFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExternallyDefinedTextFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExternallyDefinedTextFont *ExpressDataSet::cloneIfcExternallyDefinedTextFont(const IfcExternallyDefinedTextFont &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExternallyDefinedTextFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExternallyDefinedTextFont(this, obj, copyop);
    }
}

IfcExtrudedAreaSolid *ExpressDataSet::getIfcExtrudedAreaSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcExtrudedAreaSolid * > (current->second.get());
    }
    else {
        IfcExtrudedAreaSolid *ret = static_cast< IfcExtrudedAreaSolid * > (allocateIfcExtrudedAreaSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcExtrudedAreaSolid(IfcExtrudedAreaSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcExtrudedAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcExtrudedAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcExtrudedAreaSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcExtrudedAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcExtrudedAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcExtrudedAreaSolid > ExpressDataSet::createIfcExtrudedAreaSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcExtrudedAreaSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcExtrudedAreaSolid * > (allocateIfcExtrudedAreaSolid(this, Step::Id_UNSET));
    }
}

IfcExtrudedAreaSolid *ExpressDataSet::cloneIfcExtrudedAreaSolid(ExpressDataSet *expressDataSet, const IfcExtrudedAreaSolid &obj, const CopyOp &copyop) {
    IfcExtrudedAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcExtrudedAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcExtrudedAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcExtrudedAreaSolid *ExpressDataSet::cloneIfcExtrudedAreaSolid(const IfcExtrudedAreaSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcExtrudedAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcExtrudedAreaSolid(this, obj, copyop);
    }
}

IfcFace *ExpressDataSet::getIfcFace(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFace * > (current->second.get());
    }
    else {
        IfcFace *ret = static_cast< IfcFace * > (allocateIfcFace(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFace(IfcFace *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFace(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFace *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFace > ExpressDataSet::createIfcFace(bool isVolatile) {
    if (isVolatile) {
        return new IfcFace(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFace * > (allocateIfcFace(this, Step::Id_UNSET));
    }
}

IfcFace *ExpressDataSet::cloneIfcFace(ExpressDataSet *expressDataSet, const IfcFace &obj, const CopyOp &copyop) {
    IfcFace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFace *ExpressDataSet::cloneIfcFace(const IfcFace &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFace(this, obj, copyop);
    }
}

IfcFaceBasedSurfaceModel *ExpressDataSet::getIfcFaceBasedSurfaceModel(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFaceBasedSurfaceModel * > (current->second.get());
    }
    else {
        IfcFaceBasedSurfaceModel *ret = static_cast< IfcFaceBasedSurfaceModel * > (allocateIfcFaceBasedSurfaceModel(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFaceBasedSurfaceModel(IfcFaceBasedSurfaceModel *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFaceBasedSurfaceModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceBasedSurfaceModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFaceBasedSurfaceModel *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceBasedSurfaceModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceBasedSurfaceModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceBasedSurfaceModel > ExpressDataSet::createIfcFaceBasedSurfaceModel(bool isVolatile) {
    if (isVolatile) {
        return new IfcFaceBasedSurfaceModel(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFaceBasedSurfaceModel * > (allocateIfcFaceBasedSurfaceModel(this, Step::Id_UNSET));
    }
}

IfcFaceBasedSurfaceModel *ExpressDataSet::cloneIfcFaceBasedSurfaceModel(ExpressDataSet *expressDataSet, const IfcFaceBasedSurfaceModel &obj, const CopyOp &copyop) {
    IfcFaceBasedSurfaceModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceBasedSurfaceModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceBasedSurfaceModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceBasedSurfaceModel *ExpressDataSet::cloneIfcFaceBasedSurfaceModel(const IfcFaceBasedSurfaceModel &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFaceBasedSurfaceModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFaceBasedSurfaceModel(this, obj, copyop);
    }
}

IfcFaceBound *ExpressDataSet::getIfcFaceBound(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFaceBound * > (current->second.get());
    }
    else {
        IfcFaceBound *ret = static_cast< IfcFaceBound * > (allocateIfcFaceBound(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFaceBound(IfcFaceBound *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFaceBound_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceBound(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFaceBound *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceBound(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceBound_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceBound > ExpressDataSet::createIfcFaceBound(bool isVolatile) {
    if (isVolatile) {
        return new IfcFaceBound(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFaceBound * > (allocateIfcFaceBound(this, Step::Id_UNSET));
    }
}

IfcFaceBound *ExpressDataSet::cloneIfcFaceBound(ExpressDataSet *expressDataSet, const IfcFaceBound &obj, const CopyOp &copyop) {
    IfcFaceBound *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceBound(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceBound_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceBound *ExpressDataSet::cloneIfcFaceBound(const IfcFaceBound &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFaceBound(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFaceBound(this, obj, copyop);
    }
}

IfcFaceOuterBound *ExpressDataSet::getIfcFaceOuterBound(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFaceOuterBound * > (current->second.get());
    }
    else {
        IfcFaceOuterBound *ret = static_cast< IfcFaceOuterBound * > (allocateIfcFaceOuterBound(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFaceOuterBound(IfcFaceOuterBound *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFaceOuterBound_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceOuterBound(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFaceOuterBound *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceOuterBound(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceOuterBound_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceOuterBound > ExpressDataSet::createIfcFaceOuterBound(bool isVolatile) {
    if (isVolatile) {
        return new IfcFaceOuterBound(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFaceOuterBound * > (allocateIfcFaceOuterBound(this, Step::Id_UNSET));
    }
}

IfcFaceOuterBound *ExpressDataSet::cloneIfcFaceOuterBound(ExpressDataSet *expressDataSet, const IfcFaceOuterBound &obj, const CopyOp &copyop) {
    IfcFaceOuterBound *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceOuterBound(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceOuterBound_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceOuterBound *ExpressDataSet::cloneIfcFaceOuterBound(const IfcFaceOuterBound &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFaceOuterBound(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFaceOuterBound(this, obj, copyop);
    }
}

IfcFaceSurface *ExpressDataSet::getIfcFaceSurface(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFaceSurface * > (current->second.get());
    }
    else {
        IfcFaceSurface *ret = static_cast< IfcFaceSurface * > (allocateIfcFaceSurface(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFaceSurface(IfcFaceSurface *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFaceSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFaceSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFaceSurface *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFaceSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFaceSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFaceSurface > ExpressDataSet::createIfcFaceSurface(bool isVolatile) {
    if (isVolatile) {
        return new IfcFaceSurface(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFaceSurface * > (allocateIfcFaceSurface(this, Step::Id_UNSET));
    }
}

IfcFaceSurface *ExpressDataSet::cloneIfcFaceSurface(ExpressDataSet *expressDataSet, const IfcFaceSurface &obj, const CopyOp &copyop) {
    IfcFaceSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFaceSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFaceSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFaceSurface *ExpressDataSet::cloneIfcFaceSurface(const IfcFaceSurface &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFaceSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFaceSurface(this, obj, copyop);
    }
}

IfcFacetedBrep *ExpressDataSet::getIfcFacetedBrep(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFacetedBrep * > (current->second.get());
    }
    else {
        IfcFacetedBrep *ret = static_cast< IfcFacetedBrep * > (allocateIfcFacetedBrep(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFacetedBrep(IfcFacetedBrep *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFacetedBrep_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFacetedBrep(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFacetedBrep *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFacetedBrep(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFacetedBrep_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFacetedBrep > ExpressDataSet::createIfcFacetedBrep(bool isVolatile) {
    if (isVolatile) {
        return new IfcFacetedBrep(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFacetedBrep * > (allocateIfcFacetedBrep(this, Step::Id_UNSET));
    }
}

IfcFacetedBrep *ExpressDataSet::cloneIfcFacetedBrep(ExpressDataSet *expressDataSet, const IfcFacetedBrep &obj, const CopyOp &copyop) {
    IfcFacetedBrep *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFacetedBrep(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFacetedBrep_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFacetedBrep *ExpressDataSet::cloneIfcFacetedBrep(const IfcFacetedBrep &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFacetedBrep(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFacetedBrep(this, obj, copyop);
    }
}

IfcFacetedBrepWithVoids *ExpressDataSet::getIfcFacetedBrepWithVoids(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFacetedBrepWithVoids * > (current->second.get());
    }
    else {
        IfcFacetedBrepWithVoids *ret = static_cast< IfcFacetedBrepWithVoids * > (allocateIfcFacetedBrepWithVoids(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFacetedBrepWithVoids(IfcFacetedBrepWithVoids *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFacetedBrepWithVoids_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFacetedBrepWithVoids(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFacetedBrepWithVoids *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFacetedBrepWithVoids(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFacetedBrepWithVoids_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFacetedBrepWithVoids > ExpressDataSet::createIfcFacetedBrepWithVoids(bool isVolatile) {
    if (isVolatile) {
        return new IfcFacetedBrepWithVoids(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFacetedBrepWithVoids * > (allocateIfcFacetedBrepWithVoids(this, Step::Id_UNSET));
    }
}

IfcFacetedBrepWithVoids *ExpressDataSet::cloneIfcFacetedBrepWithVoids(ExpressDataSet *expressDataSet, const IfcFacetedBrepWithVoids &obj, const CopyOp &copyop) {
    IfcFacetedBrepWithVoids *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFacetedBrepWithVoids(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFacetedBrepWithVoids_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFacetedBrepWithVoids *ExpressDataSet::cloneIfcFacetedBrepWithVoids(const IfcFacetedBrepWithVoids &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFacetedBrepWithVoids(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFacetedBrepWithVoids(this, obj, copyop);
    }
}

IfcFailureConnectionCondition *ExpressDataSet::getIfcFailureConnectionCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFailureConnectionCondition * > (current->second.get());
    }
    else {
        IfcFailureConnectionCondition *ret = static_cast< IfcFailureConnectionCondition * > (allocateIfcFailureConnectionCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFailureConnectionCondition(IfcFailureConnectionCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFailureConnectionCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFailureConnectionCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFailureConnectionCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFailureConnectionCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFailureConnectionCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFailureConnectionCondition > ExpressDataSet::createIfcFailureConnectionCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcFailureConnectionCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFailureConnectionCondition * > (allocateIfcFailureConnectionCondition(this, Step::Id_UNSET));
    }
}

IfcFailureConnectionCondition *ExpressDataSet::cloneIfcFailureConnectionCondition(ExpressDataSet *expressDataSet, const IfcFailureConnectionCondition &obj, const CopyOp &copyop) {
    IfcFailureConnectionCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFailureConnectionCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFailureConnectionCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFailureConnectionCondition *ExpressDataSet::cloneIfcFailureConnectionCondition(const IfcFailureConnectionCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFailureConnectionCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFailureConnectionCondition(this, obj, copyop);
    }
}

IfcFanType *ExpressDataSet::getIfcFanType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFanType * > (current->second.get());
    }
    else {
        IfcFanType *ret = static_cast< IfcFanType * > (allocateIfcFanType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFanType(IfcFanType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFanType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFanType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFanType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFanType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFanType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFanType > ExpressDataSet::createIfcFanType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFanType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFanType * > (allocateIfcFanType(this, Step::Id_UNSET));
    }
}

IfcFanType *ExpressDataSet::cloneIfcFanType(ExpressDataSet *expressDataSet, const IfcFanType &obj, const CopyOp &copyop) {
    IfcFanType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFanType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFanType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFanType *ExpressDataSet::cloneIfcFanType(const IfcFanType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFanType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFanType(this, obj, copyop);
    }
}

IfcFastener *ExpressDataSet::getIfcFastener(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFastener * > (current->second.get());
    }
    else {
        IfcFastener *ret = static_cast< IfcFastener * > (allocateIfcFastener(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFastener(IfcFastener *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFastener_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFastener(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFastener *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFastener(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFastener_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFastener > ExpressDataSet::createIfcFastener(bool isVolatile) {
    if (isVolatile) {
        return new IfcFastener(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFastener * > (allocateIfcFastener(this, Step::Id_UNSET));
    }
}

IfcFastener *ExpressDataSet::cloneIfcFastener(ExpressDataSet *expressDataSet, const IfcFastener &obj, const CopyOp &copyop) {
    IfcFastener *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFastener(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFastener_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFastener *ExpressDataSet::cloneIfcFastener(const IfcFastener &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFastener(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFastener(this, obj, copyop);
    }
}

IfcFastenerType *ExpressDataSet::getIfcFastenerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFastenerType * > (current->second.get());
    }
    else {
        IfcFastenerType *ret = static_cast< IfcFastenerType * > (allocateIfcFastenerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFastenerType(IfcFastenerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFastenerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFastenerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFastenerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFastenerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFastenerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFastenerType > ExpressDataSet::createIfcFastenerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFastenerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFastenerType * > (allocateIfcFastenerType(this, Step::Id_UNSET));
    }
}

IfcFastenerType *ExpressDataSet::cloneIfcFastenerType(ExpressDataSet *expressDataSet, const IfcFastenerType &obj, const CopyOp &copyop) {
    IfcFastenerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFastenerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFastenerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFastenerType *ExpressDataSet::cloneIfcFastenerType(const IfcFastenerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFastenerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFastenerType(this, obj, copyop);
    }
}

IfcFillAreaStyle *ExpressDataSet::getIfcFillAreaStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFillAreaStyle * > (current->second.get());
    }
    else {
        IfcFillAreaStyle *ret = static_cast< IfcFillAreaStyle * > (allocateIfcFillAreaStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFillAreaStyle(IfcFillAreaStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFillAreaStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyle > ExpressDataSet::createIfcFillAreaStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcFillAreaStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFillAreaStyle * > (allocateIfcFillAreaStyle(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyle *ExpressDataSet::cloneIfcFillAreaStyle(ExpressDataSet *expressDataSet, const IfcFillAreaStyle &obj, const CopyOp &copyop) {
    IfcFillAreaStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyle *ExpressDataSet::cloneIfcFillAreaStyle(const IfcFillAreaStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFillAreaStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFillAreaStyle(this, obj, copyop);
    }
}

IfcFillAreaStyleHatching *ExpressDataSet::getIfcFillAreaStyleHatching(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFillAreaStyleHatching * > (current->second.get());
    }
    else {
        IfcFillAreaStyleHatching *ret = static_cast< IfcFillAreaStyleHatching * > (allocateIfcFillAreaStyleHatching(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFillAreaStyleHatching(IfcFillAreaStyleHatching *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleHatching_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleHatching(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFillAreaStyleHatching *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleHatching(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleHatching_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleHatching > ExpressDataSet::createIfcFillAreaStyleHatching(bool isVolatile) {
    if (isVolatile) {
        return new IfcFillAreaStyleHatching(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFillAreaStyleHatching * > (allocateIfcFillAreaStyleHatching(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleHatching *ExpressDataSet::cloneIfcFillAreaStyleHatching(ExpressDataSet *expressDataSet, const IfcFillAreaStyleHatching &obj, const CopyOp &copyop) {
    IfcFillAreaStyleHatching *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleHatching(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleHatching_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleHatching *ExpressDataSet::cloneIfcFillAreaStyleHatching(const IfcFillAreaStyleHatching &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFillAreaStyleHatching(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFillAreaStyleHatching(this, obj, copyop);
    }
}

IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::getIfcFillAreaStyleTileSymbolWithStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (current->second.get());
    }
    else {
        IfcFillAreaStyleTileSymbolWithStyle *ret = static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (allocateIfcFillAreaStyleTileSymbolWithStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFillAreaStyleTileSymbolWithStyle(IfcFillAreaStyleTileSymbolWithStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleTileSymbolWithStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleTileSymbolWithStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFillAreaStyleTileSymbolWithStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleTileSymbolWithStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleTileSymbolWithStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleTileSymbolWithStyle > ExpressDataSet::createIfcFillAreaStyleTileSymbolWithStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcFillAreaStyleTileSymbolWithStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFillAreaStyleTileSymbolWithStyle * > (allocateIfcFillAreaStyleTileSymbolWithStyle(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(ExpressDataSet *expressDataSet, const IfcFillAreaStyleTileSymbolWithStyle &obj, const CopyOp &copyop) {
    IfcFillAreaStyleTileSymbolWithStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleTileSymbolWithStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleTileSymbolWithStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleTileSymbolWithStyle *ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(const IfcFillAreaStyleTileSymbolWithStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFillAreaStyleTileSymbolWithStyle(this, obj, copyop);
    }
}

IfcFillAreaStyleTiles *ExpressDataSet::getIfcFillAreaStyleTiles(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFillAreaStyleTiles * > (current->second.get());
    }
    else {
        IfcFillAreaStyleTiles *ret = static_cast< IfcFillAreaStyleTiles * > (allocateIfcFillAreaStyleTiles(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFillAreaStyleTiles(IfcFillAreaStyleTiles *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFillAreaStyleTiles_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFillAreaStyleTiles(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFillAreaStyleTiles *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFillAreaStyleTiles(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFillAreaStyleTiles_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFillAreaStyleTiles > ExpressDataSet::createIfcFillAreaStyleTiles(bool isVolatile) {
    if (isVolatile) {
        return new IfcFillAreaStyleTiles(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFillAreaStyleTiles * > (allocateIfcFillAreaStyleTiles(this, Step::Id_UNSET));
    }
}

IfcFillAreaStyleTiles *ExpressDataSet::cloneIfcFillAreaStyleTiles(ExpressDataSet *expressDataSet, const IfcFillAreaStyleTiles &obj, const CopyOp &copyop) {
    IfcFillAreaStyleTiles *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFillAreaStyleTiles(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFillAreaStyleTiles_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFillAreaStyleTiles *ExpressDataSet::cloneIfcFillAreaStyleTiles(const IfcFillAreaStyleTiles &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFillAreaStyleTiles(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFillAreaStyleTiles(this, obj, copyop);
    }
}

IfcFilterType *ExpressDataSet::getIfcFilterType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFilterType * > (current->second.get());
    }
    else {
        IfcFilterType *ret = static_cast< IfcFilterType * > (allocateIfcFilterType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFilterType(IfcFilterType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFilterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFilterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFilterType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFilterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFilterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFilterType > ExpressDataSet::createIfcFilterType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFilterType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFilterType * > (allocateIfcFilterType(this, Step::Id_UNSET));
    }
}

IfcFilterType *ExpressDataSet::cloneIfcFilterType(ExpressDataSet *expressDataSet, const IfcFilterType &obj, const CopyOp &copyop) {
    IfcFilterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFilterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFilterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFilterType *ExpressDataSet::cloneIfcFilterType(const IfcFilterType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFilterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFilterType(this, obj, copyop);
    }
}

IfcFireSuppressionTerminalType *ExpressDataSet::getIfcFireSuppressionTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFireSuppressionTerminalType * > (current->second.get());
    }
    else {
        IfcFireSuppressionTerminalType *ret = static_cast< IfcFireSuppressionTerminalType * > (allocateIfcFireSuppressionTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFireSuppressionTerminalType(IfcFireSuppressionTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFireSuppressionTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFireSuppressionTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFireSuppressionTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFireSuppressionTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFireSuppressionTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFireSuppressionTerminalType > ExpressDataSet::createIfcFireSuppressionTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFireSuppressionTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFireSuppressionTerminalType * > (allocateIfcFireSuppressionTerminalType(this, Step::Id_UNSET));
    }
}

IfcFireSuppressionTerminalType *ExpressDataSet::cloneIfcFireSuppressionTerminalType(ExpressDataSet *expressDataSet, const IfcFireSuppressionTerminalType &obj, const CopyOp &copyop) {
    IfcFireSuppressionTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFireSuppressionTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFireSuppressionTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFireSuppressionTerminalType *ExpressDataSet::cloneIfcFireSuppressionTerminalType(const IfcFireSuppressionTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFireSuppressionTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFireSuppressionTerminalType(this, obj, copyop);
    }
}

IfcFlowController *ExpressDataSet::getIfcFlowController(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowController * > (current->second.get());
    }
    else {
        IfcFlowController *ret = static_cast< IfcFlowController * > (allocateIfcFlowController(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowController(IfcFlowController *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowController_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowController(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowController *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowController(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowController_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowController > ExpressDataSet::createIfcFlowController(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowController(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowController * > (allocateIfcFlowController(this, Step::Id_UNSET));
    }
}

IfcFlowController *ExpressDataSet::cloneIfcFlowController(ExpressDataSet *expressDataSet, const IfcFlowController &obj, const CopyOp &copyop) {
    IfcFlowController *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowController(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowController_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowController *ExpressDataSet::cloneIfcFlowController(const IfcFlowController &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowController(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowController(this, obj, copyop);
    }
}

IfcFlowFitting *ExpressDataSet::getIfcFlowFitting(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowFitting * > (current->second.get());
    }
    else {
        IfcFlowFitting *ret = static_cast< IfcFlowFitting * > (allocateIfcFlowFitting(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowFitting(IfcFlowFitting *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowFitting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowFitting(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowFitting *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowFitting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowFitting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowFitting > ExpressDataSet::createIfcFlowFitting(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowFitting(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowFitting * > (allocateIfcFlowFitting(this, Step::Id_UNSET));
    }
}

IfcFlowFitting *ExpressDataSet::cloneIfcFlowFitting(ExpressDataSet *expressDataSet, const IfcFlowFitting &obj, const CopyOp &copyop) {
    IfcFlowFitting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowFitting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowFitting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowFitting *ExpressDataSet::cloneIfcFlowFitting(const IfcFlowFitting &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowFitting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowFitting(this, obj, copyop);
    }
}

IfcFlowInstrumentType *ExpressDataSet::getIfcFlowInstrumentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowInstrumentType * > (current->second.get());
    }
    else {
        IfcFlowInstrumentType *ret = static_cast< IfcFlowInstrumentType * > (allocateIfcFlowInstrumentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowInstrumentType(IfcFlowInstrumentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowInstrumentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowInstrumentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowInstrumentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowInstrumentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowInstrumentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowInstrumentType > ExpressDataSet::createIfcFlowInstrumentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowInstrumentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowInstrumentType * > (allocateIfcFlowInstrumentType(this, Step::Id_UNSET));
    }
}

IfcFlowInstrumentType *ExpressDataSet::cloneIfcFlowInstrumentType(ExpressDataSet *expressDataSet, const IfcFlowInstrumentType &obj, const CopyOp &copyop) {
    IfcFlowInstrumentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowInstrumentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowInstrumentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowInstrumentType *ExpressDataSet::cloneIfcFlowInstrumentType(const IfcFlowInstrumentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowInstrumentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowInstrumentType(this, obj, copyop);
    }
}

IfcFlowMeterType *ExpressDataSet::getIfcFlowMeterType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowMeterType * > (current->second.get());
    }
    else {
        IfcFlowMeterType *ret = static_cast< IfcFlowMeterType * > (allocateIfcFlowMeterType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowMeterType(IfcFlowMeterType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowMeterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowMeterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowMeterType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowMeterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowMeterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowMeterType > ExpressDataSet::createIfcFlowMeterType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowMeterType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowMeterType * > (allocateIfcFlowMeterType(this, Step::Id_UNSET));
    }
}

IfcFlowMeterType *ExpressDataSet::cloneIfcFlowMeterType(ExpressDataSet *expressDataSet, const IfcFlowMeterType &obj, const CopyOp &copyop) {
    IfcFlowMeterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowMeterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowMeterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowMeterType *ExpressDataSet::cloneIfcFlowMeterType(const IfcFlowMeterType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowMeterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowMeterType(this, obj, copyop);
    }
}

IfcFlowMovingDevice *ExpressDataSet::getIfcFlowMovingDevice(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowMovingDevice * > (current->second.get());
    }
    else {
        IfcFlowMovingDevice *ret = static_cast< IfcFlowMovingDevice * > (allocateIfcFlowMovingDevice(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowMovingDevice(IfcFlowMovingDevice *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowMovingDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowMovingDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowMovingDevice *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowMovingDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowMovingDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowMovingDevice > ExpressDataSet::createIfcFlowMovingDevice(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowMovingDevice(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowMovingDevice * > (allocateIfcFlowMovingDevice(this, Step::Id_UNSET));
    }
}

IfcFlowMovingDevice *ExpressDataSet::cloneIfcFlowMovingDevice(ExpressDataSet *expressDataSet, const IfcFlowMovingDevice &obj, const CopyOp &copyop) {
    IfcFlowMovingDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowMovingDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowMovingDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowMovingDevice *ExpressDataSet::cloneIfcFlowMovingDevice(const IfcFlowMovingDevice &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowMovingDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowMovingDevice(this, obj, copyop);
    }
}

IfcFlowSegment *ExpressDataSet::getIfcFlowSegment(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowSegment * > (current->second.get());
    }
    else {
        IfcFlowSegment *ret = static_cast< IfcFlowSegment * > (allocateIfcFlowSegment(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowSegment(IfcFlowSegment *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowSegment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowSegment(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowSegment *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowSegment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowSegment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowSegment > ExpressDataSet::createIfcFlowSegment(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowSegment(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowSegment * > (allocateIfcFlowSegment(this, Step::Id_UNSET));
    }
}

IfcFlowSegment *ExpressDataSet::cloneIfcFlowSegment(ExpressDataSet *expressDataSet, const IfcFlowSegment &obj, const CopyOp &copyop) {
    IfcFlowSegment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowSegment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowSegment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowSegment *ExpressDataSet::cloneIfcFlowSegment(const IfcFlowSegment &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowSegment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowSegment(this, obj, copyop);
    }
}

IfcFlowStorageDevice *ExpressDataSet::getIfcFlowStorageDevice(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowStorageDevice * > (current->second.get());
    }
    else {
        IfcFlowStorageDevice *ret = static_cast< IfcFlowStorageDevice * > (allocateIfcFlowStorageDevice(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowStorageDevice(IfcFlowStorageDevice *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowStorageDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowStorageDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowStorageDevice *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowStorageDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowStorageDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowStorageDevice > ExpressDataSet::createIfcFlowStorageDevice(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowStorageDevice(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowStorageDevice * > (allocateIfcFlowStorageDevice(this, Step::Id_UNSET));
    }
}

IfcFlowStorageDevice *ExpressDataSet::cloneIfcFlowStorageDevice(ExpressDataSet *expressDataSet, const IfcFlowStorageDevice &obj, const CopyOp &copyop) {
    IfcFlowStorageDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowStorageDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowStorageDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowStorageDevice *ExpressDataSet::cloneIfcFlowStorageDevice(const IfcFlowStorageDevice &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowStorageDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowStorageDevice(this, obj, copyop);
    }
}

IfcFlowTerminal *ExpressDataSet::getIfcFlowTerminal(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowTerminal * > (current->second.get());
    }
    else {
        IfcFlowTerminal *ret = static_cast< IfcFlowTerminal * > (allocateIfcFlowTerminal(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowTerminal(IfcFlowTerminal *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowTerminal_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTerminal(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowTerminal *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTerminal(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTerminal_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTerminal > ExpressDataSet::createIfcFlowTerminal(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowTerminal(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowTerminal * > (allocateIfcFlowTerminal(this, Step::Id_UNSET));
    }
}

IfcFlowTerminal *ExpressDataSet::cloneIfcFlowTerminal(ExpressDataSet *expressDataSet, const IfcFlowTerminal &obj, const CopyOp &copyop) {
    IfcFlowTerminal *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTerminal(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTerminal_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTerminal *ExpressDataSet::cloneIfcFlowTerminal(const IfcFlowTerminal &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowTerminal(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowTerminal(this, obj, copyop);
    }
}

IfcFlowTreatmentDevice *ExpressDataSet::getIfcFlowTreatmentDevice(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFlowTreatmentDevice * > (current->second.get());
    }
    else {
        IfcFlowTreatmentDevice *ret = static_cast< IfcFlowTreatmentDevice * > (allocateIfcFlowTreatmentDevice(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFlowTreatmentDevice(IfcFlowTreatmentDevice *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFlowTreatmentDevice_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFlowTreatmentDevice(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFlowTreatmentDevice *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFlowTreatmentDevice(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFlowTreatmentDevice_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFlowTreatmentDevice > ExpressDataSet::createIfcFlowTreatmentDevice(bool isVolatile) {
    if (isVolatile) {
        return new IfcFlowTreatmentDevice(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFlowTreatmentDevice * > (allocateIfcFlowTreatmentDevice(this, Step::Id_UNSET));
    }
}

IfcFlowTreatmentDevice *ExpressDataSet::cloneIfcFlowTreatmentDevice(ExpressDataSet *expressDataSet, const IfcFlowTreatmentDevice &obj, const CopyOp &copyop) {
    IfcFlowTreatmentDevice *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFlowTreatmentDevice(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFlowTreatmentDevice_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFlowTreatmentDevice *ExpressDataSet::cloneIfcFlowTreatmentDevice(const IfcFlowTreatmentDevice &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFlowTreatmentDevice(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFlowTreatmentDevice(this, obj, copyop);
    }
}

IfcFluidFlowProperties *ExpressDataSet::getIfcFluidFlowProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFluidFlowProperties * > (current->second.get());
    }
    else {
        IfcFluidFlowProperties *ret = static_cast< IfcFluidFlowProperties * > (allocateIfcFluidFlowProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFluidFlowProperties(IfcFluidFlowProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFluidFlowProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFluidFlowProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFluidFlowProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFluidFlowProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFluidFlowProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFluidFlowProperties > ExpressDataSet::createIfcFluidFlowProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcFluidFlowProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFluidFlowProperties * > (allocateIfcFluidFlowProperties(this, Step::Id_UNSET));
    }
}

IfcFluidFlowProperties *ExpressDataSet::cloneIfcFluidFlowProperties(ExpressDataSet *expressDataSet, const IfcFluidFlowProperties &obj, const CopyOp &copyop) {
    IfcFluidFlowProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFluidFlowProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFluidFlowProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFluidFlowProperties *ExpressDataSet::cloneIfcFluidFlowProperties(const IfcFluidFlowProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFluidFlowProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFluidFlowProperties(this, obj, copyop);
    }
}

IfcFooting *ExpressDataSet::getIfcFooting(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFooting * > (current->second.get());
    }
    else {
        IfcFooting *ret = static_cast< IfcFooting * > (allocateIfcFooting(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFooting(IfcFooting *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFooting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFooting(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFooting *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFooting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFooting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFooting > ExpressDataSet::createIfcFooting(bool isVolatile) {
    if (isVolatile) {
        return new IfcFooting(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFooting * > (allocateIfcFooting(this, Step::Id_UNSET));
    }
}

IfcFooting *ExpressDataSet::cloneIfcFooting(ExpressDataSet *expressDataSet, const IfcFooting &obj, const CopyOp &copyop) {
    IfcFooting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFooting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFooting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFooting *ExpressDataSet::cloneIfcFooting(const IfcFooting &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFooting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFooting(this, obj, copyop);
    }
}

IfcFuelProperties *ExpressDataSet::getIfcFuelProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFuelProperties * > (current->second.get());
    }
    else {
        IfcFuelProperties *ret = static_cast< IfcFuelProperties * > (allocateIfcFuelProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFuelProperties(IfcFuelProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFuelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFuelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFuelProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFuelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFuelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFuelProperties > ExpressDataSet::createIfcFuelProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcFuelProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFuelProperties * > (allocateIfcFuelProperties(this, Step::Id_UNSET));
    }
}

IfcFuelProperties *ExpressDataSet::cloneIfcFuelProperties(ExpressDataSet *expressDataSet, const IfcFuelProperties &obj, const CopyOp &copyop) {
    IfcFuelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFuelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFuelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFuelProperties *ExpressDataSet::cloneIfcFuelProperties(const IfcFuelProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFuelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFuelProperties(this, obj, copyop);
    }
}

IfcFurnishingElement *ExpressDataSet::getIfcFurnishingElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFurnishingElement * > (current->second.get());
    }
    else {
        IfcFurnishingElement *ret = static_cast< IfcFurnishingElement * > (allocateIfcFurnishingElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFurnishingElement(IfcFurnishingElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFurnishingElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnishingElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFurnishingElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnishingElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnishingElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnishingElement > ExpressDataSet::createIfcFurnishingElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcFurnishingElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFurnishingElement * > (allocateIfcFurnishingElement(this, Step::Id_UNSET));
    }
}

IfcFurnishingElement *ExpressDataSet::cloneIfcFurnishingElement(ExpressDataSet *expressDataSet, const IfcFurnishingElement &obj, const CopyOp &copyop) {
    IfcFurnishingElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnishingElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnishingElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnishingElement *ExpressDataSet::cloneIfcFurnishingElement(const IfcFurnishingElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFurnishingElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFurnishingElement(this, obj, copyop);
    }
}

IfcFurnishingElementType *ExpressDataSet::getIfcFurnishingElementType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFurnishingElementType * > (current->second.get());
    }
    else {
        IfcFurnishingElementType *ret = static_cast< IfcFurnishingElementType * > (allocateIfcFurnishingElementType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFurnishingElementType(IfcFurnishingElementType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFurnishingElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnishingElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFurnishingElementType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnishingElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnishingElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnishingElementType > ExpressDataSet::createIfcFurnishingElementType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFurnishingElementType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFurnishingElementType * > (allocateIfcFurnishingElementType(this, Step::Id_UNSET));
    }
}

IfcFurnishingElementType *ExpressDataSet::cloneIfcFurnishingElementType(ExpressDataSet *expressDataSet, const IfcFurnishingElementType &obj, const CopyOp &copyop) {
    IfcFurnishingElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnishingElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnishingElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnishingElementType *ExpressDataSet::cloneIfcFurnishingElementType(const IfcFurnishingElementType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFurnishingElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFurnishingElementType(this, obj, copyop);
    }
}

IfcFurnitureStandard *ExpressDataSet::getIfcFurnitureStandard(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFurnitureStandard * > (current->second.get());
    }
    else {
        IfcFurnitureStandard *ret = static_cast< IfcFurnitureStandard * > (allocateIfcFurnitureStandard(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFurnitureStandard(IfcFurnitureStandard *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFurnitureStandard_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnitureStandard(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFurnitureStandard *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnitureStandard(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnitureStandard_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnitureStandard > ExpressDataSet::createIfcFurnitureStandard(bool isVolatile) {
    if (isVolatile) {
        return new IfcFurnitureStandard(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFurnitureStandard * > (allocateIfcFurnitureStandard(this, Step::Id_UNSET));
    }
}

IfcFurnitureStandard *ExpressDataSet::cloneIfcFurnitureStandard(ExpressDataSet *expressDataSet, const IfcFurnitureStandard &obj, const CopyOp &copyop) {
    IfcFurnitureStandard *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnitureStandard(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnitureStandard_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnitureStandard *ExpressDataSet::cloneIfcFurnitureStandard(const IfcFurnitureStandard &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFurnitureStandard(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFurnitureStandard(this, obj, copyop);
    }
}

IfcFurnitureType *ExpressDataSet::getIfcFurnitureType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcFurnitureType * > (current->second.get());
    }
    else {
        IfcFurnitureType *ret = static_cast< IfcFurnitureType * > (allocateIfcFurnitureType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcFurnitureType(IfcFurnitureType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcFurnitureType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcFurnitureType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcFurnitureType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcFurnitureType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcFurnitureType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcFurnitureType > ExpressDataSet::createIfcFurnitureType(bool isVolatile) {
    if (isVolatile) {
        return new IfcFurnitureType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcFurnitureType * > (allocateIfcFurnitureType(this, Step::Id_UNSET));
    }
}

IfcFurnitureType *ExpressDataSet::cloneIfcFurnitureType(ExpressDataSet *expressDataSet, const IfcFurnitureType &obj, const CopyOp &copyop) {
    IfcFurnitureType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcFurnitureType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcFurnitureType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcFurnitureType *ExpressDataSet::cloneIfcFurnitureType(const IfcFurnitureType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcFurnitureType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcFurnitureType(this, obj, copyop);
    }
}

IfcGasTerminalType *ExpressDataSet::getIfcGasTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGasTerminalType * > (current->second.get());
    }
    else {
        IfcGasTerminalType *ret = static_cast< IfcGasTerminalType * > (allocateIfcGasTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGasTerminalType(IfcGasTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGasTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGasTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGasTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGasTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGasTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGasTerminalType > ExpressDataSet::createIfcGasTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcGasTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGasTerminalType * > (allocateIfcGasTerminalType(this, Step::Id_UNSET));
    }
}

IfcGasTerminalType *ExpressDataSet::cloneIfcGasTerminalType(ExpressDataSet *expressDataSet, const IfcGasTerminalType &obj, const CopyOp &copyop) {
    IfcGasTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGasTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGasTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGasTerminalType *ExpressDataSet::cloneIfcGasTerminalType(const IfcGasTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGasTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGasTerminalType(this, obj, copyop);
    }
}

IfcGeneralMaterialProperties *ExpressDataSet::getIfcGeneralMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeneralMaterialProperties * > (current->second.get());
    }
    else {
        IfcGeneralMaterialProperties *ret = static_cast< IfcGeneralMaterialProperties * > (allocateIfcGeneralMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeneralMaterialProperties(IfcGeneralMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeneralMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeneralMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeneralMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeneralMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeneralMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeneralMaterialProperties > ExpressDataSet::createIfcGeneralMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeneralMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeneralMaterialProperties * > (allocateIfcGeneralMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcGeneralMaterialProperties *ExpressDataSet::cloneIfcGeneralMaterialProperties(ExpressDataSet *expressDataSet, const IfcGeneralMaterialProperties &obj, const CopyOp &copyop) {
    IfcGeneralMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeneralMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeneralMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeneralMaterialProperties *ExpressDataSet::cloneIfcGeneralMaterialProperties(const IfcGeneralMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeneralMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeneralMaterialProperties(this, obj, copyop);
    }
}

IfcGeneralProfileProperties *ExpressDataSet::getIfcGeneralProfileProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeneralProfileProperties * > (current->second.get());
    }
    else {
        IfcGeneralProfileProperties *ret = static_cast< IfcGeneralProfileProperties * > (allocateIfcGeneralProfileProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeneralProfileProperties(IfcGeneralProfileProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeneralProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeneralProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeneralProfileProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeneralProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeneralProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeneralProfileProperties > ExpressDataSet::createIfcGeneralProfileProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeneralProfileProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeneralProfileProperties * > (allocateIfcGeneralProfileProperties(this, Step::Id_UNSET));
    }
}

IfcGeneralProfileProperties *ExpressDataSet::cloneIfcGeneralProfileProperties(ExpressDataSet *expressDataSet, const IfcGeneralProfileProperties &obj, const CopyOp &copyop) {
    IfcGeneralProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeneralProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeneralProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeneralProfileProperties *ExpressDataSet::cloneIfcGeneralProfileProperties(const IfcGeneralProfileProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeneralProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeneralProfileProperties(this, obj, copyop);
    }
}

IfcGeometricCurveSet *ExpressDataSet::getIfcGeometricCurveSet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeometricCurveSet * > (current->second.get());
    }
    else {
        IfcGeometricCurveSet *ret = static_cast< IfcGeometricCurveSet * > (allocateIfcGeometricCurveSet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeometricCurveSet(IfcGeometricCurveSet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeometricCurveSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricCurveSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeometricCurveSet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricCurveSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricCurveSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricCurveSet > ExpressDataSet::createIfcGeometricCurveSet(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeometricCurveSet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeometricCurveSet * > (allocateIfcGeometricCurveSet(this, Step::Id_UNSET));
    }
}

IfcGeometricCurveSet *ExpressDataSet::cloneIfcGeometricCurveSet(ExpressDataSet *expressDataSet, const IfcGeometricCurveSet &obj, const CopyOp &copyop) {
    IfcGeometricCurveSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricCurveSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricCurveSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricCurveSet *ExpressDataSet::cloneIfcGeometricCurveSet(const IfcGeometricCurveSet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeometricCurveSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeometricCurveSet(this, obj, copyop);
    }
}

IfcGeometricRepresentationContext *ExpressDataSet::getIfcGeometricRepresentationContext(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeometricRepresentationContext * > (current->second.get());
    }
    else {
        IfcGeometricRepresentationContext *ret = static_cast< IfcGeometricRepresentationContext * > (allocateIfcGeometricRepresentationContext(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeometricRepresentationContext(IfcGeometricRepresentationContext *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeometricRepresentationContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricRepresentationContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeometricRepresentationContext *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricRepresentationContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricRepresentationContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricRepresentationContext > ExpressDataSet::createIfcGeometricRepresentationContext(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeometricRepresentationContext(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeometricRepresentationContext * > (allocateIfcGeometricRepresentationContext(this, Step::Id_UNSET));
    }
}

IfcGeometricRepresentationContext *ExpressDataSet::cloneIfcGeometricRepresentationContext(ExpressDataSet *expressDataSet, const IfcGeometricRepresentationContext &obj, const CopyOp &copyop) {
    IfcGeometricRepresentationContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricRepresentationContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricRepresentationContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricRepresentationContext *ExpressDataSet::cloneIfcGeometricRepresentationContext(const IfcGeometricRepresentationContext &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeometricRepresentationContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeometricRepresentationContext(this, obj, copyop);
    }
}

IfcGeometricRepresentationSubContext *ExpressDataSet::getIfcGeometricRepresentationSubContext(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeometricRepresentationSubContext * > (current->second.get());
    }
    else {
        IfcGeometricRepresentationSubContext *ret = static_cast< IfcGeometricRepresentationSubContext * > (allocateIfcGeometricRepresentationSubContext(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeometricRepresentationSubContext(IfcGeometricRepresentationSubContext *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeometricRepresentationSubContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricRepresentationSubContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeometricRepresentationSubContext *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricRepresentationSubContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricRepresentationSubContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricRepresentationSubContext > ExpressDataSet::createIfcGeometricRepresentationSubContext(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeometricRepresentationSubContext(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeometricRepresentationSubContext * > (allocateIfcGeometricRepresentationSubContext(this, Step::Id_UNSET));
    }
}

IfcGeometricRepresentationSubContext *ExpressDataSet::cloneIfcGeometricRepresentationSubContext(ExpressDataSet *expressDataSet, const IfcGeometricRepresentationSubContext &obj, const CopyOp &copyop) {
    IfcGeometricRepresentationSubContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricRepresentationSubContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricRepresentationSubContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricRepresentationSubContext *ExpressDataSet::cloneIfcGeometricRepresentationSubContext(const IfcGeometricRepresentationSubContext &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeometricRepresentationSubContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeometricRepresentationSubContext(this, obj, copyop);
    }
}

IfcGeometricSet *ExpressDataSet::getIfcGeometricSet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGeometricSet * > (current->second.get());
    }
    else {
        IfcGeometricSet *ret = static_cast< IfcGeometricSet * > (allocateIfcGeometricSet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGeometricSet(IfcGeometricSet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGeometricSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGeometricSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGeometricSet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGeometricSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGeometricSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGeometricSet > ExpressDataSet::createIfcGeometricSet(bool isVolatile) {
    if (isVolatile) {
        return new IfcGeometricSet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGeometricSet * > (allocateIfcGeometricSet(this, Step::Id_UNSET));
    }
}

IfcGeometricSet *ExpressDataSet::cloneIfcGeometricSet(ExpressDataSet *expressDataSet, const IfcGeometricSet &obj, const CopyOp &copyop) {
    IfcGeometricSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGeometricSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGeometricSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGeometricSet *ExpressDataSet::cloneIfcGeometricSet(const IfcGeometricSet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGeometricSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGeometricSet(this, obj, copyop);
    }
}

IfcGrid *ExpressDataSet::getIfcGrid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGrid * > (current->second.get());
    }
    else {
        IfcGrid *ret = static_cast< IfcGrid * > (allocateIfcGrid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGrid(IfcGrid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGrid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGrid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGrid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGrid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGrid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGrid > ExpressDataSet::createIfcGrid(bool isVolatile) {
    if (isVolatile) {
        return new IfcGrid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGrid * > (allocateIfcGrid(this, Step::Id_UNSET));
    }
}

IfcGrid *ExpressDataSet::cloneIfcGrid(ExpressDataSet *expressDataSet, const IfcGrid &obj, const CopyOp &copyop) {
    IfcGrid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGrid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGrid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGrid *ExpressDataSet::cloneIfcGrid(const IfcGrid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGrid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGrid(this, obj, copyop);
    }
}

IfcGridAxis *ExpressDataSet::getIfcGridAxis(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGridAxis * > (current->second.get());
    }
    else {
        IfcGridAxis *ret = static_cast< IfcGridAxis * > (allocateIfcGridAxis(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGridAxis(IfcGridAxis *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGridAxis_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGridAxis(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGridAxis *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGridAxis(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGridAxis_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGridAxis > ExpressDataSet::createIfcGridAxis(bool isVolatile) {
    if (isVolatile) {
        return new IfcGridAxis(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGridAxis * > (allocateIfcGridAxis(this, Step::Id_UNSET));
    }
}

IfcGridAxis *ExpressDataSet::cloneIfcGridAxis(ExpressDataSet *expressDataSet, const IfcGridAxis &obj, const CopyOp &copyop) {
    IfcGridAxis *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGridAxis(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGridAxis_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGridAxis *ExpressDataSet::cloneIfcGridAxis(const IfcGridAxis &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGridAxis(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGridAxis(this, obj, copyop);
    }
}

IfcGridPlacement *ExpressDataSet::getIfcGridPlacement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGridPlacement * > (current->second.get());
    }
    else {
        IfcGridPlacement *ret = static_cast< IfcGridPlacement * > (allocateIfcGridPlacement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGridPlacement(IfcGridPlacement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGridPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGridPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGridPlacement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGridPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGridPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGridPlacement > ExpressDataSet::createIfcGridPlacement(bool isVolatile) {
    if (isVolatile) {
        return new IfcGridPlacement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGridPlacement * > (allocateIfcGridPlacement(this, Step::Id_UNSET));
    }
}

IfcGridPlacement *ExpressDataSet::cloneIfcGridPlacement(ExpressDataSet *expressDataSet, const IfcGridPlacement &obj, const CopyOp &copyop) {
    IfcGridPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGridPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGridPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGridPlacement *ExpressDataSet::cloneIfcGridPlacement(const IfcGridPlacement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGridPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGridPlacement(this, obj, copyop);
    }
}

IfcGroup *ExpressDataSet::getIfcGroup(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcGroup * > (current->second.get());
    }
    else {
        IfcGroup *ret = static_cast< IfcGroup * > (allocateIfcGroup(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcGroup(IfcGroup *arg) {
    getAll().erase(arg->getKey());
    return m_IfcGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcGroup *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcGroup > ExpressDataSet::createIfcGroup(bool isVolatile) {
    if (isVolatile) {
        return new IfcGroup(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcGroup * > (allocateIfcGroup(this, Step::Id_UNSET));
    }
}

IfcGroup *ExpressDataSet::cloneIfcGroup(ExpressDataSet *expressDataSet, const IfcGroup &obj, const CopyOp &copyop) {
    IfcGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcGroup *ExpressDataSet::cloneIfcGroup(const IfcGroup &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcGroup(this, obj, copyop);
    }
}

IfcHalfSpaceSolid *ExpressDataSet::getIfcHalfSpaceSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcHalfSpaceSolid * > (current->second.get());
    }
    else {
        IfcHalfSpaceSolid *ret = static_cast< IfcHalfSpaceSolid * > (allocateIfcHalfSpaceSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcHalfSpaceSolid(IfcHalfSpaceSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcHalfSpaceSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHalfSpaceSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcHalfSpaceSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHalfSpaceSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHalfSpaceSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHalfSpaceSolid > ExpressDataSet::createIfcHalfSpaceSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcHalfSpaceSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcHalfSpaceSolid * > (allocateIfcHalfSpaceSolid(this, Step::Id_UNSET));
    }
}

IfcHalfSpaceSolid *ExpressDataSet::cloneIfcHalfSpaceSolid(ExpressDataSet *expressDataSet, const IfcHalfSpaceSolid &obj, const CopyOp &copyop) {
    IfcHalfSpaceSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHalfSpaceSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHalfSpaceSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHalfSpaceSolid *ExpressDataSet::cloneIfcHalfSpaceSolid(const IfcHalfSpaceSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcHalfSpaceSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcHalfSpaceSolid(this, obj, copyop);
    }
}

IfcHeatExchangerType *ExpressDataSet::getIfcHeatExchangerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcHeatExchangerType * > (current->second.get());
    }
    else {
        IfcHeatExchangerType *ret = static_cast< IfcHeatExchangerType * > (allocateIfcHeatExchangerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcHeatExchangerType(IfcHeatExchangerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcHeatExchangerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHeatExchangerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcHeatExchangerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHeatExchangerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHeatExchangerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHeatExchangerType > ExpressDataSet::createIfcHeatExchangerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcHeatExchangerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcHeatExchangerType * > (allocateIfcHeatExchangerType(this, Step::Id_UNSET));
    }
}

IfcHeatExchangerType *ExpressDataSet::cloneIfcHeatExchangerType(ExpressDataSet *expressDataSet, const IfcHeatExchangerType &obj, const CopyOp &copyop) {
    IfcHeatExchangerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHeatExchangerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHeatExchangerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHeatExchangerType *ExpressDataSet::cloneIfcHeatExchangerType(const IfcHeatExchangerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcHeatExchangerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcHeatExchangerType(this, obj, copyop);
    }
}

IfcHumidifierType *ExpressDataSet::getIfcHumidifierType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcHumidifierType * > (current->second.get());
    }
    else {
        IfcHumidifierType *ret = static_cast< IfcHumidifierType * > (allocateIfcHumidifierType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcHumidifierType(IfcHumidifierType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcHumidifierType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHumidifierType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcHumidifierType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHumidifierType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHumidifierType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHumidifierType > ExpressDataSet::createIfcHumidifierType(bool isVolatile) {
    if (isVolatile) {
        return new IfcHumidifierType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcHumidifierType * > (allocateIfcHumidifierType(this, Step::Id_UNSET));
    }
}

IfcHumidifierType *ExpressDataSet::cloneIfcHumidifierType(ExpressDataSet *expressDataSet, const IfcHumidifierType &obj, const CopyOp &copyop) {
    IfcHumidifierType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHumidifierType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHumidifierType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHumidifierType *ExpressDataSet::cloneIfcHumidifierType(const IfcHumidifierType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcHumidifierType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcHumidifierType(this, obj, copyop);
    }
}

IfcHygroscopicMaterialProperties *ExpressDataSet::getIfcHygroscopicMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcHygroscopicMaterialProperties * > (current->second.get());
    }
    else {
        IfcHygroscopicMaterialProperties *ret = static_cast< IfcHygroscopicMaterialProperties * > (allocateIfcHygroscopicMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcHygroscopicMaterialProperties(IfcHygroscopicMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcHygroscopicMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcHygroscopicMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcHygroscopicMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcHygroscopicMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcHygroscopicMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcHygroscopicMaterialProperties > ExpressDataSet::createIfcHygroscopicMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcHygroscopicMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcHygroscopicMaterialProperties * > (allocateIfcHygroscopicMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcHygroscopicMaterialProperties *ExpressDataSet::cloneIfcHygroscopicMaterialProperties(ExpressDataSet *expressDataSet, const IfcHygroscopicMaterialProperties &obj, const CopyOp &copyop) {
    IfcHygroscopicMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcHygroscopicMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcHygroscopicMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcHygroscopicMaterialProperties *ExpressDataSet::cloneIfcHygroscopicMaterialProperties(const IfcHygroscopicMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcHygroscopicMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcHygroscopicMaterialProperties(this, obj, copyop);
    }
}

IfcIShapeProfileDef *ExpressDataSet::getIfcIShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcIShapeProfileDef * > (current->second.get());
    }
    else {
        IfcIShapeProfileDef *ret = static_cast< IfcIShapeProfileDef * > (allocateIfcIShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcIShapeProfileDef(IfcIShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcIShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcIShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIShapeProfileDef > ExpressDataSet::createIfcIShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcIShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcIShapeProfileDef * > (allocateIfcIShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcIShapeProfileDef *ExpressDataSet::cloneIfcIShapeProfileDef(ExpressDataSet *expressDataSet, const IfcIShapeProfileDef &obj, const CopyOp &copyop) {
    IfcIShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIShapeProfileDef *ExpressDataSet::cloneIfcIShapeProfileDef(const IfcIShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcIShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcIShapeProfileDef(this, obj, copyop);
    }
}

IfcImageTexture *ExpressDataSet::getIfcImageTexture(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcImageTexture * > (current->second.get());
    }
    else {
        IfcImageTexture *ret = static_cast< IfcImageTexture * > (allocateIfcImageTexture(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcImageTexture(IfcImageTexture *arg) {
    getAll().erase(arg->getKey());
    return m_IfcImageTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcImageTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcImageTexture *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcImageTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcImageTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcImageTexture > ExpressDataSet::createIfcImageTexture(bool isVolatile) {
    if (isVolatile) {
        return new IfcImageTexture(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcImageTexture * > (allocateIfcImageTexture(this, Step::Id_UNSET));
    }
}

IfcImageTexture *ExpressDataSet::cloneIfcImageTexture(ExpressDataSet *expressDataSet, const IfcImageTexture &obj, const CopyOp &copyop) {
    IfcImageTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcImageTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcImageTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcImageTexture *ExpressDataSet::cloneIfcImageTexture(const IfcImageTexture &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcImageTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcImageTexture(this, obj, copyop);
    }
}

IfcInventory *ExpressDataSet::getIfcInventory(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcInventory * > (current->second.get());
    }
    else {
        IfcInventory *ret = static_cast< IfcInventory * > (allocateIfcInventory(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcInventory(IfcInventory *arg) {
    getAll().erase(arg->getKey());
    return m_IfcInventory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcInventory(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcInventory *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcInventory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcInventory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcInventory > ExpressDataSet::createIfcInventory(bool isVolatile) {
    if (isVolatile) {
        return new IfcInventory(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcInventory * > (allocateIfcInventory(this, Step::Id_UNSET));
    }
}

IfcInventory *ExpressDataSet::cloneIfcInventory(ExpressDataSet *expressDataSet, const IfcInventory &obj, const CopyOp &copyop) {
    IfcInventory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcInventory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcInventory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcInventory *ExpressDataSet::cloneIfcInventory(const IfcInventory &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcInventory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcInventory(this, obj, copyop);
    }
}

IfcIrregularTimeSeries *ExpressDataSet::getIfcIrregularTimeSeries(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcIrregularTimeSeries * > (current->second.get());
    }
    else {
        IfcIrregularTimeSeries *ret = static_cast< IfcIrregularTimeSeries * > (allocateIfcIrregularTimeSeries(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcIrregularTimeSeries(IfcIrregularTimeSeries *arg) {
    getAll().erase(arg->getKey());
    return m_IfcIrregularTimeSeries_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIrregularTimeSeries(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcIrregularTimeSeries *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIrregularTimeSeries(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIrregularTimeSeries_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIrregularTimeSeries > ExpressDataSet::createIfcIrregularTimeSeries(bool isVolatile) {
    if (isVolatile) {
        return new IfcIrregularTimeSeries(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcIrregularTimeSeries * > (allocateIfcIrregularTimeSeries(this, Step::Id_UNSET));
    }
}

IfcIrregularTimeSeries *ExpressDataSet::cloneIfcIrregularTimeSeries(ExpressDataSet *expressDataSet, const IfcIrregularTimeSeries &obj, const CopyOp &copyop) {
    IfcIrregularTimeSeries *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIrregularTimeSeries(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIrregularTimeSeries_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIrregularTimeSeries *ExpressDataSet::cloneIfcIrregularTimeSeries(const IfcIrregularTimeSeries &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcIrregularTimeSeries(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcIrregularTimeSeries(this, obj, copyop);
    }
}

IfcIrregularTimeSeriesValue *ExpressDataSet::getIfcIrregularTimeSeriesValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcIrregularTimeSeriesValue * > (current->second.get());
    }
    else {
        IfcIrregularTimeSeriesValue *ret = static_cast< IfcIrregularTimeSeriesValue * > (allocateIfcIrregularTimeSeriesValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcIrregularTimeSeriesValue(IfcIrregularTimeSeriesValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcIrregularTimeSeriesValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcIrregularTimeSeriesValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcIrregularTimeSeriesValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcIrregularTimeSeriesValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcIrregularTimeSeriesValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcIrregularTimeSeriesValue > ExpressDataSet::createIfcIrregularTimeSeriesValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcIrregularTimeSeriesValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcIrregularTimeSeriesValue * > (allocateIfcIrregularTimeSeriesValue(this, Step::Id_UNSET));
    }
}

IfcIrregularTimeSeriesValue *ExpressDataSet::cloneIfcIrregularTimeSeriesValue(ExpressDataSet *expressDataSet, const IfcIrregularTimeSeriesValue &obj, const CopyOp &copyop) {
    IfcIrregularTimeSeriesValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcIrregularTimeSeriesValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcIrregularTimeSeriesValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcIrregularTimeSeriesValue *ExpressDataSet::cloneIfcIrregularTimeSeriesValue(const IfcIrregularTimeSeriesValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcIrregularTimeSeriesValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcIrregularTimeSeriesValue(this, obj, copyop);
    }
}

IfcJunctionBoxType *ExpressDataSet::getIfcJunctionBoxType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcJunctionBoxType * > (current->second.get());
    }
    else {
        IfcJunctionBoxType *ret = static_cast< IfcJunctionBoxType * > (allocateIfcJunctionBoxType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcJunctionBoxType(IfcJunctionBoxType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcJunctionBoxType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcJunctionBoxType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcJunctionBoxType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcJunctionBoxType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcJunctionBoxType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcJunctionBoxType > ExpressDataSet::createIfcJunctionBoxType(bool isVolatile) {
    if (isVolatile) {
        return new IfcJunctionBoxType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcJunctionBoxType * > (allocateIfcJunctionBoxType(this, Step::Id_UNSET));
    }
}

IfcJunctionBoxType *ExpressDataSet::cloneIfcJunctionBoxType(ExpressDataSet *expressDataSet, const IfcJunctionBoxType &obj, const CopyOp &copyop) {
    IfcJunctionBoxType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcJunctionBoxType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcJunctionBoxType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcJunctionBoxType *ExpressDataSet::cloneIfcJunctionBoxType(const IfcJunctionBoxType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcJunctionBoxType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcJunctionBoxType(this, obj, copyop);
    }
}

IfcLShapeProfileDef *ExpressDataSet::getIfcLShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLShapeProfileDef * > (current->second.get());
    }
    else {
        IfcLShapeProfileDef *ret = static_cast< IfcLShapeProfileDef * > (allocateIfcLShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLShapeProfileDef(IfcLShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLShapeProfileDef > ExpressDataSet::createIfcLShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcLShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLShapeProfileDef * > (allocateIfcLShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcLShapeProfileDef *ExpressDataSet::cloneIfcLShapeProfileDef(ExpressDataSet *expressDataSet, const IfcLShapeProfileDef &obj, const CopyOp &copyop) {
    IfcLShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLShapeProfileDef *ExpressDataSet::cloneIfcLShapeProfileDef(const IfcLShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLShapeProfileDef(this, obj, copyop);
    }
}

IfcLaborResource *ExpressDataSet::getIfcLaborResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLaborResource * > (current->second.get());
    }
    else {
        IfcLaborResource *ret = static_cast< IfcLaborResource * > (allocateIfcLaborResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLaborResource(IfcLaborResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLaborResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLaborResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLaborResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLaborResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLaborResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLaborResource > ExpressDataSet::createIfcLaborResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcLaborResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLaborResource * > (allocateIfcLaborResource(this, Step::Id_UNSET));
    }
}

IfcLaborResource *ExpressDataSet::cloneIfcLaborResource(ExpressDataSet *expressDataSet, const IfcLaborResource &obj, const CopyOp &copyop) {
    IfcLaborResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLaborResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLaborResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLaborResource *ExpressDataSet::cloneIfcLaborResource(const IfcLaborResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLaborResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLaborResource(this, obj, copyop);
    }
}

IfcLampType *ExpressDataSet::getIfcLampType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLampType * > (current->second.get());
    }
    else {
        IfcLampType *ret = static_cast< IfcLampType * > (allocateIfcLampType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLampType(IfcLampType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLampType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLampType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLampType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLampType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLampType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLampType > ExpressDataSet::createIfcLampType(bool isVolatile) {
    if (isVolatile) {
        return new IfcLampType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLampType * > (allocateIfcLampType(this, Step::Id_UNSET));
    }
}

IfcLampType *ExpressDataSet::cloneIfcLampType(ExpressDataSet *expressDataSet, const IfcLampType &obj, const CopyOp &copyop) {
    IfcLampType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLampType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLampType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLampType *ExpressDataSet::cloneIfcLampType(const IfcLampType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLampType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLampType(this, obj, copyop);
    }
}

IfcLibraryInformation *ExpressDataSet::getIfcLibraryInformation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLibraryInformation * > (current->second.get());
    }
    else {
        IfcLibraryInformation *ret = static_cast< IfcLibraryInformation * > (allocateIfcLibraryInformation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLibraryInformation(IfcLibraryInformation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLibraryInformation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLibraryInformation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLibraryInformation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLibraryInformation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLibraryInformation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLibraryInformation > ExpressDataSet::createIfcLibraryInformation(bool isVolatile) {
    if (isVolatile) {
        return new IfcLibraryInformation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLibraryInformation * > (allocateIfcLibraryInformation(this, Step::Id_UNSET));
    }
}

IfcLibraryInformation *ExpressDataSet::cloneIfcLibraryInformation(ExpressDataSet *expressDataSet, const IfcLibraryInformation &obj, const CopyOp &copyop) {
    IfcLibraryInformation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLibraryInformation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLibraryInformation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLibraryInformation *ExpressDataSet::cloneIfcLibraryInformation(const IfcLibraryInformation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLibraryInformation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLibraryInformation(this, obj, copyop);
    }
}

IfcLibraryReference *ExpressDataSet::getIfcLibraryReference(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLibraryReference * > (current->second.get());
    }
    else {
        IfcLibraryReference *ret = static_cast< IfcLibraryReference * > (allocateIfcLibraryReference(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLibraryReference(IfcLibraryReference *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLibraryReference_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLibraryReference(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLibraryReference *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLibraryReference(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLibraryReference_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLibraryReference > ExpressDataSet::createIfcLibraryReference(bool isVolatile) {
    if (isVolatile) {
        return new IfcLibraryReference(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLibraryReference * > (allocateIfcLibraryReference(this, Step::Id_UNSET));
    }
}

IfcLibraryReference *ExpressDataSet::cloneIfcLibraryReference(ExpressDataSet *expressDataSet, const IfcLibraryReference &obj, const CopyOp &copyop) {
    IfcLibraryReference *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLibraryReference(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLibraryReference_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLibraryReference *ExpressDataSet::cloneIfcLibraryReference(const IfcLibraryReference &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLibraryReference(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLibraryReference(this, obj, copyop);
    }
}

IfcLightDistributionData *ExpressDataSet::getIfcLightDistributionData(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightDistributionData * > (current->second.get());
    }
    else {
        IfcLightDistributionData *ret = static_cast< IfcLightDistributionData * > (allocateIfcLightDistributionData(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightDistributionData(IfcLightDistributionData *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightDistributionData_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightDistributionData(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightDistributionData *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightDistributionData(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightDistributionData_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightDistributionData > ExpressDataSet::createIfcLightDistributionData(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightDistributionData(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightDistributionData * > (allocateIfcLightDistributionData(this, Step::Id_UNSET));
    }
}

IfcLightDistributionData *ExpressDataSet::cloneIfcLightDistributionData(ExpressDataSet *expressDataSet, const IfcLightDistributionData &obj, const CopyOp &copyop) {
    IfcLightDistributionData *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightDistributionData(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightDistributionData_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightDistributionData *ExpressDataSet::cloneIfcLightDistributionData(const IfcLightDistributionData &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightDistributionData(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightDistributionData(this, obj, copyop);
    }
}

IfcLightFixtureType *ExpressDataSet::getIfcLightFixtureType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightFixtureType * > (current->second.get());
    }
    else {
        IfcLightFixtureType *ret = static_cast< IfcLightFixtureType * > (allocateIfcLightFixtureType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightFixtureType(IfcLightFixtureType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightFixtureType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightFixtureType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightFixtureType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightFixtureType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightFixtureType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightFixtureType > ExpressDataSet::createIfcLightFixtureType(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightFixtureType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightFixtureType * > (allocateIfcLightFixtureType(this, Step::Id_UNSET));
    }
}

IfcLightFixtureType *ExpressDataSet::cloneIfcLightFixtureType(ExpressDataSet *expressDataSet, const IfcLightFixtureType &obj, const CopyOp &copyop) {
    IfcLightFixtureType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightFixtureType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightFixtureType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightFixtureType *ExpressDataSet::cloneIfcLightFixtureType(const IfcLightFixtureType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightFixtureType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightFixtureType(this, obj, copyop);
    }
}

IfcLightIntensityDistribution *ExpressDataSet::getIfcLightIntensityDistribution(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightIntensityDistribution * > (current->second.get());
    }
    else {
        IfcLightIntensityDistribution *ret = static_cast< IfcLightIntensityDistribution * > (allocateIfcLightIntensityDistribution(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightIntensityDistribution(IfcLightIntensityDistribution *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightIntensityDistribution_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightIntensityDistribution(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightIntensityDistribution *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightIntensityDistribution(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightIntensityDistribution_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightIntensityDistribution > ExpressDataSet::createIfcLightIntensityDistribution(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightIntensityDistribution(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightIntensityDistribution * > (allocateIfcLightIntensityDistribution(this, Step::Id_UNSET));
    }
}

IfcLightIntensityDistribution *ExpressDataSet::cloneIfcLightIntensityDistribution(ExpressDataSet *expressDataSet, const IfcLightIntensityDistribution &obj, const CopyOp &copyop) {
    IfcLightIntensityDistribution *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightIntensityDistribution(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightIntensityDistribution_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightIntensityDistribution *ExpressDataSet::cloneIfcLightIntensityDistribution(const IfcLightIntensityDistribution &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightIntensityDistribution(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightIntensityDistribution(this, obj, copyop);
    }
}

IfcLightSourceAmbient *ExpressDataSet::getIfcLightSourceAmbient(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightSourceAmbient * > (current->second.get());
    }
    else {
        IfcLightSourceAmbient *ret = static_cast< IfcLightSourceAmbient * > (allocateIfcLightSourceAmbient(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightSourceAmbient(IfcLightSourceAmbient *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightSourceAmbient_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceAmbient(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightSourceAmbient *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceAmbient(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceAmbient_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceAmbient > ExpressDataSet::createIfcLightSourceAmbient(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightSourceAmbient(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightSourceAmbient * > (allocateIfcLightSourceAmbient(this, Step::Id_UNSET));
    }
}

IfcLightSourceAmbient *ExpressDataSet::cloneIfcLightSourceAmbient(ExpressDataSet *expressDataSet, const IfcLightSourceAmbient &obj, const CopyOp &copyop) {
    IfcLightSourceAmbient *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceAmbient(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceAmbient_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceAmbient *ExpressDataSet::cloneIfcLightSourceAmbient(const IfcLightSourceAmbient &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightSourceAmbient(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightSourceAmbient(this, obj, copyop);
    }
}

IfcLightSourceDirectional *ExpressDataSet::getIfcLightSourceDirectional(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightSourceDirectional * > (current->second.get());
    }
    else {
        IfcLightSourceDirectional *ret = static_cast< IfcLightSourceDirectional * > (allocateIfcLightSourceDirectional(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightSourceDirectional(IfcLightSourceDirectional *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightSourceDirectional_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceDirectional(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightSourceDirectional *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceDirectional(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceDirectional_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceDirectional > ExpressDataSet::createIfcLightSourceDirectional(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightSourceDirectional(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightSourceDirectional * > (allocateIfcLightSourceDirectional(this, Step::Id_UNSET));
    }
}

IfcLightSourceDirectional *ExpressDataSet::cloneIfcLightSourceDirectional(ExpressDataSet *expressDataSet, const IfcLightSourceDirectional &obj, const CopyOp &copyop) {
    IfcLightSourceDirectional *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceDirectional(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceDirectional_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceDirectional *ExpressDataSet::cloneIfcLightSourceDirectional(const IfcLightSourceDirectional &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightSourceDirectional(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightSourceDirectional(this, obj, copyop);
    }
}

IfcLightSourceGoniometric *ExpressDataSet::getIfcLightSourceGoniometric(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightSourceGoniometric * > (current->second.get());
    }
    else {
        IfcLightSourceGoniometric *ret = static_cast< IfcLightSourceGoniometric * > (allocateIfcLightSourceGoniometric(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightSourceGoniometric(IfcLightSourceGoniometric *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightSourceGoniometric_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceGoniometric(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightSourceGoniometric *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceGoniometric(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceGoniometric_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceGoniometric > ExpressDataSet::createIfcLightSourceGoniometric(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightSourceGoniometric(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightSourceGoniometric * > (allocateIfcLightSourceGoniometric(this, Step::Id_UNSET));
    }
}

IfcLightSourceGoniometric *ExpressDataSet::cloneIfcLightSourceGoniometric(ExpressDataSet *expressDataSet, const IfcLightSourceGoniometric &obj, const CopyOp &copyop) {
    IfcLightSourceGoniometric *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceGoniometric(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceGoniometric_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceGoniometric *ExpressDataSet::cloneIfcLightSourceGoniometric(const IfcLightSourceGoniometric &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightSourceGoniometric(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightSourceGoniometric(this, obj, copyop);
    }
}

IfcLightSourcePositional *ExpressDataSet::getIfcLightSourcePositional(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightSourcePositional * > (current->second.get());
    }
    else {
        IfcLightSourcePositional *ret = static_cast< IfcLightSourcePositional * > (allocateIfcLightSourcePositional(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightSourcePositional(IfcLightSourcePositional *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightSourcePositional_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourcePositional(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightSourcePositional *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourcePositional(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourcePositional_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourcePositional > ExpressDataSet::createIfcLightSourcePositional(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightSourcePositional(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightSourcePositional * > (allocateIfcLightSourcePositional(this, Step::Id_UNSET));
    }
}

IfcLightSourcePositional *ExpressDataSet::cloneIfcLightSourcePositional(ExpressDataSet *expressDataSet, const IfcLightSourcePositional &obj, const CopyOp &copyop) {
    IfcLightSourcePositional *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourcePositional(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourcePositional_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourcePositional *ExpressDataSet::cloneIfcLightSourcePositional(const IfcLightSourcePositional &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightSourcePositional(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightSourcePositional(this, obj, copyop);
    }
}

IfcLightSourceSpot *ExpressDataSet::getIfcLightSourceSpot(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLightSourceSpot * > (current->second.get());
    }
    else {
        IfcLightSourceSpot *ret = static_cast< IfcLightSourceSpot * > (allocateIfcLightSourceSpot(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLightSourceSpot(IfcLightSourceSpot *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLightSourceSpot_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLightSourceSpot(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLightSourceSpot *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLightSourceSpot(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLightSourceSpot_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLightSourceSpot > ExpressDataSet::createIfcLightSourceSpot(bool isVolatile) {
    if (isVolatile) {
        return new IfcLightSourceSpot(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLightSourceSpot * > (allocateIfcLightSourceSpot(this, Step::Id_UNSET));
    }
}

IfcLightSourceSpot *ExpressDataSet::cloneIfcLightSourceSpot(ExpressDataSet *expressDataSet, const IfcLightSourceSpot &obj, const CopyOp &copyop) {
    IfcLightSourceSpot *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLightSourceSpot(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLightSourceSpot_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLightSourceSpot *ExpressDataSet::cloneIfcLightSourceSpot(const IfcLightSourceSpot &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLightSourceSpot(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLightSourceSpot(this, obj, copyop);
    }
}

IfcLine *ExpressDataSet::getIfcLine(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLine * > (current->second.get());
    }
    else {
        IfcLine *ret = static_cast< IfcLine * > (allocateIfcLine(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLine(IfcLine *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLine_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLine(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLine *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLine(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLine_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLine > ExpressDataSet::createIfcLine(bool isVolatile) {
    if (isVolatile) {
        return new IfcLine(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLine * > (allocateIfcLine(this, Step::Id_UNSET));
    }
}

IfcLine *ExpressDataSet::cloneIfcLine(ExpressDataSet *expressDataSet, const IfcLine &obj, const CopyOp &copyop) {
    IfcLine *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLine(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLine_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLine *ExpressDataSet::cloneIfcLine(const IfcLine &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLine(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLine(this, obj, copyop);
    }
}

IfcLinearDimension *ExpressDataSet::getIfcLinearDimension(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLinearDimension * > (current->second.get());
    }
    else {
        IfcLinearDimension *ret = static_cast< IfcLinearDimension * > (allocateIfcLinearDimension(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLinearDimension(IfcLinearDimension *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLinearDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLinearDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLinearDimension *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLinearDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLinearDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLinearDimension > ExpressDataSet::createIfcLinearDimension(bool isVolatile) {
    if (isVolatile) {
        return new IfcLinearDimension(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLinearDimension * > (allocateIfcLinearDimension(this, Step::Id_UNSET));
    }
}

IfcLinearDimension *ExpressDataSet::cloneIfcLinearDimension(ExpressDataSet *expressDataSet, const IfcLinearDimension &obj, const CopyOp &copyop) {
    IfcLinearDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLinearDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLinearDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLinearDimension *ExpressDataSet::cloneIfcLinearDimension(const IfcLinearDimension &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLinearDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLinearDimension(this, obj, copyop);
    }
}

IfcLocalPlacement *ExpressDataSet::getIfcLocalPlacement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLocalPlacement * > (current->second.get());
    }
    else {
        IfcLocalPlacement *ret = static_cast< IfcLocalPlacement * > (allocateIfcLocalPlacement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLocalPlacement(IfcLocalPlacement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLocalPlacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLocalPlacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLocalPlacement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLocalPlacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLocalPlacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLocalPlacement > ExpressDataSet::createIfcLocalPlacement(bool isVolatile) {
    if (isVolatile) {
        return new IfcLocalPlacement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLocalPlacement * > (allocateIfcLocalPlacement(this, Step::Id_UNSET));
    }
}

IfcLocalPlacement *ExpressDataSet::cloneIfcLocalPlacement(ExpressDataSet *expressDataSet, const IfcLocalPlacement &obj, const CopyOp &copyop) {
    IfcLocalPlacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLocalPlacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLocalPlacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLocalPlacement *ExpressDataSet::cloneIfcLocalPlacement(const IfcLocalPlacement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLocalPlacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLocalPlacement(this, obj, copyop);
    }
}

IfcLocalTime *ExpressDataSet::getIfcLocalTime(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLocalTime * > (current->second.get());
    }
    else {
        IfcLocalTime *ret = static_cast< IfcLocalTime * > (allocateIfcLocalTime(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLocalTime(IfcLocalTime *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLocalTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLocalTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLocalTime *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLocalTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLocalTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLocalTime > ExpressDataSet::createIfcLocalTime(bool isVolatile) {
    if (isVolatile) {
        return new IfcLocalTime(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLocalTime * > (allocateIfcLocalTime(this, Step::Id_UNSET));
    }
}

IfcLocalTime *ExpressDataSet::cloneIfcLocalTime(ExpressDataSet *expressDataSet, const IfcLocalTime &obj, const CopyOp &copyop) {
    IfcLocalTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLocalTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLocalTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLocalTime *ExpressDataSet::cloneIfcLocalTime(const IfcLocalTime &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLocalTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLocalTime(this, obj, copyop);
    }
}

IfcLoop *ExpressDataSet::getIfcLoop(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcLoop * > (current->second.get());
    }
    else {
        IfcLoop *ret = static_cast< IfcLoop * > (allocateIfcLoop(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcLoop(IfcLoop *arg) {
    getAll().erase(arg->getKey());
    return m_IfcLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcLoop *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcLoop > ExpressDataSet::createIfcLoop(bool isVolatile) {
    if (isVolatile) {
        return new IfcLoop(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcLoop * > (allocateIfcLoop(this, Step::Id_UNSET));
    }
}

IfcLoop *ExpressDataSet::cloneIfcLoop(ExpressDataSet *expressDataSet, const IfcLoop &obj, const CopyOp &copyop) {
    IfcLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcLoop *ExpressDataSet::cloneIfcLoop(const IfcLoop &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcLoop(this, obj, copyop);
    }
}

IfcMappedItem *ExpressDataSet::getIfcMappedItem(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMappedItem * > (current->second.get());
    }
    else {
        IfcMappedItem *ret = static_cast< IfcMappedItem * > (allocateIfcMappedItem(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMappedItem(IfcMappedItem *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMappedItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMappedItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMappedItem *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMappedItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMappedItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMappedItem > ExpressDataSet::createIfcMappedItem(bool isVolatile) {
    if (isVolatile) {
        return new IfcMappedItem(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMappedItem * > (allocateIfcMappedItem(this, Step::Id_UNSET));
    }
}

IfcMappedItem *ExpressDataSet::cloneIfcMappedItem(ExpressDataSet *expressDataSet, const IfcMappedItem &obj, const CopyOp &copyop) {
    IfcMappedItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMappedItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMappedItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMappedItem *ExpressDataSet::cloneIfcMappedItem(const IfcMappedItem &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMappedItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMappedItem(this, obj, copyop);
    }
}

IfcMaterial *ExpressDataSet::getIfcMaterial(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterial * > (current->second.get());
    }
    else {
        IfcMaterial *ret = static_cast< IfcMaterial * > (allocateIfcMaterial(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterial(IfcMaterial *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterial_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterial(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterial *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterial(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterial_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterial > ExpressDataSet::createIfcMaterial(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterial(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterial * > (allocateIfcMaterial(this, Step::Id_UNSET));
    }
}

IfcMaterial *ExpressDataSet::cloneIfcMaterial(ExpressDataSet *expressDataSet, const IfcMaterial &obj, const CopyOp &copyop) {
    IfcMaterial *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterial(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterial_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterial *ExpressDataSet::cloneIfcMaterial(const IfcMaterial &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterial(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterial(this, obj, copyop);
    }
}

IfcMaterialClassificationRelationship *ExpressDataSet::getIfcMaterialClassificationRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialClassificationRelationship * > (current->second.get());
    }
    else {
        IfcMaterialClassificationRelationship *ret = static_cast< IfcMaterialClassificationRelationship * > (allocateIfcMaterialClassificationRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialClassificationRelationship(IfcMaterialClassificationRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialClassificationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialClassificationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialClassificationRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialClassificationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialClassificationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialClassificationRelationship > ExpressDataSet::createIfcMaterialClassificationRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialClassificationRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialClassificationRelationship * > (allocateIfcMaterialClassificationRelationship(this, Step::Id_UNSET));
    }
}

IfcMaterialClassificationRelationship *ExpressDataSet::cloneIfcMaterialClassificationRelationship(ExpressDataSet *expressDataSet, const IfcMaterialClassificationRelationship &obj, const CopyOp &copyop) {
    IfcMaterialClassificationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialClassificationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialClassificationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialClassificationRelationship *ExpressDataSet::cloneIfcMaterialClassificationRelationship(const IfcMaterialClassificationRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialClassificationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialClassificationRelationship(this, obj, copyop);
    }
}

IfcMaterialDefinitionRepresentation *ExpressDataSet::getIfcMaterialDefinitionRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialDefinitionRepresentation * > (current->second.get());
    }
    else {
        IfcMaterialDefinitionRepresentation *ret = static_cast< IfcMaterialDefinitionRepresentation * > (allocateIfcMaterialDefinitionRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialDefinitionRepresentation(IfcMaterialDefinitionRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialDefinitionRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialDefinitionRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialDefinitionRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialDefinitionRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialDefinitionRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialDefinitionRepresentation > ExpressDataSet::createIfcMaterialDefinitionRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialDefinitionRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialDefinitionRepresentation * > (allocateIfcMaterialDefinitionRepresentation(this, Step::Id_UNSET));
    }
}

IfcMaterialDefinitionRepresentation *ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(ExpressDataSet *expressDataSet, const IfcMaterialDefinitionRepresentation &obj, const CopyOp &copyop) {
    IfcMaterialDefinitionRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialDefinitionRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialDefinitionRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialDefinitionRepresentation *ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(const IfcMaterialDefinitionRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialDefinitionRepresentation(this, obj, copyop);
    }
}

IfcMaterialLayer *ExpressDataSet::getIfcMaterialLayer(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialLayer * > (current->second.get());
    }
    else {
        IfcMaterialLayer *ret = static_cast< IfcMaterialLayer * > (allocateIfcMaterialLayer(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialLayer(IfcMaterialLayer *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayer_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayer(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialLayer *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayer(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayer_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayer > ExpressDataSet::createIfcMaterialLayer(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialLayer(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialLayer * > (allocateIfcMaterialLayer(this, Step::Id_UNSET));
    }
}

IfcMaterialLayer *ExpressDataSet::cloneIfcMaterialLayer(ExpressDataSet *expressDataSet, const IfcMaterialLayer &obj, const CopyOp &copyop) {
    IfcMaterialLayer *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayer(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayer_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayer *ExpressDataSet::cloneIfcMaterialLayer(const IfcMaterialLayer &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialLayer(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialLayer(this, obj, copyop);
    }
}

IfcMaterialLayerSet *ExpressDataSet::getIfcMaterialLayerSet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialLayerSet * > (current->second.get());
    }
    else {
        IfcMaterialLayerSet *ret = static_cast< IfcMaterialLayerSet * > (allocateIfcMaterialLayerSet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialLayerSet(IfcMaterialLayerSet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayerSet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayerSet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialLayerSet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayerSet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayerSet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayerSet > ExpressDataSet::createIfcMaterialLayerSet(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialLayerSet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialLayerSet * > (allocateIfcMaterialLayerSet(this, Step::Id_UNSET));
    }
}

IfcMaterialLayerSet *ExpressDataSet::cloneIfcMaterialLayerSet(ExpressDataSet *expressDataSet, const IfcMaterialLayerSet &obj, const CopyOp &copyop) {
    IfcMaterialLayerSet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayerSet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayerSet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayerSet *ExpressDataSet::cloneIfcMaterialLayerSet(const IfcMaterialLayerSet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialLayerSet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialLayerSet(this, obj, copyop);
    }
}

IfcMaterialLayerSetUsage *ExpressDataSet::getIfcMaterialLayerSetUsage(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialLayerSetUsage * > (current->second.get());
    }
    else {
        IfcMaterialLayerSetUsage *ret = static_cast< IfcMaterialLayerSetUsage * > (allocateIfcMaterialLayerSetUsage(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialLayerSetUsage(IfcMaterialLayerSetUsage *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialLayerSetUsage_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialLayerSetUsage(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialLayerSetUsage *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialLayerSetUsage(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialLayerSetUsage_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialLayerSetUsage > ExpressDataSet::createIfcMaterialLayerSetUsage(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialLayerSetUsage(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialLayerSetUsage * > (allocateIfcMaterialLayerSetUsage(this, Step::Id_UNSET));
    }
}

IfcMaterialLayerSetUsage *ExpressDataSet::cloneIfcMaterialLayerSetUsage(ExpressDataSet *expressDataSet, const IfcMaterialLayerSetUsage &obj, const CopyOp &copyop) {
    IfcMaterialLayerSetUsage *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialLayerSetUsage(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialLayerSetUsage_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialLayerSetUsage *ExpressDataSet::cloneIfcMaterialLayerSetUsage(const IfcMaterialLayerSetUsage &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialLayerSetUsage(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialLayerSetUsage(this, obj, copyop);
    }
}

IfcMaterialList *ExpressDataSet::getIfcMaterialList(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMaterialList * > (current->second.get());
    }
    else {
        IfcMaterialList *ret = static_cast< IfcMaterialList * > (allocateIfcMaterialList(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMaterialList(IfcMaterialList *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMaterialList_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMaterialList(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMaterialList *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMaterialList(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMaterialList_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMaterialList > ExpressDataSet::createIfcMaterialList(bool isVolatile) {
    if (isVolatile) {
        return new IfcMaterialList(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMaterialList * > (allocateIfcMaterialList(this, Step::Id_UNSET));
    }
}

IfcMaterialList *ExpressDataSet::cloneIfcMaterialList(ExpressDataSet *expressDataSet, const IfcMaterialList &obj, const CopyOp &copyop) {
    IfcMaterialList *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMaterialList(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMaterialList_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMaterialList *ExpressDataSet::cloneIfcMaterialList(const IfcMaterialList &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMaterialList(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMaterialList(this, obj, copyop);
    }
}

IfcMeasureWithUnit *ExpressDataSet::getIfcMeasureWithUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMeasureWithUnit * > (current->second.get());
    }
    else {
        IfcMeasureWithUnit *ret = static_cast< IfcMeasureWithUnit * > (allocateIfcMeasureWithUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMeasureWithUnit(IfcMeasureWithUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMeasureWithUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMeasureWithUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMeasureWithUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMeasureWithUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMeasureWithUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMeasureWithUnit > ExpressDataSet::createIfcMeasureWithUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcMeasureWithUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMeasureWithUnit * > (allocateIfcMeasureWithUnit(this, Step::Id_UNSET));
    }
}

IfcMeasureWithUnit *ExpressDataSet::cloneIfcMeasureWithUnit(ExpressDataSet *expressDataSet, const IfcMeasureWithUnit &obj, const CopyOp &copyop) {
    IfcMeasureWithUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMeasureWithUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMeasureWithUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMeasureWithUnit *ExpressDataSet::cloneIfcMeasureWithUnit(const IfcMeasureWithUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMeasureWithUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMeasureWithUnit(this, obj, copyop);
    }
}

IfcMechanicalConcreteMaterialProperties *ExpressDataSet::getIfcMechanicalConcreteMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMechanicalConcreteMaterialProperties * > (current->second.get());
    }
    else {
        IfcMechanicalConcreteMaterialProperties *ret = static_cast< IfcMechanicalConcreteMaterialProperties * > (allocateIfcMechanicalConcreteMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMechanicalConcreteMaterialProperties(IfcMechanicalConcreteMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMechanicalConcreteMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalConcreteMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMechanicalConcreteMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalConcreteMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalConcreteMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalConcreteMaterialProperties > ExpressDataSet::createIfcMechanicalConcreteMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcMechanicalConcreteMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMechanicalConcreteMaterialProperties * > (allocateIfcMechanicalConcreteMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalConcreteMaterialProperties *ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalConcreteMaterialProperties &obj, const CopyOp &copyop) {
    IfcMechanicalConcreteMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalConcreteMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalConcreteMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalConcreteMaterialProperties *ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(const IfcMechanicalConcreteMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMechanicalConcreteMaterialProperties(this, obj, copyop);
    }
}

IfcMechanicalFastener *ExpressDataSet::getIfcMechanicalFastener(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMechanicalFastener * > (current->second.get());
    }
    else {
        IfcMechanicalFastener *ret = static_cast< IfcMechanicalFastener * > (allocateIfcMechanicalFastener(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMechanicalFastener(IfcMechanicalFastener *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMechanicalFastener_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalFastener(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMechanicalFastener *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalFastener(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalFastener_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalFastener > ExpressDataSet::createIfcMechanicalFastener(bool isVolatile) {
    if (isVolatile) {
        return new IfcMechanicalFastener(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMechanicalFastener * > (allocateIfcMechanicalFastener(this, Step::Id_UNSET));
    }
}

IfcMechanicalFastener *ExpressDataSet::cloneIfcMechanicalFastener(ExpressDataSet *expressDataSet, const IfcMechanicalFastener &obj, const CopyOp &copyop) {
    IfcMechanicalFastener *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalFastener(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalFastener_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalFastener *ExpressDataSet::cloneIfcMechanicalFastener(const IfcMechanicalFastener &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMechanicalFastener(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMechanicalFastener(this, obj, copyop);
    }
}

IfcMechanicalFastenerType *ExpressDataSet::getIfcMechanicalFastenerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMechanicalFastenerType * > (current->second.get());
    }
    else {
        IfcMechanicalFastenerType *ret = static_cast< IfcMechanicalFastenerType * > (allocateIfcMechanicalFastenerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMechanicalFastenerType(IfcMechanicalFastenerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMechanicalFastenerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalFastenerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMechanicalFastenerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalFastenerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalFastenerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalFastenerType > ExpressDataSet::createIfcMechanicalFastenerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcMechanicalFastenerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMechanicalFastenerType * > (allocateIfcMechanicalFastenerType(this, Step::Id_UNSET));
    }
}

IfcMechanicalFastenerType *ExpressDataSet::cloneIfcMechanicalFastenerType(ExpressDataSet *expressDataSet, const IfcMechanicalFastenerType &obj, const CopyOp &copyop) {
    IfcMechanicalFastenerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalFastenerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalFastenerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalFastenerType *ExpressDataSet::cloneIfcMechanicalFastenerType(const IfcMechanicalFastenerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMechanicalFastenerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMechanicalFastenerType(this, obj, copyop);
    }
}

IfcMechanicalMaterialProperties *ExpressDataSet::getIfcMechanicalMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMechanicalMaterialProperties * > (current->second.get());
    }
    else {
        IfcMechanicalMaterialProperties *ret = static_cast< IfcMechanicalMaterialProperties * > (allocateIfcMechanicalMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMechanicalMaterialProperties(IfcMechanicalMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMechanicalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMechanicalMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalMaterialProperties > ExpressDataSet::createIfcMechanicalMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcMechanicalMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMechanicalMaterialProperties * > (allocateIfcMechanicalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalMaterialProperties *ExpressDataSet::cloneIfcMechanicalMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalMaterialProperties &obj, const CopyOp &copyop) {
    IfcMechanicalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalMaterialProperties *ExpressDataSet::cloneIfcMechanicalMaterialProperties(const IfcMechanicalMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMechanicalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMechanicalMaterialProperties(this, obj, copyop);
    }
}

IfcMechanicalSteelMaterialProperties *ExpressDataSet::getIfcMechanicalSteelMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMechanicalSteelMaterialProperties * > (current->second.get());
    }
    else {
        IfcMechanicalSteelMaterialProperties *ret = static_cast< IfcMechanicalSteelMaterialProperties * > (allocateIfcMechanicalSteelMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMechanicalSteelMaterialProperties(IfcMechanicalSteelMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMechanicalSteelMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMechanicalSteelMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMechanicalSteelMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMechanicalSteelMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMechanicalSteelMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMechanicalSteelMaterialProperties > ExpressDataSet::createIfcMechanicalSteelMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcMechanicalSteelMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMechanicalSteelMaterialProperties * > (allocateIfcMechanicalSteelMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcMechanicalSteelMaterialProperties *ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(ExpressDataSet *expressDataSet, const IfcMechanicalSteelMaterialProperties &obj, const CopyOp &copyop) {
    IfcMechanicalSteelMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMechanicalSteelMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMechanicalSteelMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMechanicalSteelMaterialProperties *ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(const IfcMechanicalSteelMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMechanicalSteelMaterialProperties(this, obj, copyop);
    }
}

IfcMember *ExpressDataSet::getIfcMember(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMember * > (current->second.get());
    }
    else {
        IfcMember *ret = static_cast< IfcMember * > (allocateIfcMember(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMember(IfcMember *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMember *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMember > ExpressDataSet::createIfcMember(bool isVolatile) {
    if (isVolatile) {
        return new IfcMember(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMember * > (allocateIfcMember(this, Step::Id_UNSET));
    }
}

IfcMember *ExpressDataSet::cloneIfcMember(ExpressDataSet *expressDataSet, const IfcMember &obj, const CopyOp &copyop) {
    IfcMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMember *ExpressDataSet::cloneIfcMember(const IfcMember &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMember(this, obj, copyop);
    }
}

IfcMemberType *ExpressDataSet::getIfcMemberType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMemberType * > (current->second.get());
    }
    else {
        IfcMemberType *ret = static_cast< IfcMemberType * > (allocateIfcMemberType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMemberType(IfcMemberType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMemberType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMemberType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMemberType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMemberType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMemberType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMemberType > ExpressDataSet::createIfcMemberType(bool isVolatile) {
    if (isVolatile) {
        return new IfcMemberType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMemberType * > (allocateIfcMemberType(this, Step::Id_UNSET));
    }
}

IfcMemberType *ExpressDataSet::cloneIfcMemberType(ExpressDataSet *expressDataSet, const IfcMemberType &obj, const CopyOp &copyop) {
    IfcMemberType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMemberType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMemberType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMemberType *ExpressDataSet::cloneIfcMemberType(const IfcMemberType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMemberType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMemberType(this, obj, copyop);
    }
}

IfcMetric *ExpressDataSet::getIfcMetric(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMetric * > (current->second.get());
    }
    else {
        IfcMetric *ret = static_cast< IfcMetric * > (allocateIfcMetric(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMetric(IfcMetric *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMetric_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMetric(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMetric *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMetric(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMetric_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMetric > ExpressDataSet::createIfcMetric(bool isVolatile) {
    if (isVolatile) {
        return new IfcMetric(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMetric * > (allocateIfcMetric(this, Step::Id_UNSET));
    }
}

IfcMetric *ExpressDataSet::cloneIfcMetric(ExpressDataSet *expressDataSet, const IfcMetric &obj, const CopyOp &copyop) {
    IfcMetric *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMetric(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMetric_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMetric *ExpressDataSet::cloneIfcMetric(const IfcMetric &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMetric(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMetric(this, obj, copyop);
    }
}

IfcMonetaryUnit *ExpressDataSet::getIfcMonetaryUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMonetaryUnit * > (current->second.get());
    }
    else {
        IfcMonetaryUnit *ret = static_cast< IfcMonetaryUnit * > (allocateIfcMonetaryUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMonetaryUnit(IfcMonetaryUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMonetaryUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMonetaryUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMonetaryUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMonetaryUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMonetaryUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMonetaryUnit > ExpressDataSet::createIfcMonetaryUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcMonetaryUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMonetaryUnit * > (allocateIfcMonetaryUnit(this, Step::Id_UNSET));
    }
}

IfcMonetaryUnit *ExpressDataSet::cloneIfcMonetaryUnit(ExpressDataSet *expressDataSet, const IfcMonetaryUnit &obj, const CopyOp &copyop) {
    IfcMonetaryUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMonetaryUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMonetaryUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMonetaryUnit *ExpressDataSet::cloneIfcMonetaryUnit(const IfcMonetaryUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMonetaryUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMonetaryUnit(this, obj, copyop);
    }
}

IfcMotorConnectionType *ExpressDataSet::getIfcMotorConnectionType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMotorConnectionType * > (current->second.get());
    }
    else {
        IfcMotorConnectionType *ret = static_cast< IfcMotorConnectionType * > (allocateIfcMotorConnectionType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMotorConnectionType(IfcMotorConnectionType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMotorConnectionType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMotorConnectionType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMotorConnectionType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMotorConnectionType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMotorConnectionType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMotorConnectionType > ExpressDataSet::createIfcMotorConnectionType(bool isVolatile) {
    if (isVolatile) {
        return new IfcMotorConnectionType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMotorConnectionType * > (allocateIfcMotorConnectionType(this, Step::Id_UNSET));
    }
}

IfcMotorConnectionType *ExpressDataSet::cloneIfcMotorConnectionType(ExpressDataSet *expressDataSet, const IfcMotorConnectionType &obj, const CopyOp &copyop) {
    IfcMotorConnectionType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMotorConnectionType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMotorConnectionType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMotorConnectionType *ExpressDataSet::cloneIfcMotorConnectionType(const IfcMotorConnectionType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMotorConnectionType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMotorConnectionType(this, obj, copyop);
    }
}

IfcMove *ExpressDataSet::getIfcMove(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcMove * > (current->second.get());
    }
    else {
        IfcMove *ret = static_cast< IfcMove * > (allocateIfcMove(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcMove(IfcMove *arg) {
    getAll().erase(arg->getKey());
    return m_IfcMove_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcMove(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcMove *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcMove(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcMove_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcMove > ExpressDataSet::createIfcMove(bool isVolatile) {
    if (isVolatile) {
        return new IfcMove(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcMove * > (allocateIfcMove(this, Step::Id_UNSET));
    }
}

IfcMove *ExpressDataSet::cloneIfcMove(ExpressDataSet *expressDataSet, const IfcMove &obj, const CopyOp &copyop) {
    IfcMove *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcMove(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcMove_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcMove *ExpressDataSet::cloneIfcMove(const IfcMove &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcMove(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcMove(this, obj, copyop);
    }
}

IfcObjective *ExpressDataSet::getIfcObjective(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcObjective * > (current->second.get());
    }
    else {
        IfcObjective *ret = static_cast< IfcObjective * > (allocateIfcObjective(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcObjective(IfcObjective *arg) {
    getAll().erase(arg->getKey());
    return m_IfcObjective_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcObjective(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcObjective *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcObjective(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcObjective_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcObjective > ExpressDataSet::createIfcObjective(bool isVolatile) {
    if (isVolatile) {
        return new IfcObjective(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcObjective * > (allocateIfcObjective(this, Step::Id_UNSET));
    }
}

IfcObjective *ExpressDataSet::cloneIfcObjective(ExpressDataSet *expressDataSet, const IfcObjective &obj, const CopyOp &copyop) {
    IfcObjective *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcObjective(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcObjective_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcObjective *ExpressDataSet::cloneIfcObjective(const IfcObjective &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcObjective(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcObjective(this, obj, copyop);
    }
}

IfcOccupant *ExpressDataSet::getIfcOccupant(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOccupant * > (current->second.get());
    }
    else {
        IfcOccupant *ret = static_cast< IfcOccupant * > (allocateIfcOccupant(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOccupant(IfcOccupant *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOccupant_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOccupant(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOccupant *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOccupant(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOccupant_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOccupant > ExpressDataSet::createIfcOccupant(bool isVolatile) {
    if (isVolatile) {
        return new IfcOccupant(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOccupant * > (allocateIfcOccupant(this, Step::Id_UNSET));
    }
}

IfcOccupant *ExpressDataSet::cloneIfcOccupant(ExpressDataSet *expressDataSet, const IfcOccupant &obj, const CopyOp &copyop) {
    IfcOccupant *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOccupant(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOccupant_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOccupant *ExpressDataSet::cloneIfcOccupant(const IfcOccupant &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOccupant(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOccupant(this, obj, copyop);
    }
}

IfcOffsetCurve2D *ExpressDataSet::getIfcOffsetCurve2D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOffsetCurve2D * > (current->second.get());
    }
    else {
        IfcOffsetCurve2D *ret = static_cast< IfcOffsetCurve2D * > (allocateIfcOffsetCurve2D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOffsetCurve2D(IfcOffsetCurve2D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOffsetCurve2D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOffsetCurve2D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOffsetCurve2D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOffsetCurve2D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOffsetCurve2D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOffsetCurve2D > ExpressDataSet::createIfcOffsetCurve2D(bool isVolatile) {
    if (isVolatile) {
        return new IfcOffsetCurve2D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOffsetCurve2D * > (allocateIfcOffsetCurve2D(this, Step::Id_UNSET));
    }
}

IfcOffsetCurve2D *ExpressDataSet::cloneIfcOffsetCurve2D(ExpressDataSet *expressDataSet, const IfcOffsetCurve2D &obj, const CopyOp &copyop) {
    IfcOffsetCurve2D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOffsetCurve2D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOffsetCurve2D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOffsetCurve2D *ExpressDataSet::cloneIfcOffsetCurve2D(const IfcOffsetCurve2D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOffsetCurve2D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOffsetCurve2D(this, obj, copyop);
    }
}

IfcOffsetCurve3D *ExpressDataSet::getIfcOffsetCurve3D(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOffsetCurve3D * > (current->second.get());
    }
    else {
        IfcOffsetCurve3D *ret = static_cast< IfcOffsetCurve3D * > (allocateIfcOffsetCurve3D(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOffsetCurve3D(IfcOffsetCurve3D *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOffsetCurve3D_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOffsetCurve3D(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOffsetCurve3D *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOffsetCurve3D(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOffsetCurve3D_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOffsetCurve3D > ExpressDataSet::createIfcOffsetCurve3D(bool isVolatile) {
    if (isVolatile) {
        return new IfcOffsetCurve3D(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOffsetCurve3D * > (allocateIfcOffsetCurve3D(this, Step::Id_UNSET));
    }
}

IfcOffsetCurve3D *ExpressDataSet::cloneIfcOffsetCurve3D(ExpressDataSet *expressDataSet, const IfcOffsetCurve3D &obj, const CopyOp &copyop) {
    IfcOffsetCurve3D *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOffsetCurve3D(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOffsetCurve3D_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOffsetCurve3D *ExpressDataSet::cloneIfcOffsetCurve3D(const IfcOffsetCurve3D &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOffsetCurve3D(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOffsetCurve3D(this, obj, copyop);
    }
}

IfcOneDirectionRepeatFactor *ExpressDataSet::getIfcOneDirectionRepeatFactor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOneDirectionRepeatFactor * > (current->second.get());
    }
    else {
        IfcOneDirectionRepeatFactor *ret = static_cast< IfcOneDirectionRepeatFactor * > (allocateIfcOneDirectionRepeatFactor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOneDirectionRepeatFactor(IfcOneDirectionRepeatFactor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOneDirectionRepeatFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOneDirectionRepeatFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOneDirectionRepeatFactor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOneDirectionRepeatFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOneDirectionRepeatFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOneDirectionRepeatFactor > ExpressDataSet::createIfcOneDirectionRepeatFactor(bool isVolatile) {
    if (isVolatile) {
        return new IfcOneDirectionRepeatFactor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOneDirectionRepeatFactor * > (allocateIfcOneDirectionRepeatFactor(this, Step::Id_UNSET));
    }
}

IfcOneDirectionRepeatFactor *ExpressDataSet::cloneIfcOneDirectionRepeatFactor(ExpressDataSet *expressDataSet, const IfcOneDirectionRepeatFactor &obj, const CopyOp &copyop) {
    IfcOneDirectionRepeatFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOneDirectionRepeatFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOneDirectionRepeatFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOneDirectionRepeatFactor *ExpressDataSet::cloneIfcOneDirectionRepeatFactor(const IfcOneDirectionRepeatFactor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOneDirectionRepeatFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOneDirectionRepeatFactor(this, obj, copyop);
    }
}

IfcOpenShell *ExpressDataSet::getIfcOpenShell(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOpenShell * > (current->second.get());
    }
    else {
        IfcOpenShell *ret = static_cast< IfcOpenShell * > (allocateIfcOpenShell(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOpenShell(IfcOpenShell *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOpenShell_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpenShell(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOpenShell *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpenShell(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpenShell_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpenShell > ExpressDataSet::createIfcOpenShell(bool isVolatile) {
    if (isVolatile) {
        return new IfcOpenShell(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOpenShell * > (allocateIfcOpenShell(this, Step::Id_UNSET));
    }
}

IfcOpenShell *ExpressDataSet::cloneIfcOpenShell(ExpressDataSet *expressDataSet, const IfcOpenShell &obj, const CopyOp &copyop) {
    IfcOpenShell *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpenShell(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpenShell_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpenShell *ExpressDataSet::cloneIfcOpenShell(const IfcOpenShell &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOpenShell(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOpenShell(this, obj, copyop);
    }
}

IfcOpeningElement *ExpressDataSet::getIfcOpeningElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOpeningElement * > (current->second.get());
    }
    else {
        IfcOpeningElement *ret = static_cast< IfcOpeningElement * > (allocateIfcOpeningElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOpeningElement(IfcOpeningElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOpeningElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpeningElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOpeningElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpeningElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpeningElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpeningElement > ExpressDataSet::createIfcOpeningElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcOpeningElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOpeningElement * > (allocateIfcOpeningElement(this, Step::Id_UNSET));
    }
}

IfcOpeningElement *ExpressDataSet::cloneIfcOpeningElement(ExpressDataSet *expressDataSet, const IfcOpeningElement &obj, const CopyOp &copyop) {
    IfcOpeningElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpeningElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpeningElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpeningElement *ExpressDataSet::cloneIfcOpeningElement(const IfcOpeningElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOpeningElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOpeningElement(this, obj, copyop);
    }
}

IfcOpticalMaterialProperties *ExpressDataSet::getIfcOpticalMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOpticalMaterialProperties * > (current->second.get());
    }
    else {
        IfcOpticalMaterialProperties *ret = static_cast< IfcOpticalMaterialProperties * > (allocateIfcOpticalMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOpticalMaterialProperties(IfcOpticalMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOpticalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOpticalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOpticalMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOpticalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOpticalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOpticalMaterialProperties > ExpressDataSet::createIfcOpticalMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcOpticalMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOpticalMaterialProperties * > (allocateIfcOpticalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcOpticalMaterialProperties *ExpressDataSet::cloneIfcOpticalMaterialProperties(ExpressDataSet *expressDataSet, const IfcOpticalMaterialProperties &obj, const CopyOp &copyop) {
    IfcOpticalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOpticalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOpticalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOpticalMaterialProperties *ExpressDataSet::cloneIfcOpticalMaterialProperties(const IfcOpticalMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOpticalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOpticalMaterialProperties(this, obj, copyop);
    }
}

IfcOrderAction *ExpressDataSet::getIfcOrderAction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOrderAction * > (current->second.get());
    }
    else {
        IfcOrderAction *ret = static_cast< IfcOrderAction * > (allocateIfcOrderAction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOrderAction(IfcOrderAction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOrderAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrderAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOrderAction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrderAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrderAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrderAction > ExpressDataSet::createIfcOrderAction(bool isVolatile) {
    if (isVolatile) {
        return new IfcOrderAction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOrderAction * > (allocateIfcOrderAction(this, Step::Id_UNSET));
    }
}

IfcOrderAction *ExpressDataSet::cloneIfcOrderAction(ExpressDataSet *expressDataSet, const IfcOrderAction &obj, const CopyOp &copyop) {
    IfcOrderAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrderAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrderAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrderAction *ExpressDataSet::cloneIfcOrderAction(const IfcOrderAction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOrderAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOrderAction(this, obj, copyop);
    }
}

IfcOrganization *ExpressDataSet::getIfcOrganization(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOrganization * > (current->second.get());
    }
    else {
        IfcOrganization *ret = static_cast< IfcOrganization * > (allocateIfcOrganization(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOrganization(IfcOrganization *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOrganization_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrganization(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOrganization *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrganization(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrganization_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrganization > ExpressDataSet::createIfcOrganization(bool isVolatile) {
    if (isVolatile) {
        return new IfcOrganization(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOrganization * > (allocateIfcOrganization(this, Step::Id_UNSET));
    }
}

IfcOrganization *ExpressDataSet::cloneIfcOrganization(ExpressDataSet *expressDataSet, const IfcOrganization &obj, const CopyOp &copyop) {
    IfcOrganization *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrganization(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrganization_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrganization *ExpressDataSet::cloneIfcOrganization(const IfcOrganization &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOrganization(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOrganization(this, obj, copyop);
    }
}

IfcOrganizationRelationship *ExpressDataSet::getIfcOrganizationRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOrganizationRelationship * > (current->second.get());
    }
    else {
        IfcOrganizationRelationship *ret = static_cast< IfcOrganizationRelationship * > (allocateIfcOrganizationRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOrganizationRelationship(IfcOrganizationRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOrganizationRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrganizationRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOrganizationRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrganizationRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrganizationRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrganizationRelationship > ExpressDataSet::createIfcOrganizationRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcOrganizationRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOrganizationRelationship * > (allocateIfcOrganizationRelationship(this, Step::Id_UNSET));
    }
}

IfcOrganizationRelationship *ExpressDataSet::cloneIfcOrganizationRelationship(ExpressDataSet *expressDataSet, const IfcOrganizationRelationship &obj, const CopyOp &copyop) {
    IfcOrganizationRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrganizationRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrganizationRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrganizationRelationship *ExpressDataSet::cloneIfcOrganizationRelationship(const IfcOrganizationRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOrganizationRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOrganizationRelationship(this, obj, copyop);
    }
}

IfcOrientedEdge *ExpressDataSet::getIfcOrientedEdge(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOrientedEdge * > (current->second.get());
    }
    else {
        IfcOrientedEdge *ret = static_cast< IfcOrientedEdge * > (allocateIfcOrientedEdge(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOrientedEdge(IfcOrientedEdge *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOrientedEdge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOrientedEdge(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOrientedEdge *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOrientedEdge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOrientedEdge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOrientedEdge > ExpressDataSet::createIfcOrientedEdge(bool isVolatile) {
    if (isVolatile) {
        return new IfcOrientedEdge(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOrientedEdge * > (allocateIfcOrientedEdge(this, Step::Id_UNSET));
    }
}

IfcOrientedEdge *ExpressDataSet::cloneIfcOrientedEdge(ExpressDataSet *expressDataSet, const IfcOrientedEdge &obj, const CopyOp &copyop) {
    IfcOrientedEdge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOrientedEdge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOrientedEdge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOrientedEdge *ExpressDataSet::cloneIfcOrientedEdge(const IfcOrientedEdge &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOrientedEdge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOrientedEdge(this, obj, copyop);
    }
}

IfcOutletType *ExpressDataSet::getIfcOutletType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOutletType * > (current->second.get());
    }
    else {
        IfcOutletType *ret = static_cast< IfcOutletType * > (allocateIfcOutletType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOutletType(IfcOutletType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOutletType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOutletType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOutletType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOutletType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOutletType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOutletType > ExpressDataSet::createIfcOutletType(bool isVolatile) {
    if (isVolatile) {
        return new IfcOutletType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOutletType * > (allocateIfcOutletType(this, Step::Id_UNSET));
    }
}

IfcOutletType *ExpressDataSet::cloneIfcOutletType(ExpressDataSet *expressDataSet, const IfcOutletType &obj, const CopyOp &copyop) {
    IfcOutletType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOutletType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOutletType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOutletType *ExpressDataSet::cloneIfcOutletType(const IfcOutletType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOutletType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOutletType(this, obj, copyop);
    }
}

IfcOwnerHistory *ExpressDataSet::getIfcOwnerHistory(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcOwnerHistory * > (current->second.get());
    }
    else {
        IfcOwnerHistory *ret = static_cast< IfcOwnerHistory * > (allocateIfcOwnerHistory(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcOwnerHistory(IfcOwnerHistory *arg) {
    getAll().erase(arg->getKey());
    return m_IfcOwnerHistory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcOwnerHistory(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcOwnerHistory *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcOwnerHistory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcOwnerHistory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcOwnerHistory > ExpressDataSet::createIfcOwnerHistory(bool isVolatile) {
    if (isVolatile) {
        return new IfcOwnerHistory(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcOwnerHistory * > (allocateIfcOwnerHistory(this, Step::Id_UNSET));
    }
}

IfcOwnerHistory *ExpressDataSet::cloneIfcOwnerHistory(ExpressDataSet *expressDataSet, const IfcOwnerHistory &obj, const CopyOp &copyop) {
    IfcOwnerHistory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcOwnerHistory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcOwnerHistory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcOwnerHistory *ExpressDataSet::cloneIfcOwnerHistory(const IfcOwnerHistory &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcOwnerHistory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcOwnerHistory(this, obj, copyop);
    }
}

IfcPath *ExpressDataSet::getIfcPath(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPath * > (current->second.get());
    }
    else {
        IfcPath *ret = static_cast< IfcPath * > (allocateIfcPath(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPath(IfcPath *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPath_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPath(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPath *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPath(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPath_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPath > ExpressDataSet::createIfcPath(bool isVolatile) {
    if (isVolatile) {
        return new IfcPath(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPath * > (allocateIfcPath(this, Step::Id_UNSET));
    }
}

IfcPath *ExpressDataSet::cloneIfcPath(ExpressDataSet *expressDataSet, const IfcPath &obj, const CopyOp &copyop) {
    IfcPath *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPath(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPath_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPath *ExpressDataSet::cloneIfcPath(const IfcPath &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPath(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPath(this, obj, copyop);
    }
}

IfcPerformanceHistory *ExpressDataSet::getIfcPerformanceHistory(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPerformanceHistory * > (current->second.get());
    }
    else {
        IfcPerformanceHistory *ret = static_cast< IfcPerformanceHistory * > (allocateIfcPerformanceHistory(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPerformanceHistory(IfcPerformanceHistory *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPerformanceHistory_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPerformanceHistory(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPerformanceHistory *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPerformanceHistory(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPerformanceHistory_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPerformanceHistory > ExpressDataSet::createIfcPerformanceHistory(bool isVolatile) {
    if (isVolatile) {
        return new IfcPerformanceHistory(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPerformanceHistory * > (allocateIfcPerformanceHistory(this, Step::Id_UNSET));
    }
}

IfcPerformanceHistory *ExpressDataSet::cloneIfcPerformanceHistory(ExpressDataSet *expressDataSet, const IfcPerformanceHistory &obj, const CopyOp &copyop) {
    IfcPerformanceHistory *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPerformanceHistory(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPerformanceHistory_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPerformanceHistory *ExpressDataSet::cloneIfcPerformanceHistory(const IfcPerformanceHistory &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPerformanceHistory(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPerformanceHistory(this, obj, copyop);
    }
}

IfcPermeableCoveringProperties *ExpressDataSet::getIfcPermeableCoveringProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPermeableCoveringProperties * > (current->second.get());
    }
    else {
        IfcPermeableCoveringProperties *ret = static_cast< IfcPermeableCoveringProperties * > (allocateIfcPermeableCoveringProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPermeableCoveringProperties(IfcPermeableCoveringProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPermeableCoveringProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPermeableCoveringProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPermeableCoveringProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPermeableCoveringProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPermeableCoveringProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPermeableCoveringProperties > ExpressDataSet::createIfcPermeableCoveringProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcPermeableCoveringProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPermeableCoveringProperties * > (allocateIfcPermeableCoveringProperties(this, Step::Id_UNSET));
    }
}

IfcPermeableCoveringProperties *ExpressDataSet::cloneIfcPermeableCoveringProperties(ExpressDataSet *expressDataSet, const IfcPermeableCoveringProperties &obj, const CopyOp &copyop) {
    IfcPermeableCoveringProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPermeableCoveringProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPermeableCoveringProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPermeableCoveringProperties *ExpressDataSet::cloneIfcPermeableCoveringProperties(const IfcPermeableCoveringProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPermeableCoveringProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPermeableCoveringProperties(this, obj, copyop);
    }
}

IfcPermit *ExpressDataSet::getIfcPermit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPermit * > (current->second.get());
    }
    else {
        IfcPermit *ret = static_cast< IfcPermit * > (allocateIfcPermit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPermit(IfcPermit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPermit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPermit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPermit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPermit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPermit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPermit > ExpressDataSet::createIfcPermit(bool isVolatile) {
    if (isVolatile) {
        return new IfcPermit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPermit * > (allocateIfcPermit(this, Step::Id_UNSET));
    }
}

IfcPermit *ExpressDataSet::cloneIfcPermit(ExpressDataSet *expressDataSet, const IfcPermit &obj, const CopyOp &copyop) {
    IfcPermit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPermit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPermit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPermit *ExpressDataSet::cloneIfcPermit(const IfcPermit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPermit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPermit(this, obj, copyop);
    }
}

IfcPerson *ExpressDataSet::getIfcPerson(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPerson * > (current->second.get());
    }
    else {
        IfcPerson *ret = static_cast< IfcPerson * > (allocateIfcPerson(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPerson(IfcPerson *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPerson_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPerson(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPerson *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPerson(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPerson_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPerson > ExpressDataSet::createIfcPerson(bool isVolatile) {
    if (isVolatile) {
        return new IfcPerson(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPerson * > (allocateIfcPerson(this, Step::Id_UNSET));
    }
}

IfcPerson *ExpressDataSet::cloneIfcPerson(ExpressDataSet *expressDataSet, const IfcPerson &obj, const CopyOp &copyop) {
    IfcPerson *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPerson(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPerson_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPerson *ExpressDataSet::cloneIfcPerson(const IfcPerson &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPerson(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPerson(this, obj, copyop);
    }
}

IfcPersonAndOrganization *ExpressDataSet::getIfcPersonAndOrganization(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPersonAndOrganization * > (current->second.get());
    }
    else {
        IfcPersonAndOrganization *ret = static_cast< IfcPersonAndOrganization * > (allocateIfcPersonAndOrganization(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPersonAndOrganization(IfcPersonAndOrganization *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPersonAndOrganization_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPersonAndOrganization(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPersonAndOrganization *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPersonAndOrganization(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPersonAndOrganization_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPersonAndOrganization > ExpressDataSet::createIfcPersonAndOrganization(bool isVolatile) {
    if (isVolatile) {
        return new IfcPersonAndOrganization(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPersonAndOrganization * > (allocateIfcPersonAndOrganization(this, Step::Id_UNSET));
    }
}

IfcPersonAndOrganization *ExpressDataSet::cloneIfcPersonAndOrganization(ExpressDataSet *expressDataSet, const IfcPersonAndOrganization &obj, const CopyOp &copyop) {
    IfcPersonAndOrganization *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPersonAndOrganization(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPersonAndOrganization_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPersonAndOrganization *ExpressDataSet::cloneIfcPersonAndOrganization(const IfcPersonAndOrganization &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPersonAndOrganization(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPersonAndOrganization(this, obj, copyop);
    }
}

IfcPhysicalComplexQuantity *ExpressDataSet::getIfcPhysicalComplexQuantity(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPhysicalComplexQuantity * > (current->second.get());
    }
    else {
        IfcPhysicalComplexQuantity *ret = static_cast< IfcPhysicalComplexQuantity * > (allocateIfcPhysicalComplexQuantity(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPhysicalComplexQuantity(IfcPhysicalComplexQuantity *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPhysicalComplexQuantity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPhysicalComplexQuantity(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPhysicalComplexQuantity *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPhysicalComplexQuantity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPhysicalComplexQuantity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPhysicalComplexQuantity > ExpressDataSet::createIfcPhysicalComplexQuantity(bool isVolatile) {
    if (isVolatile) {
        return new IfcPhysicalComplexQuantity(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPhysicalComplexQuantity * > (allocateIfcPhysicalComplexQuantity(this, Step::Id_UNSET));
    }
}

IfcPhysicalComplexQuantity *ExpressDataSet::cloneIfcPhysicalComplexQuantity(ExpressDataSet *expressDataSet, const IfcPhysicalComplexQuantity &obj, const CopyOp &copyop) {
    IfcPhysicalComplexQuantity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPhysicalComplexQuantity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPhysicalComplexQuantity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPhysicalComplexQuantity *ExpressDataSet::cloneIfcPhysicalComplexQuantity(const IfcPhysicalComplexQuantity &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPhysicalComplexQuantity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPhysicalComplexQuantity(this, obj, copyop);
    }
}

IfcPile *ExpressDataSet::getIfcPile(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPile * > (current->second.get());
    }
    else {
        IfcPile *ret = static_cast< IfcPile * > (allocateIfcPile(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPile(IfcPile *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPile_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPile(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPile *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPile(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPile_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPile > ExpressDataSet::createIfcPile(bool isVolatile) {
    if (isVolatile) {
        return new IfcPile(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPile * > (allocateIfcPile(this, Step::Id_UNSET));
    }
}

IfcPile *ExpressDataSet::cloneIfcPile(ExpressDataSet *expressDataSet, const IfcPile &obj, const CopyOp &copyop) {
    IfcPile *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPile(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPile_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPile *ExpressDataSet::cloneIfcPile(const IfcPile &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPile(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPile(this, obj, copyop);
    }
}

IfcPipeFittingType *ExpressDataSet::getIfcPipeFittingType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPipeFittingType * > (current->second.get());
    }
    else {
        IfcPipeFittingType *ret = static_cast< IfcPipeFittingType * > (allocateIfcPipeFittingType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPipeFittingType(IfcPipeFittingType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPipeFittingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPipeFittingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPipeFittingType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPipeFittingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPipeFittingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPipeFittingType > ExpressDataSet::createIfcPipeFittingType(bool isVolatile) {
    if (isVolatile) {
        return new IfcPipeFittingType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPipeFittingType * > (allocateIfcPipeFittingType(this, Step::Id_UNSET));
    }
}

IfcPipeFittingType *ExpressDataSet::cloneIfcPipeFittingType(ExpressDataSet *expressDataSet, const IfcPipeFittingType &obj, const CopyOp &copyop) {
    IfcPipeFittingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPipeFittingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPipeFittingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPipeFittingType *ExpressDataSet::cloneIfcPipeFittingType(const IfcPipeFittingType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPipeFittingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPipeFittingType(this, obj, copyop);
    }
}

IfcPipeSegmentType *ExpressDataSet::getIfcPipeSegmentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPipeSegmentType * > (current->second.get());
    }
    else {
        IfcPipeSegmentType *ret = static_cast< IfcPipeSegmentType * > (allocateIfcPipeSegmentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPipeSegmentType(IfcPipeSegmentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPipeSegmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPipeSegmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPipeSegmentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPipeSegmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPipeSegmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPipeSegmentType > ExpressDataSet::createIfcPipeSegmentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcPipeSegmentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPipeSegmentType * > (allocateIfcPipeSegmentType(this, Step::Id_UNSET));
    }
}

IfcPipeSegmentType *ExpressDataSet::cloneIfcPipeSegmentType(ExpressDataSet *expressDataSet, const IfcPipeSegmentType &obj, const CopyOp &copyop) {
    IfcPipeSegmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPipeSegmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPipeSegmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPipeSegmentType *ExpressDataSet::cloneIfcPipeSegmentType(const IfcPipeSegmentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPipeSegmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPipeSegmentType(this, obj, copyop);
    }
}

IfcPixelTexture *ExpressDataSet::getIfcPixelTexture(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPixelTexture * > (current->second.get());
    }
    else {
        IfcPixelTexture *ret = static_cast< IfcPixelTexture * > (allocateIfcPixelTexture(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPixelTexture(IfcPixelTexture *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPixelTexture_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPixelTexture(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPixelTexture *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPixelTexture(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPixelTexture_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPixelTexture > ExpressDataSet::createIfcPixelTexture(bool isVolatile) {
    if (isVolatile) {
        return new IfcPixelTexture(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPixelTexture * > (allocateIfcPixelTexture(this, Step::Id_UNSET));
    }
}

IfcPixelTexture *ExpressDataSet::cloneIfcPixelTexture(ExpressDataSet *expressDataSet, const IfcPixelTexture &obj, const CopyOp &copyop) {
    IfcPixelTexture *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPixelTexture(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPixelTexture_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPixelTexture *ExpressDataSet::cloneIfcPixelTexture(const IfcPixelTexture &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPixelTexture(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPixelTexture(this, obj, copyop);
    }
}

IfcPlanarBox *ExpressDataSet::getIfcPlanarBox(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPlanarBox * > (current->second.get());
    }
    else {
        IfcPlanarBox *ret = static_cast< IfcPlanarBox * > (allocateIfcPlanarBox(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPlanarBox(IfcPlanarBox *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPlanarBox_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlanarBox(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPlanarBox *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlanarBox(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlanarBox_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlanarBox > ExpressDataSet::createIfcPlanarBox(bool isVolatile) {
    if (isVolatile) {
        return new IfcPlanarBox(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPlanarBox * > (allocateIfcPlanarBox(this, Step::Id_UNSET));
    }
}

IfcPlanarBox *ExpressDataSet::cloneIfcPlanarBox(ExpressDataSet *expressDataSet, const IfcPlanarBox &obj, const CopyOp &copyop) {
    IfcPlanarBox *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlanarBox(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlanarBox_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlanarBox *ExpressDataSet::cloneIfcPlanarBox(const IfcPlanarBox &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPlanarBox(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPlanarBox(this, obj, copyop);
    }
}

IfcPlanarExtent *ExpressDataSet::getIfcPlanarExtent(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPlanarExtent * > (current->second.get());
    }
    else {
        IfcPlanarExtent *ret = static_cast< IfcPlanarExtent * > (allocateIfcPlanarExtent(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPlanarExtent(IfcPlanarExtent *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPlanarExtent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlanarExtent(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPlanarExtent *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlanarExtent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlanarExtent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlanarExtent > ExpressDataSet::createIfcPlanarExtent(bool isVolatile) {
    if (isVolatile) {
        return new IfcPlanarExtent(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPlanarExtent * > (allocateIfcPlanarExtent(this, Step::Id_UNSET));
    }
}

IfcPlanarExtent *ExpressDataSet::cloneIfcPlanarExtent(ExpressDataSet *expressDataSet, const IfcPlanarExtent &obj, const CopyOp &copyop) {
    IfcPlanarExtent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlanarExtent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlanarExtent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlanarExtent *ExpressDataSet::cloneIfcPlanarExtent(const IfcPlanarExtent &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPlanarExtent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPlanarExtent(this, obj, copyop);
    }
}

IfcPlane *ExpressDataSet::getIfcPlane(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPlane * > (current->second.get());
    }
    else {
        IfcPlane *ret = static_cast< IfcPlane * > (allocateIfcPlane(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPlane(IfcPlane *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPlane_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlane(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPlane *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlane(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlane_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlane > ExpressDataSet::createIfcPlane(bool isVolatile) {
    if (isVolatile) {
        return new IfcPlane(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPlane * > (allocateIfcPlane(this, Step::Id_UNSET));
    }
}

IfcPlane *ExpressDataSet::cloneIfcPlane(ExpressDataSet *expressDataSet, const IfcPlane &obj, const CopyOp &copyop) {
    IfcPlane *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlane(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlane_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlane *ExpressDataSet::cloneIfcPlane(const IfcPlane &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPlane(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPlane(this, obj, copyop);
    }
}

IfcPlate *ExpressDataSet::getIfcPlate(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPlate * > (current->second.get());
    }
    else {
        IfcPlate *ret = static_cast< IfcPlate * > (allocateIfcPlate(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPlate(IfcPlate *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPlate_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlate(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPlate *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlate(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlate_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlate > ExpressDataSet::createIfcPlate(bool isVolatile) {
    if (isVolatile) {
        return new IfcPlate(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPlate * > (allocateIfcPlate(this, Step::Id_UNSET));
    }
}

IfcPlate *ExpressDataSet::cloneIfcPlate(ExpressDataSet *expressDataSet, const IfcPlate &obj, const CopyOp &copyop) {
    IfcPlate *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlate(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlate_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlate *ExpressDataSet::cloneIfcPlate(const IfcPlate &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPlate(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPlate(this, obj, copyop);
    }
}

IfcPlateType *ExpressDataSet::getIfcPlateType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPlateType * > (current->second.get());
    }
    else {
        IfcPlateType *ret = static_cast< IfcPlateType * > (allocateIfcPlateType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPlateType(IfcPlateType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPlateType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPlateType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPlateType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPlateType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPlateType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPlateType > ExpressDataSet::createIfcPlateType(bool isVolatile) {
    if (isVolatile) {
        return new IfcPlateType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPlateType * > (allocateIfcPlateType(this, Step::Id_UNSET));
    }
}

IfcPlateType *ExpressDataSet::cloneIfcPlateType(ExpressDataSet *expressDataSet, const IfcPlateType &obj, const CopyOp &copyop) {
    IfcPlateType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPlateType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPlateType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPlateType *ExpressDataSet::cloneIfcPlateType(const IfcPlateType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPlateType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPlateType(this, obj, copyop);
    }
}

IfcPointOnCurve *ExpressDataSet::getIfcPointOnCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPointOnCurve * > (current->second.get());
    }
    else {
        IfcPointOnCurve *ret = static_cast< IfcPointOnCurve * > (allocateIfcPointOnCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPointOnCurve(IfcPointOnCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPointOnCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPointOnCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPointOnCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPointOnCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPointOnCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPointOnCurve > ExpressDataSet::createIfcPointOnCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcPointOnCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPointOnCurve * > (allocateIfcPointOnCurve(this, Step::Id_UNSET));
    }
}

IfcPointOnCurve *ExpressDataSet::cloneIfcPointOnCurve(ExpressDataSet *expressDataSet, const IfcPointOnCurve &obj, const CopyOp &copyop) {
    IfcPointOnCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPointOnCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPointOnCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPointOnCurve *ExpressDataSet::cloneIfcPointOnCurve(const IfcPointOnCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPointOnCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPointOnCurve(this, obj, copyop);
    }
}

IfcPointOnSurface *ExpressDataSet::getIfcPointOnSurface(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPointOnSurface * > (current->second.get());
    }
    else {
        IfcPointOnSurface *ret = static_cast< IfcPointOnSurface * > (allocateIfcPointOnSurface(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPointOnSurface(IfcPointOnSurface *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPointOnSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPointOnSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPointOnSurface *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPointOnSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPointOnSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPointOnSurface > ExpressDataSet::createIfcPointOnSurface(bool isVolatile) {
    if (isVolatile) {
        return new IfcPointOnSurface(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPointOnSurface * > (allocateIfcPointOnSurface(this, Step::Id_UNSET));
    }
}

IfcPointOnSurface *ExpressDataSet::cloneIfcPointOnSurface(ExpressDataSet *expressDataSet, const IfcPointOnSurface &obj, const CopyOp &copyop) {
    IfcPointOnSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPointOnSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPointOnSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPointOnSurface *ExpressDataSet::cloneIfcPointOnSurface(const IfcPointOnSurface &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPointOnSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPointOnSurface(this, obj, copyop);
    }
}

IfcPolyLoop *ExpressDataSet::getIfcPolyLoop(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPolyLoop * > (current->second.get());
    }
    else {
        IfcPolyLoop *ret = static_cast< IfcPolyLoop * > (allocateIfcPolyLoop(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPolyLoop(IfcPolyLoop *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPolyLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolyLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPolyLoop *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolyLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolyLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolyLoop > ExpressDataSet::createIfcPolyLoop(bool isVolatile) {
    if (isVolatile) {
        return new IfcPolyLoop(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPolyLoop * > (allocateIfcPolyLoop(this, Step::Id_UNSET));
    }
}

IfcPolyLoop *ExpressDataSet::cloneIfcPolyLoop(ExpressDataSet *expressDataSet, const IfcPolyLoop &obj, const CopyOp &copyop) {
    IfcPolyLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolyLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolyLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolyLoop *ExpressDataSet::cloneIfcPolyLoop(const IfcPolyLoop &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPolyLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPolyLoop(this, obj, copyop);
    }
}

IfcPolygonalBoundedHalfSpace *ExpressDataSet::getIfcPolygonalBoundedHalfSpace(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPolygonalBoundedHalfSpace * > (current->second.get());
    }
    else {
        IfcPolygonalBoundedHalfSpace *ret = static_cast< IfcPolygonalBoundedHalfSpace * > (allocateIfcPolygonalBoundedHalfSpace(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPolygonalBoundedHalfSpace(IfcPolygonalBoundedHalfSpace *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPolygonalBoundedHalfSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolygonalBoundedHalfSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPolygonalBoundedHalfSpace *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolygonalBoundedHalfSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolygonalBoundedHalfSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolygonalBoundedHalfSpace > ExpressDataSet::createIfcPolygonalBoundedHalfSpace(bool isVolatile) {
    if (isVolatile) {
        return new IfcPolygonalBoundedHalfSpace(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPolygonalBoundedHalfSpace * > (allocateIfcPolygonalBoundedHalfSpace(this, Step::Id_UNSET));
    }
}

IfcPolygonalBoundedHalfSpace *ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(ExpressDataSet *expressDataSet, const IfcPolygonalBoundedHalfSpace &obj, const CopyOp &copyop) {
    IfcPolygonalBoundedHalfSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolygonalBoundedHalfSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolygonalBoundedHalfSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolygonalBoundedHalfSpace *ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(const IfcPolygonalBoundedHalfSpace &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPolygonalBoundedHalfSpace(this, obj, copyop);
    }
}

IfcPolyline *ExpressDataSet::getIfcPolyline(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPolyline * > (current->second.get());
    }
    else {
        IfcPolyline *ret = static_cast< IfcPolyline * > (allocateIfcPolyline(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPolyline(IfcPolyline *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPolyline_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPolyline(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPolyline *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPolyline(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPolyline_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPolyline > ExpressDataSet::createIfcPolyline(bool isVolatile) {
    if (isVolatile) {
        return new IfcPolyline(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPolyline * > (allocateIfcPolyline(this, Step::Id_UNSET));
    }
}

IfcPolyline *ExpressDataSet::cloneIfcPolyline(ExpressDataSet *expressDataSet, const IfcPolyline &obj, const CopyOp &copyop) {
    IfcPolyline *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPolyline(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPolyline_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPolyline *ExpressDataSet::cloneIfcPolyline(const IfcPolyline &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPolyline(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPolyline(this, obj, copyop);
    }
}

IfcPostalAddress *ExpressDataSet::getIfcPostalAddress(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPostalAddress * > (current->second.get());
    }
    else {
        IfcPostalAddress *ret = static_cast< IfcPostalAddress * > (allocateIfcPostalAddress(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPostalAddress(IfcPostalAddress *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPostalAddress_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPostalAddress(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPostalAddress *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPostalAddress(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPostalAddress_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPostalAddress > ExpressDataSet::createIfcPostalAddress(bool isVolatile) {
    if (isVolatile) {
        return new IfcPostalAddress(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPostalAddress * > (allocateIfcPostalAddress(this, Step::Id_UNSET));
    }
}

IfcPostalAddress *ExpressDataSet::cloneIfcPostalAddress(ExpressDataSet *expressDataSet, const IfcPostalAddress &obj, const CopyOp &copyop) {
    IfcPostalAddress *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPostalAddress(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPostalAddress_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPostalAddress *ExpressDataSet::cloneIfcPostalAddress(const IfcPostalAddress &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPostalAddress(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPostalAddress(this, obj, copyop);
    }
}

IfcPreDefinedDimensionSymbol *ExpressDataSet::getIfcPreDefinedDimensionSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPreDefinedDimensionSymbol * > (current->second.get());
    }
    else {
        IfcPreDefinedDimensionSymbol *ret = static_cast< IfcPreDefinedDimensionSymbol * > (allocateIfcPreDefinedDimensionSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPreDefinedDimensionSymbol(IfcPreDefinedDimensionSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedDimensionSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedDimensionSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPreDefinedDimensionSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedDimensionSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedDimensionSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedDimensionSymbol > ExpressDataSet::createIfcPreDefinedDimensionSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcPreDefinedDimensionSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPreDefinedDimensionSymbol * > (allocateIfcPreDefinedDimensionSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedDimensionSymbol *ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedDimensionSymbol &obj, const CopyOp &copyop) {
    IfcPreDefinedDimensionSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedDimensionSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedDimensionSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedDimensionSymbol *ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(const IfcPreDefinedDimensionSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPreDefinedDimensionSymbol(this, obj, copyop);
    }
}

IfcPreDefinedPointMarkerSymbol *ExpressDataSet::getIfcPreDefinedPointMarkerSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPreDefinedPointMarkerSymbol * > (current->second.get());
    }
    else {
        IfcPreDefinedPointMarkerSymbol *ret = static_cast< IfcPreDefinedPointMarkerSymbol * > (allocateIfcPreDefinedPointMarkerSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPreDefinedPointMarkerSymbol(IfcPreDefinedPointMarkerSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedPointMarkerSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedPointMarkerSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPreDefinedPointMarkerSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedPointMarkerSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedPointMarkerSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedPointMarkerSymbol > ExpressDataSet::createIfcPreDefinedPointMarkerSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcPreDefinedPointMarkerSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPreDefinedPointMarkerSymbol * > (allocateIfcPreDefinedPointMarkerSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedPointMarkerSymbol *ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedPointMarkerSymbol &obj, const CopyOp &copyop) {
    IfcPreDefinedPointMarkerSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedPointMarkerSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedPointMarkerSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedPointMarkerSymbol *ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(const IfcPreDefinedPointMarkerSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPreDefinedPointMarkerSymbol(this, obj, copyop);
    }
}

IfcPreDefinedTerminatorSymbol *ExpressDataSet::getIfcPreDefinedTerminatorSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPreDefinedTerminatorSymbol * > (current->second.get());
    }
    else {
        IfcPreDefinedTerminatorSymbol *ret = static_cast< IfcPreDefinedTerminatorSymbol * > (allocateIfcPreDefinedTerminatorSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPreDefinedTerminatorSymbol(IfcPreDefinedTerminatorSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPreDefinedTerminatorSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPreDefinedTerminatorSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPreDefinedTerminatorSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPreDefinedTerminatorSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPreDefinedTerminatorSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPreDefinedTerminatorSymbol > ExpressDataSet::createIfcPreDefinedTerminatorSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcPreDefinedTerminatorSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPreDefinedTerminatorSymbol * > (allocateIfcPreDefinedTerminatorSymbol(this, Step::Id_UNSET));
    }
}

IfcPreDefinedTerminatorSymbol *ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(ExpressDataSet *expressDataSet, const IfcPreDefinedTerminatorSymbol &obj, const CopyOp &copyop) {
    IfcPreDefinedTerminatorSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPreDefinedTerminatorSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPreDefinedTerminatorSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPreDefinedTerminatorSymbol *ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(const IfcPreDefinedTerminatorSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPreDefinedTerminatorSymbol(this, obj, copyop);
    }
}

IfcPresentationLayerAssignment *ExpressDataSet::getIfcPresentationLayerAssignment(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPresentationLayerAssignment * > (current->second.get());
    }
    else {
        IfcPresentationLayerAssignment *ret = static_cast< IfcPresentationLayerAssignment * > (allocateIfcPresentationLayerAssignment(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPresentationLayerAssignment(IfcPresentationLayerAssignment *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPresentationLayerAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationLayerAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPresentationLayerAssignment *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationLayerAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationLayerAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationLayerAssignment > ExpressDataSet::createIfcPresentationLayerAssignment(bool isVolatile) {
    if (isVolatile) {
        return new IfcPresentationLayerAssignment(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPresentationLayerAssignment * > (allocateIfcPresentationLayerAssignment(this, Step::Id_UNSET));
    }
}

IfcPresentationLayerAssignment *ExpressDataSet::cloneIfcPresentationLayerAssignment(ExpressDataSet *expressDataSet, const IfcPresentationLayerAssignment &obj, const CopyOp &copyop) {
    IfcPresentationLayerAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationLayerAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationLayerAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationLayerAssignment *ExpressDataSet::cloneIfcPresentationLayerAssignment(const IfcPresentationLayerAssignment &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPresentationLayerAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPresentationLayerAssignment(this, obj, copyop);
    }
}

IfcPresentationLayerWithStyle *ExpressDataSet::getIfcPresentationLayerWithStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPresentationLayerWithStyle * > (current->second.get());
    }
    else {
        IfcPresentationLayerWithStyle *ret = static_cast< IfcPresentationLayerWithStyle * > (allocateIfcPresentationLayerWithStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPresentationLayerWithStyle(IfcPresentationLayerWithStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPresentationLayerWithStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationLayerWithStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPresentationLayerWithStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationLayerWithStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationLayerWithStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationLayerWithStyle > ExpressDataSet::createIfcPresentationLayerWithStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcPresentationLayerWithStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPresentationLayerWithStyle * > (allocateIfcPresentationLayerWithStyle(this, Step::Id_UNSET));
    }
}

IfcPresentationLayerWithStyle *ExpressDataSet::cloneIfcPresentationLayerWithStyle(ExpressDataSet *expressDataSet, const IfcPresentationLayerWithStyle &obj, const CopyOp &copyop) {
    IfcPresentationLayerWithStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationLayerWithStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationLayerWithStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationLayerWithStyle *ExpressDataSet::cloneIfcPresentationLayerWithStyle(const IfcPresentationLayerWithStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPresentationLayerWithStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPresentationLayerWithStyle(this, obj, copyop);
    }
}

IfcPresentationStyleAssignment *ExpressDataSet::getIfcPresentationStyleAssignment(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPresentationStyleAssignment * > (current->second.get());
    }
    else {
        IfcPresentationStyleAssignment *ret = static_cast< IfcPresentationStyleAssignment * > (allocateIfcPresentationStyleAssignment(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPresentationStyleAssignment(IfcPresentationStyleAssignment *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPresentationStyleAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPresentationStyleAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPresentationStyleAssignment *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPresentationStyleAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPresentationStyleAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPresentationStyleAssignment > ExpressDataSet::createIfcPresentationStyleAssignment(bool isVolatile) {
    if (isVolatile) {
        return new IfcPresentationStyleAssignment(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPresentationStyleAssignment * > (allocateIfcPresentationStyleAssignment(this, Step::Id_UNSET));
    }
}

IfcPresentationStyleAssignment *ExpressDataSet::cloneIfcPresentationStyleAssignment(ExpressDataSet *expressDataSet, const IfcPresentationStyleAssignment &obj, const CopyOp &copyop) {
    IfcPresentationStyleAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPresentationStyleAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPresentationStyleAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPresentationStyleAssignment *ExpressDataSet::cloneIfcPresentationStyleAssignment(const IfcPresentationStyleAssignment &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPresentationStyleAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPresentationStyleAssignment(this, obj, copyop);
    }
}

IfcProcedure *ExpressDataSet::getIfcProcedure(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProcedure * > (current->second.get());
    }
    else {
        IfcProcedure *ret = static_cast< IfcProcedure * > (allocateIfcProcedure(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProcedure(IfcProcedure *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProcedure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProcedure(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProcedure *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProcedure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProcedure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProcedure > ExpressDataSet::createIfcProcedure(bool isVolatile) {
    if (isVolatile) {
        return new IfcProcedure(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProcedure * > (allocateIfcProcedure(this, Step::Id_UNSET));
    }
}

IfcProcedure *ExpressDataSet::cloneIfcProcedure(ExpressDataSet *expressDataSet, const IfcProcedure &obj, const CopyOp &copyop) {
    IfcProcedure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProcedure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProcedure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProcedure *ExpressDataSet::cloneIfcProcedure(const IfcProcedure &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProcedure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProcedure(this, obj, copyop);
    }
}

IfcProductDefinitionShape *ExpressDataSet::getIfcProductDefinitionShape(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProductDefinitionShape * > (current->second.get());
    }
    else {
        IfcProductDefinitionShape *ret = static_cast< IfcProductDefinitionShape * > (allocateIfcProductDefinitionShape(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProductDefinitionShape(IfcProductDefinitionShape *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProductDefinitionShape_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductDefinitionShape(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProductDefinitionShape *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductDefinitionShape(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductDefinitionShape_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductDefinitionShape > ExpressDataSet::createIfcProductDefinitionShape(bool isVolatile) {
    if (isVolatile) {
        return new IfcProductDefinitionShape(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProductDefinitionShape * > (allocateIfcProductDefinitionShape(this, Step::Id_UNSET));
    }
}

IfcProductDefinitionShape *ExpressDataSet::cloneIfcProductDefinitionShape(ExpressDataSet *expressDataSet, const IfcProductDefinitionShape &obj, const CopyOp &copyop) {
    IfcProductDefinitionShape *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductDefinitionShape(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductDefinitionShape_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductDefinitionShape *ExpressDataSet::cloneIfcProductDefinitionShape(const IfcProductDefinitionShape &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProductDefinitionShape(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProductDefinitionShape(this, obj, copyop);
    }
}

IfcProductRepresentation *ExpressDataSet::getIfcProductRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProductRepresentation * > (current->second.get());
    }
    else {
        IfcProductRepresentation *ret = static_cast< IfcProductRepresentation * > (allocateIfcProductRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProductRepresentation(IfcProductRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProductRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProductRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductRepresentation > ExpressDataSet::createIfcProductRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcProductRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProductRepresentation * > (allocateIfcProductRepresentation(this, Step::Id_UNSET));
    }
}

IfcProductRepresentation *ExpressDataSet::cloneIfcProductRepresentation(ExpressDataSet *expressDataSet, const IfcProductRepresentation &obj, const CopyOp &copyop) {
    IfcProductRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductRepresentation *ExpressDataSet::cloneIfcProductRepresentation(const IfcProductRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProductRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProductRepresentation(this, obj, copyop);
    }
}

IfcProductsOfCombustionProperties *ExpressDataSet::getIfcProductsOfCombustionProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProductsOfCombustionProperties * > (current->second.get());
    }
    else {
        IfcProductsOfCombustionProperties *ret = static_cast< IfcProductsOfCombustionProperties * > (allocateIfcProductsOfCombustionProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProductsOfCombustionProperties(IfcProductsOfCombustionProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProductsOfCombustionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProductsOfCombustionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProductsOfCombustionProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProductsOfCombustionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProductsOfCombustionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProductsOfCombustionProperties > ExpressDataSet::createIfcProductsOfCombustionProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcProductsOfCombustionProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProductsOfCombustionProperties * > (allocateIfcProductsOfCombustionProperties(this, Step::Id_UNSET));
    }
}

IfcProductsOfCombustionProperties *ExpressDataSet::cloneIfcProductsOfCombustionProperties(ExpressDataSet *expressDataSet, const IfcProductsOfCombustionProperties &obj, const CopyOp &copyop) {
    IfcProductsOfCombustionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProductsOfCombustionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProductsOfCombustionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProductsOfCombustionProperties *ExpressDataSet::cloneIfcProductsOfCombustionProperties(const IfcProductsOfCombustionProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProductsOfCombustionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProductsOfCombustionProperties(this, obj, copyop);
    }
}

IfcProject *ExpressDataSet::getIfcProject(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProject * > (current->second.get());
    }
    else {
        IfcProject *ret = static_cast< IfcProject * > (allocateIfcProject(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProject(IfcProject *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProject_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProject(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProject *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProject(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProject_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProject > ExpressDataSet::createIfcProject(bool isVolatile) {
    if (isVolatile) {
        return new IfcProject(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProject * > (allocateIfcProject(this, Step::Id_UNSET));
    }
}

IfcProject *ExpressDataSet::cloneIfcProject(ExpressDataSet *expressDataSet, const IfcProject &obj, const CopyOp &copyop) {
    IfcProject *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProject(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProject_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProject *ExpressDataSet::cloneIfcProject(const IfcProject &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProject(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProject(this, obj, copyop);
    }
}

IfcProjectOrder *ExpressDataSet::getIfcProjectOrder(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProjectOrder * > (current->second.get());
    }
    else {
        IfcProjectOrder *ret = static_cast< IfcProjectOrder * > (allocateIfcProjectOrder(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProjectOrder(IfcProjectOrder *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProjectOrder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectOrder(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProjectOrder *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectOrder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectOrder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectOrder > ExpressDataSet::createIfcProjectOrder(bool isVolatile) {
    if (isVolatile) {
        return new IfcProjectOrder(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProjectOrder * > (allocateIfcProjectOrder(this, Step::Id_UNSET));
    }
}

IfcProjectOrder *ExpressDataSet::cloneIfcProjectOrder(ExpressDataSet *expressDataSet, const IfcProjectOrder &obj, const CopyOp &copyop) {
    IfcProjectOrder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectOrder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectOrder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectOrder *ExpressDataSet::cloneIfcProjectOrder(const IfcProjectOrder &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProjectOrder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProjectOrder(this, obj, copyop);
    }
}

IfcProjectOrderRecord *ExpressDataSet::getIfcProjectOrderRecord(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProjectOrderRecord * > (current->second.get());
    }
    else {
        IfcProjectOrderRecord *ret = static_cast< IfcProjectOrderRecord * > (allocateIfcProjectOrderRecord(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProjectOrderRecord(IfcProjectOrderRecord *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProjectOrderRecord_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectOrderRecord(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProjectOrderRecord *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectOrderRecord(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectOrderRecord_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectOrderRecord > ExpressDataSet::createIfcProjectOrderRecord(bool isVolatile) {
    if (isVolatile) {
        return new IfcProjectOrderRecord(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProjectOrderRecord * > (allocateIfcProjectOrderRecord(this, Step::Id_UNSET));
    }
}

IfcProjectOrderRecord *ExpressDataSet::cloneIfcProjectOrderRecord(ExpressDataSet *expressDataSet, const IfcProjectOrderRecord &obj, const CopyOp &copyop) {
    IfcProjectOrderRecord *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectOrderRecord(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectOrderRecord_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectOrderRecord *ExpressDataSet::cloneIfcProjectOrderRecord(const IfcProjectOrderRecord &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProjectOrderRecord(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProjectOrderRecord(this, obj, copyop);
    }
}

IfcProjectionCurve *ExpressDataSet::getIfcProjectionCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProjectionCurve * > (current->second.get());
    }
    else {
        IfcProjectionCurve *ret = static_cast< IfcProjectionCurve * > (allocateIfcProjectionCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProjectionCurve(IfcProjectionCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProjectionCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectionCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProjectionCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectionCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectionCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectionCurve > ExpressDataSet::createIfcProjectionCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcProjectionCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProjectionCurve * > (allocateIfcProjectionCurve(this, Step::Id_UNSET));
    }
}

IfcProjectionCurve *ExpressDataSet::cloneIfcProjectionCurve(ExpressDataSet *expressDataSet, const IfcProjectionCurve &obj, const CopyOp &copyop) {
    IfcProjectionCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectionCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectionCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectionCurve *ExpressDataSet::cloneIfcProjectionCurve(const IfcProjectionCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProjectionCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProjectionCurve(this, obj, copyop);
    }
}

IfcProjectionElement *ExpressDataSet::getIfcProjectionElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProjectionElement * > (current->second.get());
    }
    else {
        IfcProjectionElement *ret = static_cast< IfcProjectionElement * > (allocateIfcProjectionElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProjectionElement(IfcProjectionElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProjectionElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProjectionElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProjectionElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProjectionElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProjectionElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProjectionElement > ExpressDataSet::createIfcProjectionElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcProjectionElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProjectionElement * > (allocateIfcProjectionElement(this, Step::Id_UNSET));
    }
}

IfcProjectionElement *ExpressDataSet::cloneIfcProjectionElement(ExpressDataSet *expressDataSet, const IfcProjectionElement &obj, const CopyOp &copyop) {
    IfcProjectionElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProjectionElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProjectionElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProjectionElement *ExpressDataSet::cloneIfcProjectionElement(const IfcProjectionElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProjectionElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProjectionElement(this, obj, copyop);
    }
}

IfcPropertyBoundedValue *ExpressDataSet::getIfcPropertyBoundedValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyBoundedValue * > (current->second.get());
    }
    else {
        IfcPropertyBoundedValue *ret = static_cast< IfcPropertyBoundedValue * > (allocateIfcPropertyBoundedValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyBoundedValue(IfcPropertyBoundedValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyBoundedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyBoundedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyBoundedValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyBoundedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyBoundedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyBoundedValue > ExpressDataSet::createIfcPropertyBoundedValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyBoundedValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyBoundedValue * > (allocateIfcPropertyBoundedValue(this, Step::Id_UNSET));
    }
}

IfcPropertyBoundedValue *ExpressDataSet::cloneIfcPropertyBoundedValue(ExpressDataSet *expressDataSet, const IfcPropertyBoundedValue &obj, const CopyOp &copyop) {
    IfcPropertyBoundedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyBoundedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyBoundedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyBoundedValue *ExpressDataSet::cloneIfcPropertyBoundedValue(const IfcPropertyBoundedValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyBoundedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyBoundedValue(this, obj, copyop);
    }
}

IfcPropertyConstraintRelationship *ExpressDataSet::getIfcPropertyConstraintRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyConstraintRelationship * > (current->second.get());
    }
    else {
        IfcPropertyConstraintRelationship *ret = static_cast< IfcPropertyConstraintRelationship * > (allocateIfcPropertyConstraintRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyConstraintRelationship(IfcPropertyConstraintRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyConstraintRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyConstraintRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyConstraintRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyConstraintRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyConstraintRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyConstraintRelationship > ExpressDataSet::createIfcPropertyConstraintRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyConstraintRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyConstraintRelationship * > (allocateIfcPropertyConstraintRelationship(this, Step::Id_UNSET));
    }
}

IfcPropertyConstraintRelationship *ExpressDataSet::cloneIfcPropertyConstraintRelationship(ExpressDataSet *expressDataSet, const IfcPropertyConstraintRelationship &obj, const CopyOp &copyop) {
    IfcPropertyConstraintRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyConstraintRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyConstraintRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyConstraintRelationship *ExpressDataSet::cloneIfcPropertyConstraintRelationship(const IfcPropertyConstraintRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyConstraintRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyConstraintRelationship(this, obj, copyop);
    }
}

IfcPropertyDependencyRelationship *ExpressDataSet::getIfcPropertyDependencyRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyDependencyRelationship * > (current->second.get());
    }
    else {
        IfcPropertyDependencyRelationship *ret = static_cast< IfcPropertyDependencyRelationship * > (allocateIfcPropertyDependencyRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyDependencyRelationship(IfcPropertyDependencyRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyDependencyRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyDependencyRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyDependencyRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyDependencyRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyDependencyRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyDependencyRelationship > ExpressDataSet::createIfcPropertyDependencyRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyDependencyRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyDependencyRelationship * > (allocateIfcPropertyDependencyRelationship(this, Step::Id_UNSET));
    }
}

IfcPropertyDependencyRelationship *ExpressDataSet::cloneIfcPropertyDependencyRelationship(ExpressDataSet *expressDataSet, const IfcPropertyDependencyRelationship &obj, const CopyOp &copyop) {
    IfcPropertyDependencyRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyDependencyRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyDependencyRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyDependencyRelationship *ExpressDataSet::cloneIfcPropertyDependencyRelationship(const IfcPropertyDependencyRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyDependencyRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyDependencyRelationship(this, obj, copyop);
    }
}

IfcPropertyEnumeratedValue *ExpressDataSet::getIfcPropertyEnumeratedValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyEnumeratedValue * > (current->second.get());
    }
    else {
        IfcPropertyEnumeratedValue *ret = static_cast< IfcPropertyEnumeratedValue * > (allocateIfcPropertyEnumeratedValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyEnumeratedValue(IfcPropertyEnumeratedValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyEnumeratedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyEnumeratedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyEnumeratedValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyEnumeratedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyEnumeratedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyEnumeratedValue > ExpressDataSet::createIfcPropertyEnumeratedValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyEnumeratedValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyEnumeratedValue * > (allocateIfcPropertyEnumeratedValue(this, Step::Id_UNSET));
    }
}

IfcPropertyEnumeratedValue *ExpressDataSet::cloneIfcPropertyEnumeratedValue(ExpressDataSet *expressDataSet, const IfcPropertyEnumeratedValue &obj, const CopyOp &copyop) {
    IfcPropertyEnumeratedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyEnumeratedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyEnumeratedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyEnumeratedValue *ExpressDataSet::cloneIfcPropertyEnumeratedValue(const IfcPropertyEnumeratedValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyEnumeratedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyEnumeratedValue(this, obj, copyop);
    }
}

IfcPropertyEnumeration *ExpressDataSet::getIfcPropertyEnumeration(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyEnumeration * > (current->second.get());
    }
    else {
        IfcPropertyEnumeration *ret = static_cast< IfcPropertyEnumeration * > (allocateIfcPropertyEnumeration(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyEnumeration(IfcPropertyEnumeration *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyEnumeration_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyEnumeration(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyEnumeration *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyEnumeration(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyEnumeration_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyEnumeration > ExpressDataSet::createIfcPropertyEnumeration(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyEnumeration(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyEnumeration * > (allocateIfcPropertyEnumeration(this, Step::Id_UNSET));
    }
}

IfcPropertyEnumeration *ExpressDataSet::cloneIfcPropertyEnumeration(ExpressDataSet *expressDataSet, const IfcPropertyEnumeration &obj, const CopyOp &copyop) {
    IfcPropertyEnumeration *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyEnumeration(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyEnumeration_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyEnumeration *ExpressDataSet::cloneIfcPropertyEnumeration(const IfcPropertyEnumeration &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyEnumeration(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyEnumeration(this, obj, copyop);
    }
}

IfcPropertyListValue *ExpressDataSet::getIfcPropertyListValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyListValue * > (current->second.get());
    }
    else {
        IfcPropertyListValue *ret = static_cast< IfcPropertyListValue * > (allocateIfcPropertyListValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyListValue(IfcPropertyListValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyListValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyListValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyListValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyListValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyListValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyListValue > ExpressDataSet::createIfcPropertyListValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyListValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyListValue * > (allocateIfcPropertyListValue(this, Step::Id_UNSET));
    }
}

IfcPropertyListValue *ExpressDataSet::cloneIfcPropertyListValue(ExpressDataSet *expressDataSet, const IfcPropertyListValue &obj, const CopyOp &copyop) {
    IfcPropertyListValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyListValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyListValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyListValue *ExpressDataSet::cloneIfcPropertyListValue(const IfcPropertyListValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyListValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyListValue(this, obj, copyop);
    }
}

IfcPropertyReferenceValue *ExpressDataSet::getIfcPropertyReferenceValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyReferenceValue * > (current->second.get());
    }
    else {
        IfcPropertyReferenceValue *ret = static_cast< IfcPropertyReferenceValue * > (allocateIfcPropertyReferenceValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyReferenceValue(IfcPropertyReferenceValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyReferenceValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyReferenceValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyReferenceValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyReferenceValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyReferenceValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyReferenceValue > ExpressDataSet::createIfcPropertyReferenceValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyReferenceValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyReferenceValue * > (allocateIfcPropertyReferenceValue(this, Step::Id_UNSET));
    }
}

IfcPropertyReferenceValue *ExpressDataSet::cloneIfcPropertyReferenceValue(ExpressDataSet *expressDataSet, const IfcPropertyReferenceValue &obj, const CopyOp &copyop) {
    IfcPropertyReferenceValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyReferenceValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyReferenceValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyReferenceValue *ExpressDataSet::cloneIfcPropertyReferenceValue(const IfcPropertyReferenceValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyReferenceValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyReferenceValue(this, obj, copyop);
    }
}

IfcPropertySet *ExpressDataSet::getIfcPropertySet(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertySet * > (current->second.get());
    }
    else {
        IfcPropertySet *ret = static_cast< IfcPropertySet * > (allocateIfcPropertySet(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertySet(IfcPropertySet *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertySet_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertySet(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertySet *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertySet(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertySet_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertySet > ExpressDataSet::createIfcPropertySet(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertySet(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertySet * > (allocateIfcPropertySet(this, Step::Id_UNSET));
    }
}

IfcPropertySet *ExpressDataSet::cloneIfcPropertySet(ExpressDataSet *expressDataSet, const IfcPropertySet &obj, const CopyOp &copyop) {
    IfcPropertySet *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertySet(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertySet_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertySet *ExpressDataSet::cloneIfcPropertySet(const IfcPropertySet &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertySet(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertySet(this, obj, copyop);
    }
}

IfcPropertySingleValue *ExpressDataSet::getIfcPropertySingleValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertySingleValue * > (current->second.get());
    }
    else {
        IfcPropertySingleValue *ret = static_cast< IfcPropertySingleValue * > (allocateIfcPropertySingleValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertySingleValue(IfcPropertySingleValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertySingleValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertySingleValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertySingleValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertySingleValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertySingleValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertySingleValue > ExpressDataSet::createIfcPropertySingleValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertySingleValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertySingleValue * > (allocateIfcPropertySingleValue(this, Step::Id_UNSET));
    }
}

IfcPropertySingleValue *ExpressDataSet::cloneIfcPropertySingleValue(ExpressDataSet *expressDataSet, const IfcPropertySingleValue &obj, const CopyOp &copyop) {
    IfcPropertySingleValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertySingleValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertySingleValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertySingleValue *ExpressDataSet::cloneIfcPropertySingleValue(const IfcPropertySingleValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertySingleValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertySingleValue(this, obj, copyop);
    }
}

IfcPropertyTableValue *ExpressDataSet::getIfcPropertyTableValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPropertyTableValue * > (current->second.get());
    }
    else {
        IfcPropertyTableValue *ret = static_cast< IfcPropertyTableValue * > (allocateIfcPropertyTableValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPropertyTableValue(IfcPropertyTableValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPropertyTableValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPropertyTableValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPropertyTableValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPropertyTableValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPropertyTableValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPropertyTableValue > ExpressDataSet::createIfcPropertyTableValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcPropertyTableValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPropertyTableValue * > (allocateIfcPropertyTableValue(this, Step::Id_UNSET));
    }
}

IfcPropertyTableValue *ExpressDataSet::cloneIfcPropertyTableValue(ExpressDataSet *expressDataSet, const IfcPropertyTableValue &obj, const CopyOp &copyop) {
    IfcPropertyTableValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPropertyTableValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPropertyTableValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPropertyTableValue *ExpressDataSet::cloneIfcPropertyTableValue(const IfcPropertyTableValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPropertyTableValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPropertyTableValue(this, obj, copyop);
    }
}

IfcProtectiveDeviceType *ExpressDataSet::getIfcProtectiveDeviceType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProtectiveDeviceType * > (current->second.get());
    }
    else {
        IfcProtectiveDeviceType *ret = static_cast< IfcProtectiveDeviceType * > (allocateIfcProtectiveDeviceType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProtectiveDeviceType(IfcProtectiveDeviceType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProtectiveDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProtectiveDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProtectiveDeviceType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProtectiveDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProtectiveDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProtectiveDeviceType > ExpressDataSet::createIfcProtectiveDeviceType(bool isVolatile) {
    if (isVolatile) {
        return new IfcProtectiveDeviceType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProtectiveDeviceType * > (allocateIfcProtectiveDeviceType(this, Step::Id_UNSET));
    }
}

IfcProtectiveDeviceType *ExpressDataSet::cloneIfcProtectiveDeviceType(ExpressDataSet *expressDataSet, const IfcProtectiveDeviceType &obj, const CopyOp &copyop) {
    IfcProtectiveDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProtectiveDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProtectiveDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProtectiveDeviceType *ExpressDataSet::cloneIfcProtectiveDeviceType(const IfcProtectiveDeviceType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProtectiveDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProtectiveDeviceType(this, obj, copyop);
    }
}

IfcProxy *ExpressDataSet::getIfcProxy(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcProxy * > (current->second.get());
    }
    else {
        IfcProxy *ret = static_cast< IfcProxy * > (allocateIfcProxy(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcProxy(IfcProxy *arg) {
    getAll().erase(arg->getKey());
    return m_IfcProxy_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcProxy(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcProxy *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcProxy(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcProxy_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcProxy > ExpressDataSet::createIfcProxy(bool isVolatile) {
    if (isVolatile) {
        return new IfcProxy(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcProxy * > (allocateIfcProxy(this, Step::Id_UNSET));
    }
}

IfcProxy *ExpressDataSet::cloneIfcProxy(ExpressDataSet *expressDataSet, const IfcProxy &obj, const CopyOp &copyop) {
    IfcProxy *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcProxy(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcProxy_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcProxy *ExpressDataSet::cloneIfcProxy(const IfcProxy &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcProxy(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcProxy(this, obj, copyop);
    }
}

IfcPumpType *ExpressDataSet::getIfcPumpType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcPumpType * > (current->second.get());
    }
    else {
        IfcPumpType *ret = static_cast< IfcPumpType * > (allocateIfcPumpType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcPumpType(IfcPumpType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcPumpType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcPumpType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcPumpType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcPumpType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcPumpType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcPumpType > ExpressDataSet::createIfcPumpType(bool isVolatile) {
    if (isVolatile) {
        return new IfcPumpType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcPumpType * > (allocateIfcPumpType(this, Step::Id_UNSET));
    }
}

IfcPumpType *ExpressDataSet::cloneIfcPumpType(ExpressDataSet *expressDataSet, const IfcPumpType &obj, const CopyOp &copyop) {
    IfcPumpType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcPumpType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcPumpType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcPumpType *ExpressDataSet::cloneIfcPumpType(const IfcPumpType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcPumpType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcPumpType(this, obj, copyop);
    }
}

IfcQuantityArea *ExpressDataSet::getIfcQuantityArea(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityArea * > (current->second.get());
    }
    else {
        IfcQuantityArea *ret = static_cast< IfcQuantityArea * > (allocateIfcQuantityArea(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityArea(IfcQuantityArea *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityArea_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityArea(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityArea *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityArea(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityArea_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityArea > ExpressDataSet::createIfcQuantityArea(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityArea(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityArea * > (allocateIfcQuantityArea(this, Step::Id_UNSET));
    }
}

IfcQuantityArea *ExpressDataSet::cloneIfcQuantityArea(ExpressDataSet *expressDataSet, const IfcQuantityArea &obj, const CopyOp &copyop) {
    IfcQuantityArea *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityArea(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityArea_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityArea *ExpressDataSet::cloneIfcQuantityArea(const IfcQuantityArea &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityArea(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityArea(this, obj, copyop);
    }
}

IfcQuantityCount *ExpressDataSet::getIfcQuantityCount(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityCount * > (current->second.get());
    }
    else {
        IfcQuantityCount *ret = static_cast< IfcQuantityCount * > (allocateIfcQuantityCount(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityCount(IfcQuantityCount *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityCount_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityCount(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityCount *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityCount(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityCount_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityCount > ExpressDataSet::createIfcQuantityCount(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityCount(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityCount * > (allocateIfcQuantityCount(this, Step::Id_UNSET));
    }
}

IfcQuantityCount *ExpressDataSet::cloneIfcQuantityCount(ExpressDataSet *expressDataSet, const IfcQuantityCount &obj, const CopyOp &copyop) {
    IfcQuantityCount *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityCount(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityCount_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityCount *ExpressDataSet::cloneIfcQuantityCount(const IfcQuantityCount &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityCount(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityCount(this, obj, copyop);
    }
}

IfcQuantityLength *ExpressDataSet::getIfcQuantityLength(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityLength * > (current->second.get());
    }
    else {
        IfcQuantityLength *ret = static_cast< IfcQuantityLength * > (allocateIfcQuantityLength(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityLength(IfcQuantityLength *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityLength_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityLength(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityLength *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityLength(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityLength_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityLength > ExpressDataSet::createIfcQuantityLength(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityLength(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityLength * > (allocateIfcQuantityLength(this, Step::Id_UNSET));
    }
}

IfcQuantityLength *ExpressDataSet::cloneIfcQuantityLength(ExpressDataSet *expressDataSet, const IfcQuantityLength &obj, const CopyOp &copyop) {
    IfcQuantityLength *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityLength(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityLength_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityLength *ExpressDataSet::cloneIfcQuantityLength(const IfcQuantityLength &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityLength(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityLength(this, obj, copyop);
    }
}

IfcQuantityTime *ExpressDataSet::getIfcQuantityTime(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityTime * > (current->second.get());
    }
    else {
        IfcQuantityTime *ret = static_cast< IfcQuantityTime * > (allocateIfcQuantityTime(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityTime(IfcQuantityTime *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityTime_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityTime(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityTime *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityTime(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityTime_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityTime > ExpressDataSet::createIfcQuantityTime(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityTime(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityTime * > (allocateIfcQuantityTime(this, Step::Id_UNSET));
    }
}

IfcQuantityTime *ExpressDataSet::cloneIfcQuantityTime(ExpressDataSet *expressDataSet, const IfcQuantityTime &obj, const CopyOp &copyop) {
    IfcQuantityTime *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityTime(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityTime_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityTime *ExpressDataSet::cloneIfcQuantityTime(const IfcQuantityTime &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityTime(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityTime(this, obj, copyop);
    }
}

IfcQuantityVolume *ExpressDataSet::getIfcQuantityVolume(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityVolume * > (current->second.get());
    }
    else {
        IfcQuantityVolume *ret = static_cast< IfcQuantityVolume * > (allocateIfcQuantityVolume(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityVolume(IfcQuantityVolume *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityVolume_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityVolume(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityVolume *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityVolume(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityVolume_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityVolume > ExpressDataSet::createIfcQuantityVolume(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityVolume(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityVolume * > (allocateIfcQuantityVolume(this, Step::Id_UNSET));
    }
}

IfcQuantityVolume *ExpressDataSet::cloneIfcQuantityVolume(ExpressDataSet *expressDataSet, const IfcQuantityVolume &obj, const CopyOp &copyop) {
    IfcQuantityVolume *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityVolume(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityVolume_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityVolume *ExpressDataSet::cloneIfcQuantityVolume(const IfcQuantityVolume &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityVolume(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityVolume(this, obj, copyop);
    }
}

IfcQuantityWeight *ExpressDataSet::getIfcQuantityWeight(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcQuantityWeight * > (current->second.get());
    }
    else {
        IfcQuantityWeight *ret = static_cast< IfcQuantityWeight * > (allocateIfcQuantityWeight(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcQuantityWeight(IfcQuantityWeight *arg) {
    getAll().erase(arg->getKey());
    return m_IfcQuantityWeight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcQuantityWeight(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcQuantityWeight *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcQuantityWeight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcQuantityWeight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcQuantityWeight > ExpressDataSet::createIfcQuantityWeight(bool isVolatile) {
    if (isVolatile) {
        return new IfcQuantityWeight(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcQuantityWeight * > (allocateIfcQuantityWeight(this, Step::Id_UNSET));
    }
}

IfcQuantityWeight *ExpressDataSet::cloneIfcQuantityWeight(ExpressDataSet *expressDataSet, const IfcQuantityWeight &obj, const CopyOp &copyop) {
    IfcQuantityWeight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcQuantityWeight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcQuantityWeight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcQuantityWeight *ExpressDataSet::cloneIfcQuantityWeight(const IfcQuantityWeight &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcQuantityWeight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcQuantityWeight(this, obj, copyop);
    }
}

IfcRadiusDimension *ExpressDataSet::getIfcRadiusDimension(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRadiusDimension * > (current->second.get());
    }
    else {
        IfcRadiusDimension *ret = static_cast< IfcRadiusDimension * > (allocateIfcRadiusDimension(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRadiusDimension(IfcRadiusDimension *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRadiusDimension_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRadiusDimension(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRadiusDimension *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRadiusDimension(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRadiusDimension_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRadiusDimension > ExpressDataSet::createIfcRadiusDimension(bool isVolatile) {
    if (isVolatile) {
        return new IfcRadiusDimension(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRadiusDimension * > (allocateIfcRadiusDimension(this, Step::Id_UNSET));
    }
}

IfcRadiusDimension *ExpressDataSet::cloneIfcRadiusDimension(ExpressDataSet *expressDataSet, const IfcRadiusDimension &obj, const CopyOp &copyop) {
    IfcRadiusDimension *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRadiusDimension(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRadiusDimension_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRadiusDimension *ExpressDataSet::cloneIfcRadiusDimension(const IfcRadiusDimension &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRadiusDimension(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRadiusDimension(this, obj, copyop);
    }
}

IfcRailing *ExpressDataSet::getIfcRailing(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRailing * > (current->second.get());
    }
    else {
        IfcRailing *ret = static_cast< IfcRailing * > (allocateIfcRailing(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRailing(IfcRailing *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRailing_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRailing(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRailing *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRailing(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRailing_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRailing > ExpressDataSet::createIfcRailing(bool isVolatile) {
    if (isVolatile) {
        return new IfcRailing(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRailing * > (allocateIfcRailing(this, Step::Id_UNSET));
    }
}

IfcRailing *ExpressDataSet::cloneIfcRailing(ExpressDataSet *expressDataSet, const IfcRailing &obj, const CopyOp &copyop) {
    IfcRailing *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRailing(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRailing_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRailing *ExpressDataSet::cloneIfcRailing(const IfcRailing &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRailing(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRailing(this, obj, copyop);
    }
}

IfcRailingType *ExpressDataSet::getIfcRailingType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRailingType * > (current->second.get());
    }
    else {
        IfcRailingType *ret = static_cast< IfcRailingType * > (allocateIfcRailingType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRailingType(IfcRailingType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRailingType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRailingType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRailingType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRailingType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRailingType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRailingType > ExpressDataSet::createIfcRailingType(bool isVolatile) {
    if (isVolatile) {
        return new IfcRailingType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRailingType * > (allocateIfcRailingType(this, Step::Id_UNSET));
    }
}

IfcRailingType *ExpressDataSet::cloneIfcRailingType(ExpressDataSet *expressDataSet, const IfcRailingType &obj, const CopyOp &copyop) {
    IfcRailingType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRailingType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRailingType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRailingType *ExpressDataSet::cloneIfcRailingType(const IfcRailingType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRailingType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRailingType(this, obj, copyop);
    }
}

IfcRamp *ExpressDataSet::getIfcRamp(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRamp * > (current->second.get());
    }
    else {
        IfcRamp *ret = static_cast< IfcRamp * > (allocateIfcRamp(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRamp(IfcRamp *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRamp_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRamp(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRamp *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRamp(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRamp_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRamp > ExpressDataSet::createIfcRamp(bool isVolatile) {
    if (isVolatile) {
        return new IfcRamp(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRamp * > (allocateIfcRamp(this, Step::Id_UNSET));
    }
}

IfcRamp *ExpressDataSet::cloneIfcRamp(ExpressDataSet *expressDataSet, const IfcRamp &obj, const CopyOp &copyop) {
    IfcRamp *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRamp(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRamp_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRamp *ExpressDataSet::cloneIfcRamp(const IfcRamp &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRamp(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRamp(this, obj, copyop);
    }
}

IfcRampFlight *ExpressDataSet::getIfcRampFlight(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRampFlight * > (current->second.get());
    }
    else {
        IfcRampFlight *ret = static_cast< IfcRampFlight * > (allocateIfcRampFlight(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRampFlight(IfcRampFlight *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRampFlight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRampFlight(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRampFlight *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRampFlight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRampFlight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRampFlight > ExpressDataSet::createIfcRampFlight(bool isVolatile) {
    if (isVolatile) {
        return new IfcRampFlight(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRampFlight * > (allocateIfcRampFlight(this, Step::Id_UNSET));
    }
}

IfcRampFlight *ExpressDataSet::cloneIfcRampFlight(ExpressDataSet *expressDataSet, const IfcRampFlight &obj, const CopyOp &copyop) {
    IfcRampFlight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRampFlight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRampFlight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRampFlight *ExpressDataSet::cloneIfcRampFlight(const IfcRampFlight &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRampFlight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRampFlight(this, obj, copyop);
    }
}

IfcRampFlightType *ExpressDataSet::getIfcRampFlightType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRampFlightType * > (current->second.get());
    }
    else {
        IfcRampFlightType *ret = static_cast< IfcRampFlightType * > (allocateIfcRampFlightType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRampFlightType(IfcRampFlightType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRampFlightType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRampFlightType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRampFlightType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRampFlightType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRampFlightType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRampFlightType > ExpressDataSet::createIfcRampFlightType(bool isVolatile) {
    if (isVolatile) {
        return new IfcRampFlightType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRampFlightType * > (allocateIfcRampFlightType(this, Step::Id_UNSET));
    }
}

IfcRampFlightType *ExpressDataSet::cloneIfcRampFlightType(ExpressDataSet *expressDataSet, const IfcRampFlightType &obj, const CopyOp &copyop) {
    IfcRampFlightType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRampFlightType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRampFlightType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRampFlightType *ExpressDataSet::cloneIfcRampFlightType(const IfcRampFlightType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRampFlightType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRampFlightType(this, obj, copyop);
    }
}

IfcRationalBezierCurve *ExpressDataSet::getIfcRationalBezierCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRationalBezierCurve * > (current->second.get());
    }
    else {
        IfcRationalBezierCurve *ret = static_cast< IfcRationalBezierCurve * > (allocateIfcRationalBezierCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRationalBezierCurve(IfcRationalBezierCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRationalBezierCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRationalBezierCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRationalBezierCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRationalBezierCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRationalBezierCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRationalBezierCurve > ExpressDataSet::createIfcRationalBezierCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcRationalBezierCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRationalBezierCurve * > (allocateIfcRationalBezierCurve(this, Step::Id_UNSET));
    }
}

IfcRationalBezierCurve *ExpressDataSet::cloneIfcRationalBezierCurve(ExpressDataSet *expressDataSet, const IfcRationalBezierCurve &obj, const CopyOp &copyop) {
    IfcRationalBezierCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRationalBezierCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRationalBezierCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRationalBezierCurve *ExpressDataSet::cloneIfcRationalBezierCurve(const IfcRationalBezierCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRationalBezierCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRationalBezierCurve(this, obj, copyop);
    }
}

IfcRectangleHollowProfileDef *ExpressDataSet::getIfcRectangleHollowProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRectangleHollowProfileDef * > (current->second.get());
    }
    else {
        IfcRectangleHollowProfileDef *ret = static_cast< IfcRectangleHollowProfileDef * > (allocateIfcRectangleHollowProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRectangleHollowProfileDef(IfcRectangleHollowProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRectangleHollowProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangleHollowProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRectangleHollowProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangleHollowProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangleHollowProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangleHollowProfileDef > ExpressDataSet::createIfcRectangleHollowProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcRectangleHollowProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRectangleHollowProfileDef * > (allocateIfcRectangleHollowProfileDef(this, Step::Id_UNSET));
    }
}

IfcRectangleHollowProfileDef *ExpressDataSet::cloneIfcRectangleHollowProfileDef(ExpressDataSet *expressDataSet, const IfcRectangleHollowProfileDef &obj, const CopyOp &copyop) {
    IfcRectangleHollowProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangleHollowProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangleHollowProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangleHollowProfileDef *ExpressDataSet::cloneIfcRectangleHollowProfileDef(const IfcRectangleHollowProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRectangleHollowProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRectangleHollowProfileDef(this, obj, copyop);
    }
}

IfcRectangleProfileDef *ExpressDataSet::getIfcRectangleProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRectangleProfileDef * > (current->second.get());
    }
    else {
        IfcRectangleProfileDef *ret = static_cast< IfcRectangleProfileDef * > (allocateIfcRectangleProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRectangleProfileDef(IfcRectangleProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRectangleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRectangleProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangleProfileDef > ExpressDataSet::createIfcRectangleProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcRectangleProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRectangleProfileDef * > (allocateIfcRectangleProfileDef(this, Step::Id_UNSET));
    }
}

IfcRectangleProfileDef *ExpressDataSet::cloneIfcRectangleProfileDef(ExpressDataSet *expressDataSet, const IfcRectangleProfileDef &obj, const CopyOp &copyop) {
    IfcRectangleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangleProfileDef *ExpressDataSet::cloneIfcRectangleProfileDef(const IfcRectangleProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRectangleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRectangleProfileDef(this, obj, copyop);
    }
}

IfcRectangularPyramid *ExpressDataSet::getIfcRectangularPyramid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRectangularPyramid * > (current->second.get());
    }
    else {
        IfcRectangularPyramid *ret = static_cast< IfcRectangularPyramid * > (allocateIfcRectangularPyramid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRectangularPyramid(IfcRectangularPyramid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRectangularPyramid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangularPyramid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRectangularPyramid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangularPyramid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangularPyramid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangularPyramid > ExpressDataSet::createIfcRectangularPyramid(bool isVolatile) {
    if (isVolatile) {
        return new IfcRectangularPyramid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRectangularPyramid * > (allocateIfcRectangularPyramid(this, Step::Id_UNSET));
    }
}

IfcRectangularPyramid *ExpressDataSet::cloneIfcRectangularPyramid(ExpressDataSet *expressDataSet, const IfcRectangularPyramid &obj, const CopyOp &copyop) {
    IfcRectangularPyramid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangularPyramid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangularPyramid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangularPyramid *ExpressDataSet::cloneIfcRectangularPyramid(const IfcRectangularPyramid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRectangularPyramid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRectangularPyramid(this, obj, copyop);
    }
}

IfcRectangularTrimmedSurface *ExpressDataSet::getIfcRectangularTrimmedSurface(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRectangularTrimmedSurface * > (current->second.get());
    }
    else {
        IfcRectangularTrimmedSurface *ret = static_cast< IfcRectangularTrimmedSurface * > (allocateIfcRectangularTrimmedSurface(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRectangularTrimmedSurface(IfcRectangularTrimmedSurface *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRectangularTrimmedSurface_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRectangularTrimmedSurface(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRectangularTrimmedSurface *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRectangularTrimmedSurface(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRectangularTrimmedSurface_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRectangularTrimmedSurface > ExpressDataSet::createIfcRectangularTrimmedSurface(bool isVolatile) {
    if (isVolatile) {
        return new IfcRectangularTrimmedSurface(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRectangularTrimmedSurface * > (allocateIfcRectangularTrimmedSurface(this, Step::Id_UNSET));
    }
}

IfcRectangularTrimmedSurface *ExpressDataSet::cloneIfcRectangularTrimmedSurface(ExpressDataSet *expressDataSet, const IfcRectangularTrimmedSurface &obj, const CopyOp &copyop) {
    IfcRectangularTrimmedSurface *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRectangularTrimmedSurface(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRectangularTrimmedSurface_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRectangularTrimmedSurface *ExpressDataSet::cloneIfcRectangularTrimmedSurface(const IfcRectangularTrimmedSurface &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRectangularTrimmedSurface(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRectangularTrimmedSurface(this, obj, copyop);
    }
}

IfcReferencesValueDocument *ExpressDataSet::getIfcReferencesValueDocument(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcReferencesValueDocument * > (current->second.get());
    }
    else {
        IfcReferencesValueDocument *ret = static_cast< IfcReferencesValueDocument * > (allocateIfcReferencesValueDocument(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcReferencesValueDocument(IfcReferencesValueDocument *arg) {
    getAll().erase(arg->getKey());
    return m_IfcReferencesValueDocument_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReferencesValueDocument(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcReferencesValueDocument *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReferencesValueDocument(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReferencesValueDocument_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReferencesValueDocument > ExpressDataSet::createIfcReferencesValueDocument(bool isVolatile) {
    if (isVolatile) {
        return new IfcReferencesValueDocument(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcReferencesValueDocument * > (allocateIfcReferencesValueDocument(this, Step::Id_UNSET));
    }
}

IfcReferencesValueDocument *ExpressDataSet::cloneIfcReferencesValueDocument(ExpressDataSet *expressDataSet, const IfcReferencesValueDocument &obj, const CopyOp &copyop) {
    IfcReferencesValueDocument *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReferencesValueDocument(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReferencesValueDocument_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReferencesValueDocument *ExpressDataSet::cloneIfcReferencesValueDocument(const IfcReferencesValueDocument &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcReferencesValueDocument(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcReferencesValueDocument(this, obj, copyop);
    }
}

IfcRegularTimeSeries *ExpressDataSet::getIfcRegularTimeSeries(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRegularTimeSeries * > (current->second.get());
    }
    else {
        IfcRegularTimeSeries *ret = static_cast< IfcRegularTimeSeries * > (allocateIfcRegularTimeSeries(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRegularTimeSeries(IfcRegularTimeSeries *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRegularTimeSeries_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRegularTimeSeries(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRegularTimeSeries *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRegularTimeSeries(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRegularTimeSeries_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRegularTimeSeries > ExpressDataSet::createIfcRegularTimeSeries(bool isVolatile) {
    if (isVolatile) {
        return new IfcRegularTimeSeries(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRegularTimeSeries * > (allocateIfcRegularTimeSeries(this, Step::Id_UNSET));
    }
}

IfcRegularTimeSeries *ExpressDataSet::cloneIfcRegularTimeSeries(ExpressDataSet *expressDataSet, const IfcRegularTimeSeries &obj, const CopyOp &copyop) {
    IfcRegularTimeSeries *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRegularTimeSeries(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRegularTimeSeries_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRegularTimeSeries *ExpressDataSet::cloneIfcRegularTimeSeries(const IfcRegularTimeSeries &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRegularTimeSeries(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRegularTimeSeries(this, obj, copyop);
    }
}

IfcReinforcementBarProperties *ExpressDataSet::getIfcReinforcementBarProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcReinforcementBarProperties * > (current->second.get());
    }
    else {
        IfcReinforcementBarProperties *ret = static_cast< IfcReinforcementBarProperties * > (allocateIfcReinforcementBarProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcReinforcementBarProperties(IfcReinforcementBarProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcReinforcementBarProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcementBarProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcReinforcementBarProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcementBarProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcementBarProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcementBarProperties > ExpressDataSet::createIfcReinforcementBarProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcReinforcementBarProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcReinforcementBarProperties * > (allocateIfcReinforcementBarProperties(this, Step::Id_UNSET));
    }
}

IfcReinforcementBarProperties *ExpressDataSet::cloneIfcReinforcementBarProperties(ExpressDataSet *expressDataSet, const IfcReinforcementBarProperties &obj, const CopyOp &copyop) {
    IfcReinforcementBarProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcementBarProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcementBarProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcementBarProperties *ExpressDataSet::cloneIfcReinforcementBarProperties(const IfcReinforcementBarProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcReinforcementBarProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcReinforcementBarProperties(this, obj, copyop);
    }
}

IfcReinforcementDefinitionProperties *ExpressDataSet::getIfcReinforcementDefinitionProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcReinforcementDefinitionProperties * > (current->second.get());
    }
    else {
        IfcReinforcementDefinitionProperties *ret = static_cast< IfcReinforcementDefinitionProperties * > (allocateIfcReinforcementDefinitionProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcReinforcementDefinitionProperties(IfcReinforcementDefinitionProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcReinforcementDefinitionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcementDefinitionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcReinforcementDefinitionProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcementDefinitionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcementDefinitionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcementDefinitionProperties > ExpressDataSet::createIfcReinforcementDefinitionProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcReinforcementDefinitionProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcReinforcementDefinitionProperties * > (allocateIfcReinforcementDefinitionProperties(this, Step::Id_UNSET));
    }
}

IfcReinforcementDefinitionProperties *ExpressDataSet::cloneIfcReinforcementDefinitionProperties(ExpressDataSet *expressDataSet, const IfcReinforcementDefinitionProperties &obj, const CopyOp &copyop) {
    IfcReinforcementDefinitionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcementDefinitionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcementDefinitionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcementDefinitionProperties *ExpressDataSet::cloneIfcReinforcementDefinitionProperties(const IfcReinforcementDefinitionProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcReinforcementDefinitionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcReinforcementDefinitionProperties(this, obj, copyop);
    }
}

IfcReinforcingBar *ExpressDataSet::getIfcReinforcingBar(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcReinforcingBar * > (current->second.get());
    }
    else {
        IfcReinforcingBar *ret = static_cast< IfcReinforcingBar * > (allocateIfcReinforcingBar(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcReinforcingBar(IfcReinforcingBar *arg) {
    getAll().erase(arg->getKey());
    return m_IfcReinforcingBar_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcingBar(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcReinforcingBar *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcingBar(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcingBar_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcingBar > ExpressDataSet::createIfcReinforcingBar(bool isVolatile) {
    if (isVolatile) {
        return new IfcReinforcingBar(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcReinforcingBar * > (allocateIfcReinforcingBar(this, Step::Id_UNSET));
    }
}

IfcReinforcingBar *ExpressDataSet::cloneIfcReinforcingBar(ExpressDataSet *expressDataSet, const IfcReinforcingBar &obj, const CopyOp &copyop) {
    IfcReinforcingBar *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcingBar(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcingBar_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcingBar *ExpressDataSet::cloneIfcReinforcingBar(const IfcReinforcingBar &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcReinforcingBar(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcReinforcingBar(this, obj, copyop);
    }
}

IfcReinforcingMesh *ExpressDataSet::getIfcReinforcingMesh(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcReinforcingMesh * > (current->second.get());
    }
    else {
        IfcReinforcingMesh *ret = static_cast< IfcReinforcingMesh * > (allocateIfcReinforcingMesh(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcReinforcingMesh(IfcReinforcingMesh *arg) {
    getAll().erase(arg->getKey());
    return m_IfcReinforcingMesh_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcReinforcingMesh(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcReinforcingMesh *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcReinforcingMesh(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcReinforcingMesh_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcReinforcingMesh > ExpressDataSet::createIfcReinforcingMesh(bool isVolatile) {
    if (isVolatile) {
        return new IfcReinforcingMesh(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcReinforcingMesh * > (allocateIfcReinforcingMesh(this, Step::Id_UNSET));
    }
}

IfcReinforcingMesh *ExpressDataSet::cloneIfcReinforcingMesh(ExpressDataSet *expressDataSet, const IfcReinforcingMesh &obj, const CopyOp &copyop) {
    IfcReinforcingMesh *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcReinforcingMesh(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcReinforcingMesh_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcReinforcingMesh *ExpressDataSet::cloneIfcReinforcingMesh(const IfcReinforcingMesh &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcReinforcingMesh(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcReinforcingMesh(this, obj, copyop);
    }
}

IfcRelAggregates *ExpressDataSet::getIfcRelAggregates(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAggregates * > (current->second.get());
    }
    else {
        IfcRelAggregates *ret = static_cast< IfcRelAggregates * > (allocateIfcRelAggregates(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAggregates(IfcRelAggregates *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAggregates_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAggregates(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAggregates *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAggregates(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAggregates_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAggregates > ExpressDataSet::createIfcRelAggregates(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAggregates(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAggregates * > (allocateIfcRelAggregates(this, Step::Id_UNSET));
    }
}

IfcRelAggregates *ExpressDataSet::cloneIfcRelAggregates(ExpressDataSet *expressDataSet, const IfcRelAggregates &obj, const CopyOp &copyop) {
    IfcRelAggregates *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAggregates(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAggregates_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAggregates *ExpressDataSet::cloneIfcRelAggregates(const IfcRelAggregates &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAggregates(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAggregates(this, obj, copyop);
    }
}

IfcRelAssignsTasks *ExpressDataSet::getIfcRelAssignsTasks(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsTasks * > (current->second.get());
    }
    else {
        IfcRelAssignsTasks *ret = static_cast< IfcRelAssignsTasks * > (allocateIfcRelAssignsTasks(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsTasks(IfcRelAssignsTasks *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsTasks_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsTasks(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsTasks *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsTasks(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsTasks_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsTasks > ExpressDataSet::createIfcRelAssignsTasks(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsTasks(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsTasks * > (allocateIfcRelAssignsTasks(this, Step::Id_UNSET));
    }
}

IfcRelAssignsTasks *ExpressDataSet::cloneIfcRelAssignsTasks(ExpressDataSet *expressDataSet, const IfcRelAssignsTasks &obj, const CopyOp &copyop) {
    IfcRelAssignsTasks *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsTasks(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsTasks_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsTasks *ExpressDataSet::cloneIfcRelAssignsTasks(const IfcRelAssignsTasks &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsTasks(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsTasks(this, obj, copyop);
    }
}

IfcRelAssignsToActor *ExpressDataSet::getIfcRelAssignsToActor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToActor * > (current->second.get());
    }
    else {
        IfcRelAssignsToActor *ret = static_cast< IfcRelAssignsToActor * > (allocateIfcRelAssignsToActor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToActor(IfcRelAssignsToActor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToActor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToActor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToActor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToActor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToActor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToActor > ExpressDataSet::createIfcRelAssignsToActor(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToActor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToActor * > (allocateIfcRelAssignsToActor(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToActor *ExpressDataSet::cloneIfcRelAssignsToActor(ExpressDataSet *expressDataSet, const IfcRelAssignsToActor &obj, const CopyOp &copyop) {
    IfcRelAssignsToActor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToActor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToActor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToActor *ExpressDataSet::cloneIfcRelAssignsToActor(const IfcRelAssignsToActor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToActor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToActor(this, obj, copyop);
    }
}

IfcRelAssignsToControl *ExpressDataSet::getIfcRelAssignsToControl(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToControl * > (current->second.get());
    }
    else {
        IfcRelAssignsToControl *ret = static_cast< IfcRelAssignsToControl * > (allocateIfcRelAssignsToControl(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToControl(IfcRelAssignsToControl *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToControl *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToControl > ExpressDataSet::createIfcRelAssignsToControl(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToControl(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToControl * > (allocateIfcRelAssignsToControl(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToControl *ExpressDataSet::cloneIfcRelAssignsToControl(ExpressDataSet *expressDataSet, const IfcRelAssignsToControl &obj, const CopyOp &copyop) {
    IfcRelAssignsToControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToControl *ExpressDataSet::cloneIfcRelAssignsToControl(const IfcRelAssignsToControl &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToControl(this, obj, copyop);
    }
}

IfcRelAssignsToGroup *ExpressDataSet::getIfcRelAssignsToGroup(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToGroup * > (current->second.get());
    }
    else {
        IfcRelAssignsToGroup *ret = static_cast< IfcRelAssignsToGroup * > (allocateIfcRelAssignsToGroup(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToGroup(IfcRelAssignsToGroup *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToGroup *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToGroup > ExpressDataSet::createIfcRelAssignsToGroup(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToGroup(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToGroup * > (allocateIfcRelAssignsToGroup(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToGroup *ExpressDataSet::cloneIfcRelAssignsToGroup(ExpressDataSet *expressDataSet, const IfcRelAssignsToGroup &obj, const CopyOp &copyop) {
    IfcRelAssignsToGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToGroup *ExpressDataSet::cloneIfcRelAssignsToGroup(const IfcRelAssignsToGroup &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToGroup(this, obj, copyop);
    }
}

IfcRelAssignsToProcess *ExpressDataSet::getIfcRelAssignsToProcess(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToProcess * > (current->second.get());
    }
    else {
        IfcRelAssignsToProcess *ret = static_cast< IfcRelAssignsToProcess * > (allocateIfcRelAssignsToProcess(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToProcess(IfcRelAssignsToProcess *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProcess_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProcess(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToProcess *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProcess(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProcess_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProcess > ExpressDataSet::createIfcRelAssignsToProcess(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToProcess(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToProcess * > (allocateIfcRelAssignsToProcess(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProcess *ExpressDataSet::cloneIfcRelAssignsToProcess(ExpressDataSet *expressDataSet, const IfcRelAssignsToProcess &obj, const CopyOp &copyop) {
    IfcRelAssignsToProcess *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProcess(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProcess_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProcess *ExpressDataSet::cloneIfcRelAssignsToProcess(const IfcRelAssignsToProcess &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToProcess(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToProcess(this, obj, copyop);
    }
}

IfcRelAssignsToProduct *ExpressDataSet::getIfcRelAssignsToProduct(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToProduct * > (current->second.get());
    }
    else {
        IfcRelAssignsToProduct *ret = static_cast< IfcRelAssignsToProduct * > (allocateIfcRelAssignsToProduct(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToProduct(IfcRelAssignsToProduct *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProduct_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProduct(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToProduct *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProduct(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProduct_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProduct > ExpressDataSet::createIfcRelAssignsToProduct(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToProduct(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToProduct * > (allocateIfcRelAssignsToProduct(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProduct *ExpressDataSet::cloneIfcRelAssignsToProduct(ExpressDataSet *expressDataSet, const IfcRelAssignsToProduct &obj, const CopyOp &copyop) {
    IfcRelAssignsToProduct *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProduct(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProduct_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProduct *ExpressDataSet::cloneIfcRelAssignsToProduct(const IfcRelAssignsToProduct &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToProduct(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToProduct(this, obj, copyop);
    }
}

IfcRelAssignsToProjectOrder *ExpressDataSet::getIfcRelAssignsToProjectOrder(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToProjectOrder * > (current->second.get());
    }
    else {
        IfcRelAssignsToProjectOrder *ret = static_cast< IfcRelAssignsToProjectOrder * > (allocateIfcRelAssignsToProjectOrder(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToProjectOrder(IfcRelAssignsToProjectOrder *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToProjectOrder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToProjectOrder(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToProjectOrder *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToProjectOrder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToProjectOrder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToProjectOrder > ExpressDataSet::createIfcRelAssignsToProjectOrder(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToProjectOrder(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToProjectOrder * > (allocateIfcRelAssignsToProjectOrder(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToProjectOrder *ExpressDataSet::cloneIfcRelAssignsToProjectOrder(ExpressDataSet *expressDataSet, const IfcRelAssignsToProjectOrder &obj, const CopyOp &copyop) {
    IfcRelAssignsToProjectOrder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToProjectOrder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToProjectOrder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToProjectOrder *ExpressDataSet::cloneIfcRelAssignsToProjectOrder(const IfcRelAssignsToProjectOrder &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToProjectOrder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToProjectOrder(this, obj, copyop);
    }
}

IfcRelAssignsToResource *ExpressDataSet::getIfcRelAssignsToResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssignsToResource * > (current->second.get());
    }
    else {
        IfcRelAssignsToResource *ret = static_cast< IfcRelAssignsToResource * > (allocateIfcRelAssignsToResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssignsToResource(IfcRelAssignsToResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssignsToResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssignsToResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssignsToResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssignsToResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssignsToResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssignsToResource > ExpressDataSet::createIfcRelAssignsToResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssignsToResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssignsToResource * > (allocateIfcRelAssignsToResource(this, Step::Id_UNSET));
    }
}

IfcRelAssignsToResource *ExpressDataSet::cloneIfcRelAssignsToResource(ExpressDataSet *expressDataSet, const IfcRelAssignsToResource &obj, const CopyOp &copyop) {
    IfcRelAssignsToResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssignsToResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssignsToResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssignsToResource *ExpressDataSet::cloneIfcRelAssignsToResource(const IfcRelAssignsToResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssignsToResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssignsToResource(this, obj, copyop);
    }
}

IfcRelAssociates *ExpressDataSet::getIfcRelAssociates(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociates * > (current->second.get());
    }
    else {
        IfcRelAssociates *ret = static_cast< IfcRelAssociates * > (allocateIfcRelAssociates(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociates(IfcRelAssociates *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociates_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociates(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociates *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociates(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociates_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociates > ExpressDataSet::createIfcRelAssociates(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociates(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociates * > (allocateIfcRelAssociates(this, Step::Id_UNSET));
    }
}

IfcRelAssociates *ExpressDataSet::cloneIfcRelAssociates(ExpressDataSet *expressDataSet, const IfcRelAssociates &obj, const CopyOp &copyop) {
    IfcRelAssociates *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociates(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociates_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociates *ExpressDataSet::cloneIfcRelAssociates(const IfcRelAssociates &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociates(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociates(this, obj, copyop);
    }
}

IfcRelAssociatesAppliedValue *ExpressDataSet::getIfcRelAssociatesAppliedValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesAppliedValue * > (current->second.get());
    }
    else {
        IfcRelAssociatesAppliedValue *ret = static_cast< IfcRelAssociatesAppliedValue * > (allocateIfcRelAssociatesAppliedValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesAppliedValue(IfcRelAssociatesAppliedValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesAppliedValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesAppliedValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesAppliedValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesAppliedValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesAppliedValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesAppliedValue > ExpressDataSet::createIfcRelAssociatesAppliedValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesAppliedValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesAppliedValue * > (allocateIfcRelAssociatesAppliedValue(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesAppliedValue *ExpressDataSet::cloneIfcRelAssociatesAppliedValue(ExpressDataSet *expressDataSet, const IfcRelAssociatesAppliedValue &obj, const CopyOp &copyop) {
    IfcRelAssociatesAppliedValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesAppliedValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesAppliedValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesAppliedValue *ExpressDataSet::cloneIfcRelAssociatesAppliedValue(const IfcRelAssociatesAppliedValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesAppliedValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesAppliedValue(this, obj, copyop);
    }
}

IfcRelAssociatesApproval *ExpressDataSet::getIfcRelAssociatesApproval(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesApproval * > (current->second.get());
    }
    else {
        IfcRelAssociatesApproval *ret = static_cast< IfcRelAssociatesApproval * > (allocateIfcRelAssociatesApproval(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesApproval(IfcRelAssociatesApproval *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesApproval_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesApproval(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesApproval *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesApproval(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesApproval_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesApproval > ExpressDataSet::createIfcRelAssociatesApproval(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesApproval(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesApproval * > (allocateIfcRelAssociatesApproval(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesApproval *ExpressDataSet::cloneIfcRelAssociatesApproval(ExpressDataSet *expressDataSet, const IfcRelAssociatesApproval &obj, const CopyOp &copyop) {
    IfcRelAssociatesApproval *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesApproval(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesApproval_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesApproval *ExpressDataSet::cloneIfcRelAssociatesApproval(const IfcRelAssociatesApproval &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesApproval(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesApproval(this, obj, copyop);
    }
}

IfcRelAssociatesClassification *ExpressDataSet::getIfcRelAssociatesClassification(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesClassification * > (current->second.get());
    }
    else {
        IfcRelAssociatesClassification *ret = static_cast< IfcRelAssociatesClassification * > (allocateIfcRelAssociatesClassification(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesClassification(IfcRelAssociatesClassification *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesClassification_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesClassification(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesClassification *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesClassification(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesClassification_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesClassification > ExpressDataSet::createIfcRelAssociatesClassification(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesClassification(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesClassification * > (allocateIfcRelAssociatesClassification(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesClassification *ExpressDataSet::cloneIfcRelAssociatesClassification(ExpressDataSet *expressDataSet, const IfcRelAssociatesClassification &obj, const CopyOp &copyop) {
    IfcRelAssociatesClassification *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesClassification(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesClassification_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesClassification *ExpressDataSet::cloneIfcRelAssociatesClassification(const IfcRelAssociatesClassification &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesClassification(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesClassification(this, obj, copyop);
    }
}

IfcRelAssociatesConstraint *ExpressDataSet::getIfcRelAssociatesConstraint(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesConstraint * > (current->second.get());
    }
    else {
        IfcRelAssociatesConstraint *ret = static_cast< IfcRelAssociatesConstraint * > (allocateIfcRelAssociatesConstraint(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesConstraint(IfcRelAssociatesConstraint *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesConstraint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesConstraint(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesConstraint *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesConstraint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesConstraint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesConstraint > ExpressDataSet::createIfcRelAssociatesConstraint(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesConstraint(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesConstraint * > (allocateIfcRelAssociatesConstraint(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesConstraint *ExpressDataSet::cloneIfcRelAssociatesConstraint(ExpressDataSet *expressDataSet, const IfcRelAssociatesConstraint &obj, const CopyOp &copyop) {
    IfcRelAssociatesConstraint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesConstraint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesConstraint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesConstraint *ExpressDataSet::cloneIfcRelAssociatesConstraint(const IfcRelAssociatesConstraint &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesConstraint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesConstraint(this, obj, copyop);
    }
}

IfcRelAssociatesDocument *ExpressDataSet::getIfcRelAssociatesDocument(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesDocument * > (current->second.get());
    }
    else {
        IfcRelAssociatesDocument *ret = static_cast< IfcRelAssociatesDocument * > (allocateIfcRelAssociatesDocument(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesDocument(IfcRelAssociatesDocument *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesDocument_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesDocument(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesDocument *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesDocument(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesDocument_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesDocument > ExpressDataSet::createIfcRelAssociatesDocument(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesDocument(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesDocument * > (allocateIfcRelAssociatesDocument(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesDocument *ExpressDataSet::cloneIfcRelAssociatesDocument(ExpressDataSet *expressDataSet, const IfcRelAssociatesDocument &obj, const CopyOp &copyop) {
    IfcRelAssociatesDocument *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesDocument(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesDocument_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesDocument *ExpressDataSet::cloneIfcRelAssociatesDocument(const IfcRelAssociatesDocument &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesDocument(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesDocument(this, obj, copyop);
    }
}

IfcRelAssociatesLibrary *ExpressDataSet::getIfcRelAssociatesLibrary(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesLibrary * > (current->second.get());
    }
    else {
        IfcRelAssociatesLibrary *ret = static_cast< IfcRelAssociatesLibrary * > (allocateIfcRelAssociatesLibrary(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesLibrary(IfcRelAssociatesLibrary *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesLibrary_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesLibrary(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesLibrary *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesLibrary(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesLibrary_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesLibrary > ExpressDataSet::createIfcRelAssociatesLibrary(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesLibrary(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesLibrary * > (allocateIfcRelAssociatesLibrary(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesLibrary *ExpressDataSet::cloneIfcRelAssociatesLibrary(ExpressDataSet *expressDataSet, const IfcRelAssociatesLibrary &obj, const CopyOp &copyop) {
    IfcRelAssociatesLibrary *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesLibrary(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesLibrary_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesLibrary *ExpressDataSet::cloneIfcRelAssociatesLibrary(const IfcRelAssociatesLibrary &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesLibrary(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesLibrary(this, obj, copyop);
    }
}

IfcRelAssociatesMaterial *ExpressDataSet::getIfcRelAssociatesMaterial(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesMaterial * > (current->second.get());
    }
    else {
        IfcRelAssociatesMaterial *ret = static_cast< IfcRelAssociatesMaterial * > (allocateIfcRelAssociatesMaterial(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesMaterial(IfcRelAssociatesMaterial *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesMaterial_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesMaterial(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesMaterial *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesMaterial(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesMaterial_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesMaterial > ExpressDataSet::createIfcRelAssociatesMaterial(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesMaterial(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesMaterial * > (allocateIfcRelAssociatesMaterial(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesMaterial *ExpressDataSet::cloneIfcRelAssociatesMaterial(ExpressDataSet *expressDataSet, const IfcRelAssociatesMaterial &obj, const CopyOp &copyop) {
    IfcRelAssociatesMaterial *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesMaterial(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesMaterial_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesMaterial *ExpressDataSet::cloneIfcRelAssociatesMaterial(const IfcRelAssociatesMaterial &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesMaterial(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesMaterial(this, obj, copyop);
    }
}

IfcRelAssociatesProfileProperties *ExpressDataSet::getIfcRelAssociatesProfileProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelAssociatesProfileProperties * > (current->second.get());
    }
    else {
        IfcRelAssociatesProfileProperties *ret = static_cast< IfcRelAssociatesProfileProperties * > (allocateIfcRelAssociatesProfileProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelAssociatesProfileProperties(IfcRelAssociatesProfileProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelAssociatesProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelAssociatesProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelAssociatesProfileProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelAssociatesProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelAssociatesProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelAssociatesProfileProperties > ExpressDataSet::createIfcRelAssociatesProfileProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelAssociatesProfileProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelAssociatesProfileProperties * > (allocateIfcRelAssociatesProfileProperties(this, Step::Id_UNSET));
    }
}

IfcRelAssociatesProfileProperties *ExpressDataSet::cloneIfcRelAssociatesProfileProperties(ExpressDataSet *expressDataSet, const IfcRelAssociatesProfileProperties &obj, const CopyOp &copyop) {
    IfcRelAssociatesProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelAssociatesProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelAssociatesProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelAssociatesProfileProperties *ExpressDataSet::cloneIfcRelAssociatesProfileProperties(const IfcRelAssociatesProfileProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelAssociatesProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelAssociatesProfileProperties(this, obj, copyop);
    }
}

IfcRelConnectsElements *ExpressDataSet::getIfcRelConnectsElements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsElements * > (current->second.get());
    }
    else {
        IfcRelConnectsElements *ret = static_cast< IfcRelConnectsElements * > (allocateIfcRelConnectsElements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsElements(IfcRelConnectsElements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsElements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsElements > ExpressDataSet::createIfcRelConnectsElements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsElements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsElements * > (allocateIfcRelConnectsElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsElements *ExpressDataSet::cloneIfcRelConnectsElements(ExpressDataSet *expressDataSet, const IfcRelConnectsElements &obj, const CopyOp &copyop) {
    IfcRelConnectsElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsElements *ExpressDataSet::cloneIfcRelConnectsElements(const IfcRelConnectsElements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsElements(this, obj, copyop);
    }
}

IfcRelConnectsPathElements *ExpressDataSet::getIfcRelConnectsPathElements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsPathElements * > (current->second.get());
    }
    else {
        IfcRelConnectsPathElements *ret = static_cast< IfcRelConnectsPathElements * > (allocateIfcRelConnectsPathElements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsPathElements(IfcRelConnectsPathElements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPathElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPathElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsPathElements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPathElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPathElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPathElements > ExpressDataSet::createIfcRelConnectsPathElements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsPathElements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsPathElements * > (allocateIfcRelConnectsPathElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPathElements *ExpressDataSet::cloneIfcRelConnectsPathElements(ExpressDataSet *expressDataSet, const IfcRelConnectsPathElements &obj, const CopyOp &copyop) {
    IfcRelConnectsPathElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPathElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPathElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPathElements *ExpressDataSet::cloneIfcRelConnectsPathElements(const IfcRelConnectsPathElements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsPathElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsPathElements(this, obj, copyop);
    }
}

IfcRelConnectsPortToElement *ExpressDataSet::getIfcRelConnectsPortToElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsPortToElement * > (current->second.get());
    }
    else {
        IfcRelConnectsPortToElement *ret = static_cast< IfcRelConnectsPortToElement * > (allocateIfcRelConnectsPortToElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsPortToElement(IfcRelConnectsPortToElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPortToElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPortToElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsPortToElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPortToElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPortToElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPortToElement > ExpressDataSet::createIfcRelConnectsPortToElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsPortToElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsPortToElement * > (allocateIfcRelConnectsPortToElement(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPortToElement *ExpressDataSet::cloneIfcRelConnectsPortToElement(ExpressDataSet *expressDataSet, const IfcRelConnectsPortToElement &obj, const CopyOp &copyop) {
    IfcRelConnectsPortToElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPortToElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPortToElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPortToElement *ExpressDataSet::cloneIfcRelConnectsPortToElement(const IfcRelConnectsPortToElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsPortToElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsPortToElement(this, obj, copyop);
    }
}

IfcRelConnectsPorts *ExpressDataSet::getIfcRelConnectsPorts(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsPorts * > (current->second.get());
    }
    else {
        IfcRelConnectsPorts *ret = static_cast< IfcRelConnectsPorts * > (allocateIfcRelConnectsPorts(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsPorts(IfcRelConnectsPorts *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsPorts_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsPorts(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsPorts *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsPorts(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsPorts_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsPorts > ExpressDataSet::createIfcRelConnectsPorts(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsPorts(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsPorts * > (allocateIfcRelConnectsPorts(this, Step::Id_UNSET));
    }
}

IfcRelConnectsPorts *ExpressDataSet::cloneIfcRelConnectsPorts(ExpressDataSet *expressDataSet, const IfcRelConnectsPorts &obj, const CopyOp &copyop) {
    IfcRelConnectsPorts *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsPorts(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsPorts_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsPorts *ExpressDataSet::cloneIfcRelConnectsPorts(const IfcRelConnectsPorts &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsPorts(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsPorts(this, obj, copyop);
    }
}

IfcRelConnectsStructuralActivity *ExpressDataSet::getIfcRelConnectsStructuralActivity(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsStructuralActivity * > (current->second.get());
    }
    else {
        IfcRelConnectsStructuralActivity *ret = static_cast< IfcRelConnectsStructuralActivity * > (allocateIfcRelConnectsStructuralActivity(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsStructuralActivity(IfcRelConnectsStructuralActivity *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralActivity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralActivity(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsStructuralActivity *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralActivity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralActivity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralActivity > ExpressDataSet::createIfcRelConnectsStructuralActivity(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsStructuralActivity(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsStructuralActivity * > (allocateIfcRelConnectsStructuralActivity(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralActivity *ExpressDataSet::cloneIfcRelConnectsStructuralActivity(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralActivity &obj, const CopyOp &copyop) {
    IfcRelConnectsStructuralActivity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralActivity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralActivity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralActivity *ExpressDataSet::cloneIfcRelConnectsStructuralActivity(const IfcRelConnectsStructuralActivity &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsStructuralActivity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsStructuralActivity(this, obj, copyop);
    }
}

IfcRelConnectsStructuralElement *ExpressDataSet::getIfcRelConnectsStructuralElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsStructuralElement * > (current->second.get());
    }
    else {
        IfcRelConnectsStructuralElement *ret = static_cast< IfcRelConnectsStructuralElement * > (allocateIfcRelConnectsStructuralElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsStructuralElement(IfcRelConnectsStructuralElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsStructuralElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralElement > ExpressDataSet::createIfcRelConnectsStructuralElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsStructuralElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsStructuralElement * > (allocateIfcRelConnectsStructuralElement(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralElement *ExpressDataSet::cloneIfcRelConnectsStructuralElement(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralElement &obj, const CopyOp &copyop) {
    IfcRelConnectsStructuralElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralElement *ExpressDataSet::cloneIfcRelConnectsStructuralElement(const IfcRelConnectsStructuralElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsStructuralElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsStructuralElement(this, obj, copyop);
    }
}

IfcRelConnectsStructuralMember *ExpressDataSet::getIfcRelConnectsStructuralMember(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsStructuralMember * > (current->second.get());
    }
    else {
        IfcRelConnectsStructuralMember *ret = static_cast< IfcRelConnectsStructuralMember * > (allocateIfcRelConnectsStructuralMember(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsStructuralMember(IfcRelConnectsStructuralMember *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsStructuralMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsStructuralMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsStructuralMember *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsStructuralMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsStructuralMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsStructuralMember > ExpressDataSet::createIfcRelConnectsStructuralMember(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsStructuralMember(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsStructuralMember * > (allocateIfcRelConnectsStructuralMember(this, Step::Id_UNSET));
    }
}

IfcRelConnectsStructuralMember *ExpressDataSet::cloneIfcRelConnectsStructuralMember(ExpressDataSet *expressDataSet, const IfcRelConnectsStructuralMember &obj, const CopyOp &copyop) {
    IfcRelConnectsStructuralMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsStructuralMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsStructuralMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsStructuralMember *ExpressDataSet::cloneIfcRelConnectsStructuralMember(const IfcRelConnectsStructuralMember &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsStructuralMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsStructuralMember(this, obj, copyop);
    }
}

IfcRelConnectsWithEccentricity *ExpressDataSet::getIfcRelConnectsWithEccentricity(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsWithEccentricity * > (current->second.get());
    }
    else {
        IfcRelConnectsWithEccentricity *ret = static_cast< IfcRelConnectsWithEccentricity * > (allocateIfcRelConnectsWithEccentricity(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsWithEccentricity(IfcRelConnectsWithEccentricity *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsWithEccentricity_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsWithEccentricity(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsWithEccentricity *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsWithEccentricity(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsWithEccentricity_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsWithEccentricity > ExpressDataSet::createIfcRelConnectsWithEccentricity(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsWithEccentricity(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsWithEccentricity * > (allocateIfcRelConnectsWithEccentricity(this, Step::Id_UNSET));
    }
}

IfcRelConnectsWithEccentricity *ExpressDataSet::cloneIfcRelConnectsWithEccentricity(ExpressDataSet *expressDataSet, const IfcRelConnectsWithEccentricity &obj, const CopyOp &copyop) {
    IfcRelConnectsWithEccentricity *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsWithEccentricity(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsWithEccentricity_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsWithEccentricity *ExpressDataSet::cloneIfcRelConnectsWithEccentricity(const IfcRelConnectsWithEccentricity &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsWithEccentricity(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsWithEccentricity(this, obj, copyop);
    }
}

IfcRelConnectsWithRealizingElements *ExpressDataSet::getIfcRelConnectsWithRealizingElements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelConnectsWithRealizingElements * > (current->second.get());
    }
    else {
        IfcRelConnectsWithRealizingElements *ret = static_cast< IfcRelConnectsWithRealizingElements * > (allocateIfcRelConnectsWithRealizingElements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelConnectsWithRealizingElements(IfcRelConnectsWithRealizingElements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelConnectsWithRealizingElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelConnectsWithRealizingElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelConnectsWithRealizingElements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelConnectsWithRealizingElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelConnectsWithRealizingElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelConnectsWithRealizingElements > ExpressDataSet::createIfcRelConnectsWithRealizingElements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelConnectsWithRealizingElements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelConnectsWithRealizingElements * > (allocateIfcRelConnectsWithRealizingElements(this, Step::Id_UNSET));
    }
}

IfcRelConnectsWithRealizingElements *ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(ExpressDataSet *expressDataSet, const IfcRelConnectsWithRealizingElements &obj, const CopyOp &copyop) {
    IfcRelConnectsWithRealizingElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelConnectsWithRealizingElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelConnectsWithRealizingElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelConnectsWithRealizingElements *ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(const IfcRelConnectsWithRealizingElements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelConnectsWithRealizingElements(this, obj, copyop);
    }
}

IfcRelContainedInSpatialStructure *ExpressDataSet::getIfcRelContainedInSpatialStructure(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelContainedInSpatialStructure * > (current->second.get());
    }
    else {
        IfcRelContainedInSpatialStructure *ret = static_cast< IfcRelContainedInSpatialStructure * > (allocateIfcRelContainedInSpatialStructure(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelContainedInSpatialStructure(IfcRelContainedInSpatialStructure *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelContainedInSpatialStructure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelContainedInSpatialStructure(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelContainedInSpatialStructure *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelContainedInSpatialStructure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelContainedInSpatialStructure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelContainedInSpatialStructure > ExpressDataSet::createIfcRelContainedInSpatialStructure(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelContainedInSpatialStructure(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelContainedInSpatialStructure * > (allocateIfcRelContainedInSpatialStructure(this, Step::Id_UNSET));
    }
}

IfcRelContainedInSpatialStructure *ExpressDataSet::cloneIfcRelContainedInSpatialStructure(ExpressDataSet *expressDataSet, const IfcRelContainedInSpatialStructure &obj, const CopyOp &copyop) {
    IfcRelContainedInSpatialStructure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelContainedInSpatialStructure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelContainedInSpatialStructure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelContainedInSpatialStructure *ExpressDataSet::cloneIfcRelContainedInSpatialStructure(const IfcRelContainedInSpatialStructure &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelContainedInSpatialStructure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelContainedInSpatialStructure(this, obj, copyop);
    }
}

IfcRelCoversBldgElements *ExpressDataSet::getIfcRelCoversBldgElements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelCoversBldgElements * > (current->second.get());
    }
    else {
        IfcRelCoversBldgElements *ret = static_cast< IfcRelCoversBldgElements * > (allocateIfcRelCoversBldgElements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelCoversBldgElements(IfcRelCoversBldgElements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelCoversBldgElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelCoversBldgElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelCoversBldgElements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelCoversBldgElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelCoversBldgElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelCoversBldgElements > ExpressDataSet::createIfcRelCoversBldgElements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelCoversBldgElements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelCoversBldgElements * > (allocateIfcRelCoversBldgElements(this, Step::Id_UNSET));
    }
}

IfcRelCoversBldgElements *ExpressDataSet::cloneIfcRelCoversBldgElements(ExpressDataSet *expressDataSet, const IfcRelCoversBldgElements &obj, const CopyOp &copyop) {
    IfcRelCoversBldgElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelCoversBldgElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelCoversBldgElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelCoversBldgElements *ExpressDataSet::cloneIfcRelCoversBldgElements(const IfcRelCoversBldgElements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelCoversBldgElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelCoversBldgElements(this, obj, copyop);
    }
}

IfcRelCoversSpaces *ExpressDataSet::getIfcRelCoversSpaces(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelCoversSpaces * > (current->second.get());
    }
    else {
        IfcRelCoversSpaces *ret = static_cast< IfcRelCoversSpaces * > (allocateIfcRelCoversSpaces(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelCoversSpaces(IfcRelCoversSpaces *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelCoversSpaces_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelCoversSpaces(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelCoversSpaces *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelCoversSpaces(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelCoversSpaces_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelCoversSpaces > ExpressDataSet::createIfcRelCoversSpaces(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelCoversSpaces(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelCoversSpaces * > (allocateIfcRelCoversSpaces(this, Step::Id_UNSET));
    }
}

IfcRelCoversSpaces *ExpressDataSet::cloneIfcRelCoversSpaces(ExpressDataSet *expressDataSet, const IfcRelCoversSpaces &obj, const CopyOp &copyop) {
    IfcRelCoversSpaces *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelCoversSpaces(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelCoversSpaces_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelCoversSpaces *ExpressDataSet::cloneIfcRelCoversSpaces(const IfcRelCoversSpaces &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelCoversSpaces(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelCoversSpaces(this, obj, copyop);
    }
}

IfcRelDefinesByProperties *ExpressDataSet::getIfcRelDefinesByProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelDefinesByProperties * > (current->second.get());
    }
    else {
        IfcRelDefinesByProperties *ret = static_cast< IfcRelDefinesByProperties * > (allocateIfcRelDefinesByProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelDefinesByProperties(IfcRelDefinesByProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelDefinesByProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDefinesByProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelDefinesByProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDefinesByProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDefinesByProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDefinesByProperties > ExpressDataSet::createIfcRelDefinesByProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelDefinesByProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelDefinesByProperties * > (allocateIfcRelDefinesByProperties(this, Step::Id_UNSET));
    }
}

IfcRelDefinesByProperties *ExpressDataSet::cloneIfcRelDefinesByProperties(ExpressDataSet *expressDataSet, const IfcRelDefinesByProperties &obj, const CopyOp &copyop) {
    IfcRelDefinesByProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDefinesByProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDefinesByProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDefinesByProperties *ExpressDataSet::cloneIfcRelDefinesByProperties(const IfcRelDefinesByProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelDefinesByProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelDefinesByProperties(this, obj, copyop);
    }
}

IfcRelDefinesByType *ExpressDataSet::getIfcRelDefinesByType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelDefinesByType * > (current->second.get());
    }
    else {
        IfcRelDefinesByType *ret = static_cast< IfcRelDefinesByType * > (allocateIfcRelDefinesByType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelDefinesByType(IfcRelDefinesByType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelDefinesByType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelDefinesByType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelDefinesByType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelDefinesByType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelDefinesByType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelDefinesByType > ExpressDataSet::createIfcRelDefinesByType(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelDefinesByType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelDefinesByType * > (allocateIfcRelDefinesByType(this, Step::Id_UNSET));
    }
}

IfcRelDefinesByType *ExpressDataSet::cloneIfcRelDefinesByType(ExpressDataSet *expressDataSet, const IfcRelDefinesByType &obj, const CopyOp &copyop) {
    IfcRelDefinesByType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelDefinesByType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelDefinesByType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelDefinesByType *ExpressDataSet::cloneIfcRelDefinesByType(const IfcRelDefinesByType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelDefinesByType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelDefinesByType(this, obj, copyop);
    }
}

IfcRelFillsElement *ExpressDataSet::getIfcRelFillsElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelFillsElement * > (current->second.get());
    }
    else {
        IfcRelFillsElement *ret = static_cast< IfcRelFillsElement * > (allocateIfcRelFillsElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelFillsElement(IfcRelFillsElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelFillsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelFillsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelFillsElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelFillsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelFillsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelFillsElement > ExpressDataSet::createIfcRelFillsElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelFillsElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelFillsElement * > (allocateIfcRelFillsElement(this, Step::Id_UNSET));
    }
}

IfcRelFillsElement *ExpressDataSet::cloneIfcRelFillsElement(ExpressDataSet *expressDataSet, const IfcRelFillsElement &obj, const CopyOp &copyop) {
    IfcRelFillsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelFillsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelFillsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelFillsElement *ExpressDataSet::cloneIfcRelFillsElement(const IfcRelFillsElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelFillsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelFillsElement(this, obj, copyop);
    }
}

IfcRelFlowControlElements *ExpressDataSet::getIfcRelFlowControlElements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelFlowControlElements * > (current->second.get());
    }
    else {
        IfcRelFlowControlElements *ret = static_cast< IfcRelFlowControlElements * > (allocateIfcRelFlowControlElements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelFlowControlElements(IfcRelFlowControlElements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelFlowControlElements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelFlowControlElements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelFlowControlElements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelFlowControlElements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelFlowControlElements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelFlowControlElements > ExpressDataSet::createIfcRelFlowControlElements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelFlowControlElements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelFlowControlElements * > (allocateIfcRelFlowControlElements(this, Step::Id_UNSET));
    }
}

IfcRelFlowControlElements *ExpressDataSet::cloneIfcRelFlowControlElements(ExpressDataSet *expressDataSet, const IfcRelFlowControlElements &obj, const CopyOp &copyop) {
    IfcRelFlowControlElements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelFlowControlElements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelFlowControlElements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelFlowControlElements *ExpressDataSet::cloneIfcRelFlowControlElements(const IfcRelFlowControlElements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelFlowControlElements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelFlowControlElements(this, obj, copyop);
    }
}

IfcRelInteractionRequirements *ExpressDataSet::getIfcRelInteractionRequirements(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelInteractionRequirements * > (current->second.get());
    }
    else {
        IfcRelInteractionRequirements *ret = static_cast< IfcRelInteractionRequirements * > (allocateIfcRelInteractionRequirements(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelInteractionRequirements(IfcRelInteractionRequirements *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelInteractionRequirements_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelInteractionRequirements(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelInteractionRequirements *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelInteractionRequirements(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelInteractionRequirements_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelInteractionRequirements > ExpressDataSet::createIfcRelInteractionRequirements(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelInteractionRequirements(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelInteractionRequirements * > (allocateIfcRelInteractionRequirements(this, Step::Id_UNSET));
    }
}

IfcRelInteractionRequirements *ExpressDataSet::cloneIfcRelInteractionRequirements(ExpressDataSet *expressDataSet, const IfcRelInteractionRequirements &obj, const CopyOp &copyop) {
    IfcRelInteractionRequirements *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelInteractionRequirements(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelInteractionRequirements_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelInteractionRequirements *ExpressDataSet::cloneIfcRelInteractionRequirements(const IfcRelInteractionRequirements &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelInteractionRequirements(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelInteractionRequirements(this, obj, copyop);
    }
}

IfcRelNests *ExpressDataSet::getIfcRelNests(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelNests * > (current->second.get());
    }
    else {
        IfcRelNests *ret = static_cast< IfcRelNests * > (allocateIfcRelNests(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelNests(IfcRelNests *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelNests_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelNests(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelNests *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelNests(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelNests_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelNests > ExpressDataSet::createIfcRelNests(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelNests(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelNests * > (allocateIfcRelNests(this, Step::Id_UNSET));
    }
}

IfcRelNests *ExpressDataSet::cloneIfcRelNests(ExpressDataSet *expressDataSet, const IfcRelNests &obj, const CopyOp &copyop) {
    IfcRelNests *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelNests(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelNests_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelNests *ExpressDataSet::cloneIfcRelNests(const IfcRelNests &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelNests(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelNests(this, obj, copyop);
    }
}

IfcRelOccupiesSpaces *ExpressDataSet::getIfcRelOccupiesSpaces(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelOccupiesSpaces * > (current->second.get());
    }
    else {
        IfcRelOccupiesSpaces *ret = static_cast< IfcRelOccupiesSpaces * > (allocateIfcRelOccupiesSpaces(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelOccupiesSpaces(IfcRelOccupiesSpaces *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelOccupiesSpaces_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelOccupiesSpaces(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelOccupiesSpaces *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelOccupiesSpaces(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelOccupiesSpaces_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelOccupiesSpaces > ExpressDataSet::createIfcRelOccupiesSpaces(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelOccupiesSpaces(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelOccupiesSpaces * > (allocateIfcRelOccupiesSpaces(this, Step::Id_UNSET));
    }
}

IfcRelOccupiesSpaces *ExpressDataSet::cloneIfcRelOccupiesSpaces(ExpressDataSet *expressDataSet, const IfcRelOccupiesSpaces &obj, const CopyOp &copyop) {
    IfcRelOccupiesSpaces *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelOccupiesSpaces(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelOccupiesSpaces_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelOccupiesSpaces *ExpressDataSet::cloneIfcRelOccupiesSpaces(const IfcRelOccupiesSpaces &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelOccupiesSpaces(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelOccupiesSpaces(this, obj, copyop);
    }
}

IfcRelOverridesProperties *ExpressDataSet::getIfcRelOverridesProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelOverridesProperties * > (current->second.get());
    }
    else {
        IfcRelOverridesProperties *ret = static_cast< IfcRelOverridesProperties * > (allocateIfcRelOverridesProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelOverridesProperties(IfcRelOverridesProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelOverridesProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelOverridesProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelOverridesProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelOverridesProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelOverridesProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelOverridesProperties > ExpressDataSet::createIfcRelOverridesProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelOverridesProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelOverridesProperties * > (allocateIfcRelOverridesProperties(this, Step::Id_UNSET));
    }
}

IfcRelOverridesProperties *ExpressDataSet::cloneIfcRelOverridesProperties(ExpressDataSet *expressDataSet, const IfcRelOverridesProperties &obj, const CopyOp &copyop) {
    IfcRelOverridesProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelOverridesProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelOverridesProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelOverridesProperties *ExpressDataSet::cloneIfcRelOverridesProperties(const IfcRelOverridesProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelOverridesProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelOverridesProperties(this, obj, copyop);
    }
}

IfcRelProjectsElement *ExpressDataSet::getIfcRelProjectsElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelProjectsElement * > (current->second.get());
    }
    else {
        IfcRelProjectsElement *ret = static_cast< IfcRelProjectsElement * > (allocateIfcRelProjectsElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelProjectsElement(IfcRelProjectsElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelProjectsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelProjectsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelProjectsElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelProjectsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelProjectsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelProjectsElement > ExpressDataSet::createIfcRelProjectsElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelProjectsElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelProjectsElement * > (allocateIfcRelProjectsElement(this, Step::Id_UNSET));
    }
}

IfcRelProjectsElement *ExpressDataSet::cloneIfcRelProjectsElement(ExpressDataSet *expressDataSet, const IfcRelProjectsElement &obj, const CopyOp &copyop) {
    IfcRelProjectsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelProjectsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelProjectsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelProjectsElement *ExpressDataSet::cloneIfcRelProjectsElement(const IfcRelProjectsElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelProjectsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelProjectsElement(this, obj, copyop);
    }
}

IfcRelReferencedInSpatialStructure *ExpressDataSet::getIfcRelReferencedInSpatialStructure(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelReferencedInSpatialStructure * > (current->second.get());
    }
    else {
        IfcRelReferencedInSpatialStructure *ret = static_cast< IfcRelReferencedInSpatialStructure * > (allocateIfcRelReferencedInSpatialStructure(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelReferencedInSpatialStructure(IfcRelReferencedInSpatialStructure *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelReferencedInSpatialStructure_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelReferencedInSpatialStructure(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelReferencedInSpatialStructure *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelReferencedInSpatialStructure(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelReferencedInSpatialStructure_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelReferencedInSpatialStructure > ExpressDataSet::createIfcRelReferencedInSpatialStructure(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelReferencedInSpatialStructure(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelReferencedInSpatialStructure * > (allocateIfcRelReferencedInSpatialStructure(this, Step::Id_UNSET));
    }
}

IfcRelReferencedInSpatialStructure *ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(ExpressDataSet *expressDataSet, const IfcRelReferencedInSpatialStructure &obj, const CopyOp &copyop) {
    IfcRelReferencedInSpatialStructure *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelReferencedInSpatialStructure(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelReferencedInSpatialStructure_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelReferencedInSpatialStructure *ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(const IfcRelReferencedInSpatialStructure &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelReferencedInSpatialStructure(this, obj, copyop);
    }
}

IfcRelSchedulesCostItems *ExpressDataSet::getIfcRelSchedulesCostItems(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelSchedulesCostItems * > (current->second.get());
    }
    else {
        IfcRelSchedulesCostItems *ret = static_cast< IfcRelSchedulesCostItems * > (allocateIfcRelSchedulesCostItems(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelSchedulesCostItems(IfcRelSchedulesCostItems *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelSchedulesCostItems_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSchedulesCostItems(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelSchedulesCostItems *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSchedulesCostItems(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSchedulesCostItems_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSchedulesCostItems > ExpressDataSet::createIfcRelSchedulesCostItems(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelSchedulesCostItems(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelSchedulesCostItems * > (allocateIfcRelSchedulesCostItems(this, Step::Id_UNSET));
    }
}

IfcRelSchedulesCostItems *ExpressDataSet::cloneIfcRelSchedulesCostItems(ExpressDataSet *expressDataSet, const IfcRelSchedulesCostItems &obj, const CopyOp &copyop) {
    IfcRelSchedulesCostItems *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSchedulesCostItems(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSchedulesCostItems_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSchedulesCostItems *ExpressDataSet::cloneIfcRelSchedulesCostItems(const IfcRelSchedulesCostItems &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelSchedulesCostItems(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelSchedulesCostItems(this, obj, copyop);
    }
}

IfcRelSequence *ExpressDataSet::getIfcRelSequence(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelSequence * > (current->second.get());
    }
    else {
        IfcRelSequence *ret = static_cast< IfcRelSequence * > (allocateIfcRelSequence(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelSequence(IfcRelSequence *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelSequence_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSequence(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelSequence *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSequence(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSequence_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSequence > ExpressDataSet::createIfcRelSequence(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelSequence(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelSequence * > (allocateIfcRelSequence(this, Step::Id_UNSET));
    }
}

IfcRelSequence *ExpressDataSet::cloneIfcRelSequence(ExpressDataSet *expressDataSet, const IfcRelSequence &obj, const CopyOp &copyop) {
    IfcRelSequence *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSequence(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSequence_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSequence *ExpressDataSet::cloneIfcRelSequence(const IfcRelSequence &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelSequence(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelSequence(this, obj, copyop);
    }
}

IfcRelServicesBuildings *ExpressDataSet::getIfcRelServicesBuildings(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelServicesBuildings * > (current->second.get());
    }
    else {
        IfcRelServicesBuildings *ret = static_cast< IfcRelServicesBuildings * > (allocateIfcRelServicesBuildings(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelServicesBuildings(IfcRelServicesBuildings *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelServicesBuildings_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelServicesBuildings(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelServicesBuildings *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelServicesBuildings(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelServicesBuildings_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelServicesBuildings > ExpressDataSet::createIfcRelServicesBuildings(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelServicesBuildings(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelServicesBuildings * > (allocateIfcRelServicesBuildings(this, Step::Id_UNSET));
    }
}

IfcRelServicesBuildings *ExpressDataSet::cloneIfcRelServicesBuildings(ExpressDataSet *expressDataSet, const IfcRelServicesBuildings &obj, const CopyOp &copyop) {
    IfcRelServicesBuildings *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelServicesBuildings(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelServicesBuildings_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelServicesBuildings *ExpressDataSet::cloneIfcRelServicesBuildings(const IfcRelServicesBuildings &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelServicesBuildings(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelServicesBuildings(this, obj, copyop);
    }
}

IfcRelSpaceBoundary *ExpressDataSet::getIfcRelSpaceBoundary(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelSpaceBoundary * > (current->second.get());
    }
    else {
        IfcRelSpaceBoundary *ret = static_cast< IfcRelSpaceBoundary * > (allocateIfcRelSpaceBoundary(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelSpaceBoundary(IfcRelSpaceBoundary *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelSpaceBoundary_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelSpaceBoundary(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelSpaceBoundary *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelSpaceBoundary(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelSpaceBoundary_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelSpaceBoundary > ExpressDataSet::createIfcRelSpaceBoundary(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelSpaceBoundary(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelSpaceBoundary * > (allocateIfcRelSpaceBoundary(this, Step::Id_UNSET));
    }
}

IfcRelSpaceBoundary *ExpressDataSet::cloneIfcRelSpaceBoundary(ExpressDataSet *expressDataSet, const IfcRelSpaceBoundary &obj, const CopyOp &copyop) {
    IfcRelSpaceBoundary *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelSpaceBoundary(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelSpaceBoundary_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelSpaceBoundary *ExpressDataSet::cloneIfcRelSpaceBoundary(const IfcRelSpaceBoundary &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelSpaceBoundary(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelSpaceBoundary(this, obj, copyop);
    }
}

IfcRelVoidsElement *ExpressDataSet::getIfcRelVoidsElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelVoidsElement * > (current->second.get());
    }
    else {
        IfcRelVoidsElement *ret = static_cast< IfcRelVoidsElement * > (allocateIfcRelVoidsElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelVoidsElement(IfcRelVoidsElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelVoidsElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelVoidsElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelVoidsElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelVoidsElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelVoidsElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelVoidsElement > ExpressDataSet::createIfcRelVoidsElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelVoidsElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelVoidsElement * > (allocateIfcRelVoidsElement(this, Step::Id_UNSET));
    }
}

IfcRelVoidsElement *ExpressDataSet::cloneIfcRelVoidsElement(ExpressDataSet *expressDataSet, const IfcRelVoidsElement &obj, const CopyOp &copyop) {
    IfcRelVoidsElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelVoidsElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelVoidsElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelVoidsElement *ExpressDataSet::cloneIfcRelVoidsElement(const IfcRelVoidsElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelVoidsElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelVoidsElement(this, obj, copyop);
    }
}

IfcRelaxation *ExpressDataSet::getIfcRelaxation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRelaxation * > (current->second.get());
    }
    else {
        IfcRelaxation *ret = static_cast< IfcRelaxation * > (allocateIfcRelaxation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRelaxation(IfcRelaxation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRelaxation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRelaxation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRelaxation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRelaxation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRelaxation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRelaxation > ExpressDataSet::createIfcRelaxation(bool isVolatile) {
    if (isVolatile) {
        return new IfcRelaxation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRelaxation * > (allocateIfcRelaxation(this, Step::Id_UNSET));
    }
}

IfcRelaxation *ExpressDataSet::cloneIfcRelaxation(ExpressDataSet *expressDataSet, const IfcRelaxation &obj, const CopyOp &copyop) {
    IfcRelaxation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRelaxation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRelaxation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRelaxation *ExpressDataSet::cloneIfcRelaxation(const IfcRelaxation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRelaxation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRelaxation(this, obj, copyop);
    }
}

IfcRepresentation *ExpressDataSet::getIfcRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRepresentation * > (current->second.get());
    }
    else {
        IfcRepresentation *ret = static_cast< IfcRepresentation * > (allocateIfcRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRepresentation(IfcRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentation > ExpressDataSet::createIfcRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRepresentation * > (allocateIfcRepresentation(this, Step::Id_UNSET));
    }
}

IfcRepresentation *ExpressDataSet::cloneIfcRepresentation(ExpressDataSet *expressDataSet, const IfcRepresentation &obj, const CopyOp &copyop) {
    IfcRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentation *ExpressDataSet::cloneIfcRepresentation(const IfcRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRepresentation(this, obj, copyop);
    }
}

IfcRepresentationContext *ExpressDataSet::getIfcRepresentationContext(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRepresentationContext * > (current->second.get());
    }
    else {
        IfcRepresentationContext *ret = static_cast< IfcRepresentationContext * > (allocateIfcRepresentationContext(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRepresentationContext(IfcRepresentationContext *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRepresentationContext_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentationContext(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRepresentationContext *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentationContext(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentationContext_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentationContext > ExpressDataSet::createIfcRepresentationContext(bool isVolatile) {
    if (isVolatile) {
        return new IfcRepresentationContext(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRepresentationContext * > (allocateIfcRepresentationContext(this, Step::Id_UNSET));
    }
}

IfcRepresentationContext *ExpressDataSet::cloneIfcRepresentationContext(ExpressDataSet *expressDataSet, const IfcRepresentationContext &obj, const CopyOp &copyop) {
    IfcRepresentationContext *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentationContext(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentationContext_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentationContext *ExpressDataSet::cloneIfcRepresentationContext(const IfcRepresentationContext &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRepresentationContext(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRepresentationContext(this, obj, copyop);
    }
}

IfcRepresentationMap *ExpressDataSet::getIfcRepresentationMap(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRepresentationMap * > (current->second.get());
    }
    else {
        IfcRepresentationMap *ret = static_cast< IfcRepresentationMap * > (allocateIfcRepresentationMap(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRepresentationMap(IfcRepresentationMap *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRepresentationMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRepresentationMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRepresentationMap *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRepresentationMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRepresentationMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRepresentationMap > ExpressDataSet::createIfcRepresentationMap(bool isVolatile) {
    if (isVolatile) {
        return new IfcRepresentationMap(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRepresentationMap * > (allocateIfcRepresentationMap(this, Step::Id_UNSET));
    }
}

IfcRepresentationMap *ExpressDataSet::cloneIfcRepresentationMap(ExpressDataSet *expressDataSet, const IfcRepresentationMap &obj, const CopyOp &copyop) {
    IfcRepresentationMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRepresentationMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRepresentationMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRepresentationMap *ExpressDataSet::cloneIfcRepresentationMap(const IfcRepresentationMap &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRepresentationMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRepresentationMap(this, obj, copyop);
    }
}

IfcRevolvedAreaSolid *ExpressDataSet::getIfcRevolvedAreaSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRevolvedAreaSolid * > (current->second.get());
    }
    else {
        IfcRevolvedAreaSolid *ret = static_cast< IfcRevolvedAreaSolid * > (allocateIfcRevolvedAreaSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRevolvedAreaSolid(IfcRevolvedAreaSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRevolvedAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRevolvedAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRevolvedAreaSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRevolvedAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRevolvedAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRevolvedAreaSolid > ExpressDataSet::createIfcRevolvedAreaSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcRevolvedAreaSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRevolvedAreaSolid * > (allocateIfcRevolvedAreaSolid(this, Step::Id_UNSET));
    }
}

IfcRevolvedAreaSolid *ExpressDataSet::cloneIfcRevolvedAreaSolid(ExpressDataSet *expressDataSet, const IfcRevolvedAreaSolid &obj, const CopyOp &copyop) {
    IfcRevolvedAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRevolvedAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRevolvedAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRevolvedAreaSolid *ExpressDataSet::cloneIfcRevolvedAreaSolid(const IfcRevolvedAreaSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRevolvedAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRevolvedAreaSolid(this, obj, copyop);
    }
}

IfcRibPlateProfileProperties *ExpressDataSet::getIfcRibPlateProfileProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRibPlateProfileProperties * > (current->second.get());
    }
    else {
        IfcRibPlateProfileProperties *ret = static_cast< IfcRibPlateProfileProperties * > (allocateIfcRibPlateProfileProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRibPlateProfileProperties(IfcRibPlateProfileProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRibPlateProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRibPlateProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRibPlateProfileProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRibPlateProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRibPlateProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRibPlateProfileProperties > ExpressDataSet::createIfcRibPlateProfileProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcRibPlateProfileProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRibPlateProfileProperties * > (allocateIfcRibPlateProfileProperties(this, Step::Id_UNSET));
    }
}

IfcRibPlateProfileProperties *ExpressDataSet::cloneIfcRibPlateProfileProperties(ExpressDataSet *expressDataSet, const IfcRibPlateProfileProperties &obj, const CopyOp &copyop) {
    IfcRibPlateProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRibPlateProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRibPlateProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRibPlateProfileProperties *ExpressDataSet::cloneIfcRibPlateProfileProperties(const IfcRibPlateProfileProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRibPlateProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRibPlateProfileProperties(this, obj, copyop);
    }
}

IfcRightCircularCone *ExpressDataSet::getIfcRightCircularCone(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRightCircularCone * > (current->second.get());
    }
    else {
        IfcRightCircularCone *ret = static_cast< IfcRightCircularCone * > (allocateIfcRightCircularCone(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRightCircularCone(IfcRightCircularCone *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRightCircularCone_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRightCircularCone(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRightCircularCone *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRightCircularCone(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRightCircularCone_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRightCircularCone > ExpressDataSet::createIfcRightCircularCone(bool isVolatile) {
    if (isVolatile) {
        return new IfcRightCircularCone(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRightCircularCone * > (allocateIfcRightCircularCone(this, Step::Id_UNSET));
    }
}

IfcRightCircularCone *ExpressDataSet::cloneIfcRightCircularCone(ExpressDataSet *expressDataSet, const IfcRightCircularCone &obj, const CopyOp &copyop) {
    IfcRightCircularCone *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRightCircularCone(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRightCircularCone_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRightCircularCone *ExpressDataSet::cloneIfcRightCircularCone(const IfcRightCircularCone &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRightCircularCone(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRightCircularCone(this, obj, copyop);
    }
}

IfcRightCircularCylinder *ExpressDataSet::getIfcRightCircularCylinder(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRightCircularCylinder * > (current->second.get());
    }
    else {
        IfcRightCircularCylinder *ret = static_cast< IfcRightCircularCylinder * > (allocateIfcRightCircularCylinder(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRightCircularCylinder(IfcRightCircularCylinder *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRightCircularCylinder_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRightCircularCylinder(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRightCircularCylinder *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRightCircularCylinder(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRightCircularCylinder_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRightCircularCylinder > ExpressDataSet::createIfcRightCircularCylinder(bool isVolatile) {
    if (isVolatile) {
        return new IfcRightCircularCylinder(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRightCircularCylinder * > (allocateIfcRightCircularCylinder(this, Step::Id_UNSET));
    }
}

IfcRightCircularCylinder *ExpressDataSet::cloneIfcRightCircularCylinder(ExpressDataSet *expressDataSet, const IfcRightCircularCylinder &obj, const CopyOp &copyop) {
    IfcRightCircularCylinder *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRightCircularCylinder(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRightCircularCylinder_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRightCircularCylinder *ExpressDataSet::cloneIfcRightCircularCylinder(const IfcRightCircularCylinder &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRightCircularCylinder(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRightCircularCylinder(this, obj, copyop);
    }
}

IfcRoof *ExpressDataSet::getIfcRoof(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRoof * > (current->second.get());
    }
    else {
        IfcRoof *ret = static_cast< IfcRoof * > (allocateIfcRoof(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRoof(IfcRoof *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRoof_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoof(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRoof *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoof(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoof_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoof > ExpressDataSet::createIfcRoof(bool isVolatile) {
    if (isVolatile) {
        return new IfcRoof(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRoof * > (allocateIfcRoof(this, Step::Id_UNSET));
    }
}

IfcRoof *ExpressDataSet::cloneIfcRoof(ExpressDataSet *expressDataSet, const IfcRoof &obj, const CopyOp &copyop) {
    IfcRoof *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoof(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoof_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoof *ExpressDataSet::cloneIfcRoof(const IfcRoof &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRoof(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRoof(this, obj, copyop);
    }
}

IfcRoundedEdgeFeature *ExpressDataSet::getIfcRoundedEdgeFeature(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRoundedEdgeFeature * > (current->second.get());
    }
    else {
        IfcRoundedEdgeFeature *ret = static_cast< IfcRoundedEdgeFeature * > (allocateIfcRoundedEdgeFeature(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRoundedEdgeFeature(IfcRoundedEdgeFeature *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRoundedEdgeFeature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoundedEdgeFeature(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRoundedEdgeFeature *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoundedEdgeFeature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoundedEdgeFeature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoundedEdgeFeature > ExpressDataSet::createIfcRoundedEdgeFeature(bool isVolatile) {
    if (isVolatile) {
        return new IfcRoundedEdgeFeature(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRoundedEdgeFeature * > (allocateIfcRoundedEdgeFeature(this, Step::Id_UNSET));
    }
}

IfcRoundedEdgeFeature *ExpressDataSet::cloneIfcRoundedEdgeFeature(ExpressDataSet *expressDataSet, const IfcRoundedEdgeFeature &obj, const CopyOp &copyop) {
    IfcRoundedEdgeFeature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoundedEdgeFeature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoundedEdgeFeature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoundedEdgeFeature *ExpressDataSet::cloneIfcRoundedEdgeFeature(const IfcRoundedEdgeFeature &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRoundedEdgeFeature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRoundedEdgeFeature(this, obj, copyop);
    }
}

IfcRoundedRectangleProfileDef *ExpressDataSet::getIfcRoundedRectangleProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcRoundedRectangleProfileDef * > (current->second.get());
    }
    else {
        IfcRoundedRectangleProfileDef *ret = static_cast< IfcRoundedRectangleProfileDef * > (allocateIfcRoundedRectangleProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcRoundedRectangleProfileDef(IfcRoundedRectangleProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcRoundedRectangleProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcRoundedRectangleProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcRoundedRectangleProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcRoundedRectangleProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcRoundedRectangleProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcRoundedRectangleProfileDef > ExpressDataSet::createIfcRoundedRectangleProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcRoundedRectangleProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcRoundedRectangleProfileDef * > (allocateIfcRoundedRectangleProfileDef(this, Step::Id_UNSET));
    }
}

IfcRoundedRectangleProfileDef *ExpressDataSet::cloneIfcRoundedRectangleProfileDef(ExpressDataSet *expressDataSet, const IfcRoundedRectangleProfileDef &obj, const CopyOp &copyop) {
    IfcRoundedRectangleProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcRoundedRectangleProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcRoundedRectangleProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcRoundedRectangleProfileDef *ExpressDataSet::cloneIfcRoundedRectangleProfileDef(const IfcRoundedRectangleProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcRoundedRectangleProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcRoundedRectangleProfileDef(this, obj, copyop);
    }
}

IfcSIUnit *ExpressDataSet::getIfcSIUnit(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSIUnit * > (current->second.get());
    }
    else {
        IfcSIUnit *ret = static_cast< IfcSIUnit * > (allocateIfcSIUnit(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSIUnit(IfcSIUnit *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSIUnit_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSIUnit(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSIUnit *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSIUnit(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSIUnit_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSIUnit > ExpressDataSet::createIfcSIUnit(bool isVolatile) {
    if (isVolatile) {
        return new IfcSIUnit(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSIUnit * > (allocateIfcSIUnit(this, Step::Id_UNSET));
    }
}

IfcSIUnit *ExpressDataSet::cloneIfcSIUnit(ExpressDataSet *expressDataSet, const IfcSIUnit &obj, const CopyOp &copyop) {
    IfcSIUnit *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSIUnit(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSIUnit_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSIUnit *ExpressDataSet::cloneIfcSIUnit(const IfcSIUnit &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSIUnit(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSIUnit(this, obj, copyop);
    }
}

IfcSanitaryTerminalType *ExpressDataSet::getIfcSanitaryTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSanitaryTerminalType * > (current->second.get());
    }
    else {
        IfcSanitaryTerminalType *ret = static_cast< IfcSanitaryTerminalType * > (allocateIfcSanitaryTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSanitaryTerminalType(IfcSanitaryTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSanitaryTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSanitaryTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSanitaryTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSanitaryTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSanitaryTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSanitaryTerminalType > ExpressDataSet::createIfcSanitaryTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSanitaryTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSanitaryTerminalType * > (allocateIfcSanitaryTerminalType(this, Step::Id_UNSET));
    }
}

IfcSanitaryTerminalType *ExpressDataSet::cloneIfcSanitaryTerminalType(ExpressDataSet *expressDataSet, const IfcSanitaryTerminalType &obj, const CopyOp &copyop) {
    IfcSanitaryTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSanitaryTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSanitaryTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSanitaryTerminalType *ExpressDataSet::cloneIfcSanitaryTerminalType(const IfcSanitaryTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSanitaryTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSanitaryTerminalType(this, obj, copyop);
    }
}

IfcScheduleTimeControl *ExpressDataSet::getIfcScheduleTimeControl(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcScheduleTimeControl * > (current->second.get());
    }
    else {
        IfcScheduleTimeControl *ret = static_cast< IfcScheduleTimeControl * > (allocateIfcScheduleTimeControl(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcScheduleTimeControl(IfcScheduleTimeControl *arg) {
    getAll().erase(arg->getKey());
    return m_IfcScheduleTimeControl_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcScheduleTimeControl(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcScheduleTimeControl *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcScheduleTimeControl(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcScheduleTimeControl_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcScheduleTimeControl > ExpressDataSet::createIfcScheduleTimeControl(bool isVolatile) {
    if (isVolatile) {
        return new IfcScheduleTimeControl(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcScheduleTimeControl * > (allocateIfcScheduleTimeControl(this, Step::Id_UNSET));
    }
}

IfcScheduleTimeControl *ExpressDataSet::cloneIfcScheduleTimeControl(ExpressDataSet *expressDataSet, const IfcScheduleTimeControl &obj, const CopyOp &copyop) {
    IfcScheduleTimeControl *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcScheduleTimeControl(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcScheduleTimeControl_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcScheduleTimeControl *ExpressDataSet::cloneIfcScheduleTimeControl(const IfcScheduleTimeControl &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcScheduleTimeControl(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcScheduleTimeControl(this, obj, copyop);
    }
}

IfcSectionProperties *ExpressDataSet::getIfcSectionProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSectionProperties * > (current->second.get());
    }
    else {
        IfcSectionProperties *ret = static_cast< IfcSectionProperties * > (allocateIfcSectionProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSectionProperties(IfcSectionProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSectionProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSectionProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionProperties > ExpressDataSet::createIfcSectionProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcSectionProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSectionProperties * > (allocateIfcSectionProperties(this, Step::Id_UNSET));
    }
}

IfcSectionProperties *ExpressDataSet::cloneIfcSectionProperties(ExpressDataSet *expressDataSet, const IfcSectionProperties &obj, const CopyOp &copyop) {
    IfcSectionProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionProperties *ExpressDataSet::cloneIfcSectionProperties(const IfcSectionProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSectionProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSectionProperties(this, obj, copyop);
    }
}

IfcSectionReinforcementProperties *ExpressDataSet::getIfcSectionReinforcementProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSectionReinforcementProperties * > (current->second.get());
    }
    else {
        IfcSectionReinforcementProperties *ret = static_cast< IfcSectionReinforcementProperties * > (allocateIfcSectionReinforcementProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSectionReinforcementProperties(IfcSectionReinforcementProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSectionReinforcementProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionReinforcementProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSectionReinforcementProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionReinforcementProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionReinforcementProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionReinforcementProperties > ExpressDataSet::createIfcSectionReinforcementProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcSectionReinforcementProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSectionReinforcementProperties * > (allocateIfcSectionReinforcementProperties(this, Step::Id_UNSET));
    }
}

IfcSectionReinforcementProperties *ExpressDataSet::cloneIfcSectionReinforcementProperties(ExpressDataSet *expressDataSet, const IfcSectionReinforcementProperties &obj, const CopyOp &copyop) {
    IfcSectionReinforcementProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionReinforcementProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionReinforcementProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionReinforcementProperties *ExpressDataSet::cloneIfcSectionReinforcementProperties(const IfcSectionReinforcementProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSectionReinforcementProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSectionReinforcementProperties(this, obj, copyop);
    }
}

IfcSectionedSpine *ExpressDataSet::getIfcSectionedSpine(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSectionedSpine * > (current->second.get());
    }
    else {
        IfcSectionedSpine *ret = static_cast< IfcSectionedSpine * > (allocateIfcSectionedSpine(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSectionedSpine(IfcSectionedSpine *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSectionedSpine_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSectionedSpine(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSectionedSpine *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSectionedSpine(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSectionedSpine_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSectionedSpine > ExpressDataSet::createIfcSectionedSpine(bool isVolatile) {
    if (isVolatile) {
        return new IfcSectionedSpine(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSectionedSpine * > (allocateIfcSectionedSpine(this, Step::Id_UNSET));
    }
}

IfcSectionedSpine *ExpressDataSet::cloneIfcSectionedSpine(ExpressDataSet *expressDataSet, const IfcSectionedSpine &obj, const CopyOp &copyop) {
    IfcSectionedSpine *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSectionedSpine(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSectionedSpine_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSectionedSpine *ExpressDataSet::cloneIfcSectionedSpine(const IfcSectionedSpine &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSectionedSpine(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSectionedSpine(this, obj, copyop);
    }
}

IfcSensorType *ExpressDataSet::getIfcSensorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSensorType * > (current->second.get());
    }
    else {
        IfcSensorType *ret = static_cast< IfcSensorType * > (allocateIfcSensorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSensorType(IfcSensorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSensorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSensorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSensorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSensorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSensorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSensorType > ExpressDataSet::createIfcSensorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSensorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSensorType * > (allocateIfcSensorType(this, Step::Id_UNSET));
    }
}

IfcSensorType *ExpressDataSet::cloneIfcSensorType(ExpressDataSet *expressDataSet, const IfcSensorType &obj, const CopyOp &copyop) {
    IfcSensorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSensorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSensorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSensorType *ExpressDataSet::cloneIfcSensorType(const IfcSensorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSensorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSensorType(this, obj, copyop);
    }
}

IfcServiceLife *ExpressDataSet::getIfcServiceLife(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcServiceLife * > (current->second.get());
    }
    else {
        IfcServiceLife *ret = static_cast< IfcServiceLife * > (allocateIfcServiceLife(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcServiceLife(IfcServiceLife *arg) {
    getAll().erase(arg->getKey());
    return m_IfcServiceLife_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcServiceLife(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcServiceLife *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcServiceLife(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcServiceLife_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcServiceLife > ExpressDataSet::createIfcServiceLife(bool isVolatile) {
    if (isVolatile) {
        return new IfcServiceLife(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcServiceLife * > (allocateIfcServiceLife(this, Step::Id_UNSET));
    }
}

IfcServiceLife *ExpressDataSet::cloneIfcServiceLife(ExpressDataSet *expressDataSet, const IfcServiceLife &obj, const CopyOp &copyop) {
    IfcServiceLife *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcServiceLife(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcServiceLife_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcServiceLife *ExpressDataSet::cloneIfcServiceLife(const IfcServiceLife &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcServiceLife(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcServiceLife(this, obj, copyop);
    }
}

IfcServiceLifeFactor *ExpressDataSet::getIfcServiceLifeFactor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcServiceLifeFactor * > (current->second.get());
    }
    else {
        IfcServiceLifeFactor *ret = static_cast< IfcServiceLifeFactor * > (allocateIfcServiceLifeFactor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcServiceLifeFactor(IfcServiceLifeFactor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcServiceLifeFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcServiceLifeFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcServiceLifeFactor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcServiceLifeFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcServiceLifeFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcServiceLifeFactor > ExpressDataSet::createIfcServiceLifeFactor(bool isVolatile) {
    if (isVolatile) {
        return new IfcServiceLifeFactor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcServiceLifeFactor * > (allocateIfcServiceLifeFactor(this, Step::Id_UNSET));
    }
}

IfcServiceLifeFactor *ExpressDataSet::cloneIfcServiceLifeFactor(ExpressDataSet *expressDataSet, const IfcServiceLifeFactor &obj, const CopyOp &copyop) {
    IfcServiceLifeFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcServiceLifeFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcServiceLifeFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcServiceLifeFactor *ExpressDataSet::cloneIfcServiceLifeFactor(const IfcServiceLifeFactor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcServiceLifeFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcServiceLifeFactor(this, obj, copyop);
    }
}

IfcShapeAspect *ExpressDataSet::getIfcShapeAspect(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcShapeAspect * > (current->second.get());
    }
    else {
        IfcShapeAspect *ret = static_cast< IfcShapeAspect * > (allocateIfcShapeAspect(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcShapeAspect(IfcShapeAspect *arg) {
    getAll().erase(arg->getKey());
    return m_IfcShapeAspect_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShapeAspect(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcShapeAspect *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShapeAspect(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShapeAspect_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShapeAspect > ExpressDataSet::createIfcShapeAspect(bool isVolatile) {
    if (isVolatile) {
        return new IfcShapeAspect(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcShapeAspect * > (allocateIfcShapeAspect(this, Step::Id_UNSET));
    }
}

IfcShapeAspect *ExpressDataSet::cloneIfcShapeAspect(ExpressDataSet *expressDataSet, const IfcShapeAspect &obj, const CopyOp &copyop) {
    IfcShapeAspect *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShapeAspect(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShapeAspect_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShapeAspect *ExpressDataSet::cloneIfcShapeAspect(const IfcShapeAspect &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcShapeAspect(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcShapeAspect(this, obj, copyop);
    }
}

IfcShapeRepresentation *ExpressDataSet::getIfcShapeRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcShapeRepresentation * > (current->second.get());
    }
    else {
        IfcShapeRepresentation *ret = static_cast< IfcShapeRepresentation * > (allocateIfcShapeRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcShapeRepresentation(IfcShapeRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcShapeRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShapeRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcShapeRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShapeRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShapeRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShapeRepresentation > ExpressDataSet::createIfcShapeRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcShapeRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcShapeRepresentation * > (allocateIfcShapeRepresentation(this, Step::Id_UNSET));
    }
}

IfcShapeRepresentation *ExpressDataSet::cloneIfcShapeRepresentation(ExpressDataSet *expressDataSet, const IfcShapeRepresentation &obj, const CopyOp &copyop) {
    IfcShapeRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShapeRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShapeRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShapeRepresentation *ExpressDataSet::cloneIfcShapeRepresentation(const IfcShapeRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcShapeRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcShapeRepresentation(this, obj, copyop);
    }
}

IfcShellBasedSurfaceModel *ExpressDataSet::getIfcShellBasedSurfaceModel(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcShellBasedSurfaceModel * > (current->second.get());
    }
    else {
        IfcShellBasedSurfaceModel *ret = static_cast< IfcShellBasedSurfaceModel * > (allocateIfcShellBasedSurfaceModel(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcShellBasedSurfaceModel(IfcShellBasedSurfaceModel *arg) {
    getAll().erase(arg->getKey());
    return m_IfcShellBasedSurfaceModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcShellBasedSurfaceModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcShellBasedSurfaceModel *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcShellBasedSurfaceModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcShellBasedSurfaceModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcShellBasedSurfaceModel > ExpressDataSet::createIfcShellBasedSurfaceModel(bool isVolatile) {
    if (isVolatile) {
        return new IfcShellBasedSurfaceModel(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcShellBasedSurfaceModel * > (allocateIfcShellBasedSurfaceModel(this, Step::Id_UNSET));
    }
}

IfcShellBasedSurfaceModel *ExpressDataSet::cloneIfcShellBasedSurfaceModel(ExpressDataSet *expressDataSet, const IfcShellBasedSurfaceModel &obj, const CopyOp &copyop) {
    IfcShellBasedSurfaceModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcShellBasedSurfaceModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcShellBasedSurfaceModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcShellBasedSurfaceModel *ExpressDataSet::cloneIfcShellBasedSurfaceModel(const IfcShellBasedSurfaceModel &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcShellBasedSurfaceModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcShellBasedSurfaceModel(this, obj, copyop);
    }
}

IfcSite *ExpressDataSet::getIfcSite(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSite * > (current->second.get());
    }
    else {
        IfcSite *ret = static_cast< IfcSite * > (allocateIfcSite(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSite(IfcSite *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSite_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSite(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSite *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSite(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSite_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSite > ExpressDataSet::createIfcSite(bool isVolatile) {
    if (isVolatile) {
        return new IfcSite(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSite * > (allocateIfcSite(this, Step::Id_UNSET));
    }
}

IfcSite *ExpressDataSet::cloneIfcSite(ExpressDataSet *expressDataSet, const IfcSite &obj, const CopyOp &copyop) {
    IfcSite *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSite(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSite_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSite *ExpressDataSet::cloneIfcSite(const IfcSite &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSite(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSite(this, obj, copyop);
    }
}

IfcSlab *ExpressDataSet::getIfcSlab(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSlab * > (current->second.get());
    }
    else {
        IfcSlab *ret = static_cast< IfcSlab * > (allocateIfcSlab(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSlab(IfcSlab *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSlab_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlab(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSlab *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlab(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlab_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlab > ExpressDataSet::createIfcSlab(bool isVolatile) {
    if (isVolatile) {
        return new IfcSlab(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSlab * > (allocateIfcSlab(this, Step::Id_UNSET));
    }
}

IfcSlab *ExpressDataSet::cloneIfcSlab(ExpressDataSet *expressDataSet, const IfcSlab &obj, const CopyOp &copyop) {
    IfcSlab *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlab(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlab_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlab *ExpressDataSet::cloneIfcSlab(const IfcSlab &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSlab(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSlab(this, obj, copyop);
    }
}

IfcSlabType *ExpressDataSet::getIfcSlabType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSlabType * > (current->second.get());
    }
    else {
        IfcSlabType *ret = static_cast< IfcSlabType * > (allocateIfcSlabType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSlabType(IfcSlabType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSlabType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlabType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSlabType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlabType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlabType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlabType > ExpressDataSet::createIfcSlabType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSlabType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSlabType * > (allocateIfcSlabType(this, Step::Id_UNSET));
    }
}

IfcSlabType *ExpressDataSet::cloneIfcSlabType(ExpressDataSet *expressDataSet, const IfcSlabType &obj, const CopyOp &copyop) {
    IfcSlabType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlabType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlabType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlabType *ExpressDataSet::cloneIfcSlabType(const IfcSlabType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSlabType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSlabType(this, obj, copyop);
    }
}

IfcSlippageConnectionCondition *ExpressDataSet::getIfcSlippageConnectionCondition(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSlippageConnectionCondition * > (current->second.get());
    }
    else {
        IfcSlippageConnectionCondition *ret = static_cast< IfcSlippageConnectionCondition * > (allocateIfcSlippageConnectionCondition(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSlippageConnectionCondition(IfcSlippageConnectionCondition *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSlippageConnectionCondition_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSlippageConnectionCondition(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSlippageConnectionCondition *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSlippageConnectionCondition(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSlippageConnectionCondition_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSlippageConnectionCondition > ExpressDataSet::createIfcSlippageConnectionCondition(bool isVolatile) {
    if (isVolatile) {
        return new IfcSlippageConnectionCondition(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSlippageConnectionCondition * > (allocateIfcSlippageConnectionCondition(this, Step::Id_UNSET));
    }
}

IfcSlippageConnectionCondition *ExpressDataSet::cloneIfcSlippageConnectionCondition(ExpressDataSet *expressDataSet, const IfcSlippageConnectionCondition &obj, const CopyOp &copyop) {
    IfcSlippageConnectionCondition *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSlippageConnectionCondition(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSlippageConnectionCondition_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSlippageConnectionCondition *ExpressDataSet::cloneIfcSlippageConnectionCondition(const IfcSlippageConnectionCondition &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSlippageConnectionCondition(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSlippageConnectionCondition(this, obj, copyop);
    }
}

IfcSoundProperties *ExpressDataSet::getIfcSoundProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSoundProperties * > (current->second.get());
    }
    else {
        IfcSoundProperties *ret = static_cast< IfcSoundProperties * > (allocateIfcSoundProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSoundProperties(IfcSoundProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSoundProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSoundProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSoundProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSoundProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSoundProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSoundProperties > ExpressDataSet::createIfcSoundProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcSoundProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSoundProperties * > (allocateIfcSoundProperties(this, Step::Id_UNSET));
    }
}

IfcSoundProperties *ExpressDataSet::cloneIfcSoundProperties(ExpressDataSet *expressDataSet, const IfcSoundProperties &obj, const CopyOp &copyop) {
    IfcSoundProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSoundProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSoundProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSoundProperties *ExpressDataSet::cloneIfcSoundProperties(const IfcSoundProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSoundProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSoundProperties(this, obj, copyop);
    }
}

IfcSoundValue *ExpressDataSet::getIfcSoundValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSoundValue * > (current->second.get());
    }
    else {
        IfcSoundValue *ret = static_cast< IfcSoundValue * > (allocateIfcSoundValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSoundValue(IfcSoundValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSoundValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSoundValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSoundValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSoundValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSoundValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSoundValue > ExpressDataSet::createIfcSoundValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcSoundValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSoundValue * > (allocateIfcSoundValue(this, Step::Id_UNSET));
    }
}

IfcSoundValue *ExpressDataSet::cloneIfcSoundValue(ExpressDataSet *expressDataSet, const IfcSoundValue &obj, const CopyOp &copyop) {
    IfcSoundValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSoundValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSoundValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSoundValue *ExpressDataSet::cloneIfcSoundValue(const IfcSoundValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSoundValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSoundValue(this, obj, copyop);
    }
}

IfcSpace *ExpressDataSet::getIfcSpace(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSpace * > (current->second.get());
    }
    else {
        IfcSpace *ret = static_cast< IfcSpace * > (allocateIfcSpace(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSpace(IfcSpace *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSpace_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpace(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSpace *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpace(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpace_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpace > ExpressDataSet::createIfcSpace(bool isVolatile) {
    if (isVolatile) {
        return new IfcSpace(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSpace * > (allocateIfcSpace(this, Step::Id_UNSET));
    }
}

IfcSpace *ExpressDataSet::cloneIfcSpace(ExpressDataSet *expressDataSet, const IfcSpace &obj, const CopyOp &copyop) {
    IfcSpace *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpace(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpace_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpace *ExpressDataSet::cloneIfcSpace(const IfcSpace &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSpace(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSpace(this, obj, copyop);
    }
}

IfcSpaceHeaterType *ExpressDataSet::getIfcSpaceHeaterType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSpaceHeaterType * > (current->second.get());
    }
    else {
        IfcSpaceHeaterType *ret = static_cast< IfcSpaceHeaterType * > (allocateIfcSpaceHeaterType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSpaceHeaterType(IfcSpaceHeaterType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSpaceHeaterType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceHeaterType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSpaceHeaterType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceHeaterType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceHeaterType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceHeaterType > ExpressDataSet::createIfcSpaceHeaterType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSpaceHeaterType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSpaceHeaterType * > (allocateIfcSpaceHeaterType(this, Step::Id_UNSET));
    }
}

IfcSpaceHeaterType *ExpressDataSet::cloneIfcSpaceHeaterType(ExpressDataSet *expressDataSet, const IfcSpaceHeaterType &obj, const CopyOp &copyop) {
    IfcSpaceHeaterType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceHeaterType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceHeaterType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceHeaterType *ExpressDataSet::cloneIfcSpaceHeaterType(const IfcSpaceHeaterType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSpaceHeaterType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSpaceHeaterType(this, obj, copyop);
    }
}

IfcSpaceProgram *ExpressDataSet::getIfcSpaceProgram(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSpaceProgram * > (current->second.get());
    }
    else {
        IfcSpaceProgram *ret = static_cast< IfcSpaceProgram * > (allocateIfcSpaceProgram(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSpaceProgram(IfcSpaceProgram *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSpaceProgram_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceProgram(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSpaceProgram *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceProgram(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceProgram_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceProgram > ExpressDataSet::createIfcSpaceProgram(bool isVolatile) {
    if (isVolatile) {
        return new IfcSpaceProgram(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSpaceProgram * > (allocateIfcSpaceProgram(this, Step::Id_UNSET));
    }
}

IfcSpaceProgram *ExpressDataSet::cloneIfcSpaceProgram(ExpressDataSet *expressDataSet, const IfcSpaceProgram &obj, const CopyOp &copyop) {
    IfcSpaceProgram *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceProgram(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceProgram_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceProgram *ExpressDataSet::cloneIfcSpaceProgram(const IfcSpaceProgram &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSpaceProgram(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSpaceProgram(this, obj, copyop);
    }
}

IfcSpaceThermalLoadProperties *ExpressDataSet::getIfcSpaceThermalLoadProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSpaceThermalLoadProperties * > (current->second.get());
    }
    else {
        IfcSpaceThermalLoadProperties *ret = static_cast< IfcSpaceThermalLoadProperties * > (allocateIfcSpaceThermalLoadProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSpaceThermalLoadProperties(IfcSpaceThermalLoadProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSpaceThermalLoadProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceThermalLoadProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSpaceThermalLoadProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceThermalLoadProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceThermalLoadProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceThermalLoadProperties > ExpressDataSet::createIfcSpaceThermalLoadProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcSpaceThermalLoadProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSpaceThermalLoadProperties * > (allocateIfcSpaceThermalLoadProperties(this, Step::Id_UNSET));
    }
}

IfcSpaceThermalLoadProperties *ExpressDataSet::cloneIfcSpaceThermalLoadProperties(ExpressDataSet *expressDataSet, const IfcSpaceThermalLoadProperties &obj, const CopyOp &copyop) {
    IfcSpaceThermalLoadProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceThermalLoadProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceThermalLoadProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceThermalLoadProperties *ExpressDataSet::cloneIfcSpaceThermalLoadProperties(const IfcSpaceThermalLoadProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSpaceThermalLoadProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSpaceThermalLoadProperties(this, obj, copyop);
    }
}

IfcSpaceType *ExpressDataSet::getIfcSpaceType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSpaceType * > (current->second.get());
    }
    else {
        IfcSpaceType *ret = static_cast< IfcSpaceType * > (allocateIfcSpaceType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSpaceType(IfcSpaceType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSpaceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSpaceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSpaceType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSpaceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSpaceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSpaceType > ExpressDataSet::createIfcSpaceType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSpaceType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSpaceType * > (allocateIfcSpaceType(this, Step::Id_UNSET));
    }
}

IfcSpaceType *ExpressDataSet::cloneIfcSpaceType(ExpressDataSet *expressDataSet, const IfcSpaceType &obj, const CopyOp &copyop) {
    IfcSpaceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSpaceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSpaceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSpaceType *ExpressDataSet::cloneIfcSpaceType(const IfcSpaceType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSpaceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSpaceType(this, obj, copyop);
    }
}

IfcSphere *ExpressDataSet::getIfcSphere(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSphere * > (current->second.get());
    }
    else {
        IfcSphere *ret = static_cast< IfcSphere * > (allocateIfcSphere(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSphere(IfcSphere *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSphere_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSphere(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSphere *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSphere(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSphere_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSphere > ExpressDataSet::createIfcSphere(bool isVolatile) {
    if (isVolatile) {
        return new IfcSphere(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSphere * > (allocateIfcSphere(this, Step::Id_UNSET));
    }
}

IfcSphere *ExpressDataSet::cloneIfcSphere(ExpressDataSet *expressDataSet, const IfcSphere &obj, const CopyOp &copyop) {
    IfcSphere *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSphere(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSphere_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSphere *ExpressDataSet::cloneIfcSphere(const IfcSphere &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSphere(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSphere(this, obj, copyop);
    }
}

IfcStackTerminalType *ExpressDataSet::getIfcStackTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStackTerminalType * > (current->second.get());
    }
    else {
        IfcStackTerminalType *ret = static_cast< IfcStackTerminalType * > (allocateIfcStackTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStackTerminalType(IfcStackTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStackTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStackTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStackTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStackTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStackTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStackTerminalType > ExpressDataSet::createIfcStackTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcStackTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStackTerminalType * > (allocateIfcStackTerminalType(this, Step::Id_UNSET));
    }
}

IfcStackTerminalType *ExpressDataSet::cloneIfcStackTerminalType(ExpressDataSet *expressDataSet, const IfcStackTerminalType &obj, const CopyOp &copyop) {
    IfcStackTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStackTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStackTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStackTerminalType *ExpressDataSet::cloneIfcStackTerminalType(const IfcStackTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStackTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStackTerminalType(this, obj, copyop);
    }
}

IfcStair *ExpressDataSet::getIfcStair(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStair * > (current->second.get());
    }
    else {
        IfcStair *ret = static_cast< IfcStair * > (allocateIfcStair(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStair(IfcStair *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStair_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStair(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStair *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStair(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStair_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStair > ExpressDataSet::createIfcStair(bool isVolatile) {
    if (isVolatile) {
        return new IfcStair(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStair * > (allocateIfcStair(this, Step::Id_UNSET));
    }
}

IfcStair *ExpressDataSet::cloneIfcStair(ExpressDataSet *expressDataSet, const IfcStair &obj, const CopyOp &copyop) {
    IfcStair *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStair(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStair_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStair *ExpressDataSet::cloneIfcStair(const IfcStair &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStair(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStair(this, obj, copyop);
    }
}

IfcStairFlight *ExpressDataSet::getIfcStairFlight(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStairFlight * > (current->second.get());
    }
    else {
        IfcStairFlight *ret = static_cast< IfcStairFlight * > (allocateIfcStairFlight(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStairFlight(IfcStairFlight *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStairFlight_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStairFlight(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStairFlight *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStairFlight(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStairFlight_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStairFlight > ExpressDataSet::createIfcStairFlight(bool isVolatile) {
    if (isVolatile) {
        return new IfcStairFlight(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStairFlight * > (allocateIfcStairFlight(this, Step::Id_UNSET));
    }
}

IfcStairFlight *ExpressDataSet::cloneIfcStairFlight(ExpressDataSet *expressDataSet, const IfcStairFlight &obj, const CopyOp &copyop) {
    IfcStairFlight *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStairFlight(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStairFlight_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStairFlight *ExpressDataSet::cloneIfcStairFlight(const IfcStairFlight &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStairFlight(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStairFlight(this, obj, copyop);
    }
}

IfcStairFlightType *ExpressDataSet::getIfcStairFlightType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStairFlightType * > (current->second.get());
    }
    else {
        IfcStairFlightType *ret = static_cast< IfcStairFlightType * > (allocateIfcStairFlightType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStairFlightType(IfcStairFlightType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStairFlightType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStairFlightType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStairFlightType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStairFlightType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStairFlightType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStairFlightType > ExpressDataSet::createIfcStairFlightType(bool isVolatile) {
    if (isVolatile) {
        return new IfcStairFlightType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStairFlightType * > (allocateIfcStairFlightType(this, Step::Id_UNSET));
    }
}

IfcStairFlightType *ExpressDataSet::cloneIfcStairFlightType(ExpressDataSet *expressDataSet, const IfcStairFlightType &obj, const CopyOp &copyop) {
    IfcStairFlightType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStairFlightType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStairFlightType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStairFlightType *ExpressDataSet::cloneIfcStairFlightType(const IfcStairFlightType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStairFlightType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStairFlightType(this, obj, copyop);
    }
}

IfcStructuralAnalysisModel *ExpressDataSet::getIfcStructuralAnalysisModel(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralAnalysisModel * > (current->second.get());
    }
    else {
        IfcStructuralAnalysisModel *ret = static_cast< IfcStructuralAnalysisModel * > (allocateIfcStructuralAnalysisModel(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralAnalysisModel(IfcStructuralAnalysisModel *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralAnalysisModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralAnalysisModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralAnalysisModel *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralAnalysisModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralAnalysisModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralAnalysisModel > ExpressDataSet::createIfcStructuralAnalysisModel(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralAnalysisModel(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralAnalysisModel * > (allocateIfcStructuralAnalysisModel(this, Step::Id_UNSET));
    }
}

IfcStructuralAnalysisModel *ExpressDataSet::cloneIfcStructuralAnalysisModel(ExpressDataSet *expressDataSet, const IfcStructuralAnalysisModel &obj, const CopyOp &copyop) {
    IfcStructuralAnalysisModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralAnalysisModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralAnalysisModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralAnalysisModel *ExpressDataSet::cloneIfcStructuralAnalysisModel(const IfcStructuralAnalysisModel &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralAnalysisModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralAnalysisModel(this, obj, copyop);
    }
}

IfcStructuralCurveConnection *ExpressDataSet::getIfcStructuralCurveConnection(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralCurveConnection * > (current->second.get());
    }
    else {
        IfcStructuralCurveConnection *ret = static_cast< IfcStructuralCurveConnection * > (allocateIfcStructuralCurveConnection(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralCurveConnection(IfcStructuralCurveConnection *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralCurveConnection *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveConnection > ExpressDataSet::createIfcStructuralCurveConnection(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralCurveConnection(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralCurveConnection * > (allocateIfcStructuralCurveConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveConnection *ExpressDataSet::cloneIfcStructuralCurveConnection(ExpressDataSet *expressDataSet, const IfcStructuralCurveConnection &obj, const CopyOp &copyop) {
    IfcStructuralCurveConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveConnection *ExpressDataSet::cloneIfcStructuralCurveConnection(const IfcStructuralCurveConnection &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralCurveConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralCurveConnection(this, obj, copyop);
    }
}

IfcStructuralCurveMember *ExpressDataSet::getIfcStructuralCurveMember(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralCurveMember * > (current->second.get());
    }
    else {
        IfcStructuralCurveMember *ret = static_cast< IfcStructuralCurveMember * > (allocateIfcStructuralCurveMember(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralCurveMember(IfcStructuralCurveMember *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralCurveMember *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveMember > ExpressDataSet::createIfcStructuralCurveMember(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralCurveMember(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralCurveMember * > (allocateIfcStructuralCurveMember(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveMember *ExpressDataSet::cloneIfcStructuralCurveMember(ExpressDataSet *expressDataSet, const IfcStructuralCurveMember &obj, const CopyOp &copyop) {
    IfcStructuralCurveMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveMember *ExpressDataSet::cloneIfcStructuralCurveMember(const IfcStructuralCurveMember &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralCurveMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralCurveMember(this, obj, copyop);
    }
}

IfcStructuralCurveMemberVarying *ExpressDataSet::getIfcStructuralCurveMemberVarying(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralCurveMemberVarying * > (current->second.get());
    }
    else {
        IfcStructuralCurveMemberVarying *ret = static_cast< IfcStructuralCurveMemberVarying * > (allocateIfcStructuralCurveMemberVarying(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralCurveMemberVarying(IfcStructuralCurveMemberVarying *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralCurveMemberVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralCurveMemberVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralCurveMemberVarying *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralCurveMemberVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralCurveMemberVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralCurveMemberVarying > ExpressDataSet::createIfcStructuralCurveMemberVarying(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralCurveMemberVarying(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralCurveMemberVarying * > (allocateIfcStructuralCurveMemberVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralCurveMemberVarying *ExpressDataSet::cloneIfcStructuralCurveMemberVarying(ExpressDataSet *expressDataSet, const IfcStructuralCurveMemberVarying &obj, const CopyOp &copyop) {
    IfcStructuralCurveMemberVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralCurveMemberVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralCurveMemberVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralCurveMemberVarying *ExpressDataSet::cloneIfcStructuralCurveMemberVarying(const IfcStructuralCurveMemberVarying &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralCurveMemberVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralCurveMemberVarying(this, obj, copyop);
    }
}

IfcStructuralLinearAction *ExpressDataSet::getIfcStructuralLinearAction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLinearAction * > (current->second.get());
    }
    else {
        IfcStructuralLinearAction *ret = static_cast< IfcStructuralLinearAction * > (allocateIfcStructuralLinearAction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLinearAction(IfcStructuralLinearAction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLinearAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLinearAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLinearAction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLinearAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLinearAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLinearAction > ExpressDataSet::createIfcStructuralLinearAction(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLinearAction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLinearAction * > (allocateIfcStructuralLinearAction(this, Step::Id_UNSET));
    }
}

IfcStructuralLinearAction *ExpressDataSet::cloneIfcStructuralLinearAction(ExpressDataSet *expressDataSet, const IfcStructuralLinearAction &obj, const CopyOp &copyop) {
    IfcStructuralLinearAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLinearAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLinearAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLinearAction *ExpressDataSet::cloneIfcStructuralLinearAction(const IfcStructuralLinearAction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLinearAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLinearAction(this, obj, copyop);
    }
}

IfcStructuralLinearActionVarying *ExpressDataSet::getIfcStructuralLinearActionVarying(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLinearActionVarying * > (current->second.get());
    }
    else {
        IfcStructuralLinearActionVarying *ret = static_cast< IfcStructuralLinearActionVarying * > (allocateIfcStructuralLinearActionVarying(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLinearActionVarying(IfcStructuralLinearActionVarying *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLinearActionVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLinearActionVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLinearActionVarying *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLinearActionVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLinearActionVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLinearActionVarying > ExpressDataSet::createIfcStructuralLinearActionVarying(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLinearActionVarying(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLinearActionVarying * > (allocateIfcStructuralLinearActionVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralLinearActionVarying *ExpressDataSet::cloneIfcStructuralLinearActionVarying(ExpressDataSet *expressDataSet, const IfcStructuralLinearActionVarying &obj, const CopyOp &copyop) {
    IfcStructuralLinearActionVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLinearActionVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLinearActionVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLinearActionVarying *ExpressDataSet::cloneIfcStructuralLinearActionVarying(const IfcStructuralLinearActionVarying &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLinearActionVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLinearActionVarying(this, obj, copyop);
    }
}

IfcStructuralLoadGroup *ExpressDataSet::getIfcStructuralLoadGroup(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadGroup * > (current->second.get());
    }
    else {
        IfcStructuralLoadGroup *ret = static_cast< IfcStructuralLoadGroup * > (allocateIfcStructuralLoadGroup(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadGroup(IfcStructuralLoadGroup *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadGroup *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadGroup > ExpressDataSet::createIfcStructuralLoadGroup(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadGroup(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadGroup * > (allocateIfcStructuralLoadGroup(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadGroup *ExpressDataSet::cloneIfcStructuralLoadGroup(ExpressDataSet *expressDataSet, const IfcStructuralLoadGroup &obj, const CopyOp &copyop) {
    IfcStructuralLoadGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadGroup *ExpressDataSet::cloneIfcStructuralLoadGroup(const IfcStructuralLoadGroup &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadGroup(this, obj, copyop);
    }
}

IfcStructuralLoadLinearForce *ExpressDataSet::getIfcStructuralLoadLinearForce(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadLinearForce * > (current->second.get());
    }
    else {
        IfcStructuralLoadLinearForce *ret = static_cast< IfcStructuralLoadLinearForce * > (allocateIfcStructuralLoadLinearForce(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadLinearForce(IfcStructuralLoadLinearForce *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadLinearForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadLinearForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadLinearForce *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadLinearForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadLinearForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadLinearForce > ExpressDataSet::createIfcStructuralLoadLinearForce(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadLinearForce(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadLinearForce * > (allocateIfcStructuralLoadLinearForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadLinearForce *ExpressDataSet::cloneIfcStructuralLoadLinearForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadLinearForce &obj, const CopyOp &copyop) {
    IfcStructuralLoadLinearForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadLinearForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadLinearForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadLinearForce *ExpressDataSet::cloneIfcStructuralLoadLinearForce(const IfcStructuralLoadLinearForce &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadLinearForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadLinearForce(this, obj, copyop);
    }
}

IfcStructuralLoadPlanarForce *ExpressDataSet::getIfcStructuralLoadPlanarForce(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadPlanarForce * > (current->second.get());
    }
    else {
        IfcStructuralLoadPlanarForce *ret = static_cast< IfcStructuralLoadPlanarForce * > (allocateIfcStructuralLoadPlanarForce(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadPlanarForce(IfcStructuralLoadPlanarForce *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadPlanarForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadPlanarForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadPlanarForce *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadPlanarForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadPlanarForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadPlanarForce > ExpressDataSet::createIfcStructuralLoadPlanarForce(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadPlanarForce(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadPlanarForce * > (allocateIfcStructuralLoadPlanarForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadPlanarForce *ExpressDataSet::cloneIfcStructuralLoadPlanarForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadPlanarForce &obj, const CopyOp &copyop) {
    IfcStructuralLoadPlanarForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadPlanarForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadPlanarForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadPlanarForce *ExpressDataSet::cloneIfcStructuralLoadPlanarForce(const IfcStructuralLoadPlanarForce &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadPlanarForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadPlanarForce(this, obj, copyop);
    }
}

IfcStructuralLoadSingleDisplacement *ExpressDataSet::getIfcStructuralLoadSingleDisplacement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadSingleDisplacement * > (current->second.get());
    }
    else {
        IfcStructuralLoadSingleDisplacement *ret = static_cast< IfcStructuralLoadSingleDisplacement * > (allocateIfcStructuralLoadSingleDisplacement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadSingleDisplacement(IfcStructuralLoadSingleDisplacement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleDisplacement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleDisplacement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadSingleDisplacement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleDisplacement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleDisplacement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleDisplacement > ExpressDataSet::createIfcStructuralLoadSingleDisplacement(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadSingleDisplacement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadSingleDisplacement * > (allocateIfcStructuralLoadSingleDisplacement(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleDisplacement *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleDisplacement &obj, const CopyOp &copyop) {
    IfcStructuralLoadSingleDisplacement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleDisplacement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleDisplacement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleDisplacement *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(const IfcStructuralLoadSingleDisplacement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacement(this, obj, copyop);
    }
}

IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::getIfcStructuralLoadSingleDisplacementDistortion(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (current->second.get());
    }
    else {
        IfcStructuralLoadSingleDisplacementDistortion *ret = static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (allocateIfcStructuralLoadSingleDisplacementDistortion(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadSingleDisplacementDistortion(IfcStructuralLoadSingleDisplacementDistortion *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleDisplacementDistortion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleDisplacementDistortion(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadSingleDisplacementDistortion *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleDisplacementDistortion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleDisplacementDistortion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleDisplacementDistortion > ExpressDataSet::createIfcStructuralLoadSingleDisplacementDistortion(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadSingleDisplacementDistortion(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadSingleDisplacementDistortion * > (allocateIfcStructuralLoadSingleDisplacementDistortion(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleDisplacementDistortion &obj, const CopyOp &copyop) {
    IfcStructuralLoadSingleDisplacementDistortion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleDisplacementDistortion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleDisplacementDistortion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleDisplacementDistortion *ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(const IfcStructuralLoadSingleDisplacementDistortion &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadSingleDisplacementDistortion(this, obj, copyop);
    }
}

IfcStructuralLoadSingleForce *ExpressDataSet::getIfcStructuralLoadSingleForce(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadSingleForce * > (current->second.get());
    }
    else {
        IfcStructuralLoadSingleForce *ret = static_cast< IfcStructuralLoadSingleForce * > (allocateIfcStructuralLoadSingleForce(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadSingleForce(IfcStructuralLoadSingleForce *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleForce_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleForce(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadSingleForce *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleForce(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleForce_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleForce > ExpressDataSet::createIfcStructuralLoadSingleForce(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadSingleForce(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadSingleForce * > (allocateIfcStructuralLoadSingleForce(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleForce *ExpressDataSet::cloneIfcStructuralLoadSingleForce(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleForce &obj, const CopyOp &copyop) {
    IfcStructuralLoadSingleForce *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleForce(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleForce_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleForce *ExpressDataSet::cloneIfcStructuralLoadSingleForce(const IfcStructuralLoadSingleForce &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForce(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForce(this, obj, copyop);
    }
}

IfcStructuralLoadSingleForceWarping *ExpressDataSet::getIfcStructuralLoadSingleForceWarping(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadSingleForceWarping * > (current->second.get());
    }
    else {
        IfcStructuralLoadSingleForceWarping *ret = static_cast< IfcStructuralLoadSingleForceWarping * > (allocateIfcStructuralLoadSingleForceWarping(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadSingleForceWarping(IfcStructuralLoadSingleForceWarping *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadSingleForceWarping_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadSingleForceWarping(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadSingleForceWarping *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadSingleForceWarping(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadSingleForceWarping_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadSingleForceWarping > ExpressDataSet::createIfcStructuralLoadSingleForceWarping(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadSingleForceWarping(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadSingleForceWarping * > (allocateIfcStructuralLoadSingleForceWarping(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadSingleForceWarping *ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(ExpressDataSet *expressDataSet, const IfcStructuralLoadSingleForceWarping &obj, const CopyOp &copyop) {
    IfcStructuralLoadSingleForceWarping *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadSingleForceWarping(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadSingleForceWarping_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadSingleForceWarping *ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(const IfcStructuralLoadSingleForceWarping &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadSingleForceWarping(this, obj, copyop);
    }
}

IfcStructuralLoadTemperature *ExpressDataSet::getIfcStructuralLoadTemperature(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralLoadTemperature * > (current->second.get());
    }
    else {
        IfcStructuralLoadTemperature *ret = static_cast< IfcStructuralLoadTemperature * > (allocateIfcStructuralLoadTemperature(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralLoadTemperature(IfcStructuralLoadTemperature *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralLoadTemperature_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralLoadTemperature(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralLoadTemperature *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralLoadTemperature(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralLoadTemperature_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralLoadTemperature > ExpressDataSet::createIfcStructuralLoadTemperature(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralLoadTemperature(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralLoadTemperature * > (allocateIfcStructuralLoadTemperature(this, Step::Id_UNSET));
    }
}

IfcStructuralLoadTemperature *ExpressDataSet::cloneIfcStructuralLoadTemperature(ExpressDataSet *expressDataSet, const IfcStructuralLoadTemperature &obj, const CopyOp &copyop) {
    IfcStructuralLoadTemperature *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralLoadTemperature(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralLoadTemperature_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralLoadTemperature *ExpressDataSet::cloneIfcStructuralLoadTemperature(const IfcStructuralLoadTemperature &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralLoadTemperature(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralLoadTemperature(this, obj, copyop);
    }
}

IfcStructuralPlanarAction *ExpressDataSet::getIfcStructuralPlanarAction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralPlanarAction * > (current->second.get());
    }
    else {
        IfcStructuralPlanarAction *ret = static_cast< IfcStructuralPlanarAction * > (allocateIfcStructuralPlanarAction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralPlanarAction(IfcStructuralPlanarAction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralPlanarAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPlanarAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralPlanarAction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPlanarAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPlanarAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPlanarAction > ExpressDataSet::createIfcStructuralPlanarAction(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralPlanarAction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralPlanarAction * > (allocateIfcStructuralPlanarAction(this, Step::Id_UNSET));
    }
}

IfcStructuralPlanarAction *ExpressDataSet::cloneIfcStructuralPlanarAction(ExpressDataSet *expressDataSet, const IfcStructuralPlanarAction &obj, const CopyOp &copyop) {
    IfcStructuralPlanarAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPlanarAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPlanarAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPlanarAction *ExpressDataSet::cloneIfcStructuralPlanarAction(const IfcStructuralPlanarAction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralPlanarAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralPlanarAction(this, obj, copyop);
    }
}

IfcStructuralPlanarActionVarying *ExpressDataSet::getIfcStructuralPlanarActionVarying(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralPlanarActionVarying * > (current->second.get());
    }
    else {
        IfcStructuralPlanarActionVarying *ret = static_cast< IfcStructuralPlanarActionVarying * > (allocateIfcStructuralPlanarActionVarying(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralPlanarActionVarying(IfcStructuralPlanarActionVarying *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralPlanarActionVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPlanarActionVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralPlanarActionVarying *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPlanarActionVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPlanarActionVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPlanarActionVarying > ExpressDataSet::createIfcStructuralPlanarActionVarying(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralPlanarActionVarying(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralPlanarActionVarying * > (allocateIfcStructuralPlanarActionVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralPlanarActionVarying *ExpressDataSet::cloneIfcStructuralPlanarActionVarying(ExpressDataSet *expressDataSet, const IfcStructuralPlanarActionVarying &obj, const CopyOp &copyop) {
    IfcStructuralPlanarActionVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPlanarActionVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPlanarActionVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPlanarActionVarying *ExpressDataSet::cloneIfcStructuralPlanarActionVarying(const IfcStructuralPlanarActionVarying &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralPlanarActionVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralPlanarActionVarying(this, obj, copyop);
    }
}

IfcStructuralPointAction *ExpressDataSet::getIfcStructuralPointAction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralPointAction * > (current->second.get());
    }
    else {
        IfcStructuralPointAction *ret = static_cast< IfcStructuralPointAction * > (allocateIfcStructuralPointAction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralPointAction(IfcStructuralPointAction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointAction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointAction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralPointAction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointAction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointAction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointAction > ExpressDataSet::createIfcStructuralPointAction(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralPointAction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralPointAction * > (allocateIfcStructuralPointAction(this, Step::Id_UNSET));
    }
}

IfcStructuralPointAction *ExpressDataSet::cloneIfcStructuralPointAction(ExpressDataSet *expressDataSet, const IfcStructuralPointAction &obj, const CopyOp &copyop) {
    IfcStructuralPointAction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointAction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointAction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointAction *ExpressDataSet::cloneIfcStructuralPointAction(const IfcStructuralPointAction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralPointAction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralPointAction(this, obj, copyop);
    }
}

IfcStructuralPointConnection *ExpressDataSet::getIfcStructuralPointConnection(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralPointConnection * > (current->second.get());
    }
    else {
        IfcStructuralPointConnection *ret = static_cast< IfcStructuralPointConnection * > (allocateIfcStructuralPointConnection(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralPointConnection(IfcStructuralPointConnection *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralPointConnection *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointConnection > ExpressDataSet::createIfcStructuralPointConnection(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralPointConnection(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralPointConnection * > (allocateIfcStructuralPointConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralPointConnection *ExpressDataSet::cloneIfcStructuralPointConnection(ExpressDataSet *expressDataSet, const IfcStructuralPointConnection &obj, const CopyOp &copyop) {
    IfcStructuralPointConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointConnection *ExpressDataSet::cloneIfcStructuralPointConnection(const IfcStructuralPointConnection &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralPointConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralPointConnection(this, obj, copyop);
    }
}

IfcStructuralPointReaction *ExpressDataSet::getIfcStructuralPointReaction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralPointReaction * > (current->second.get());
    }
    else {
        IfcStructuralPointReaction *ret = static_cast< IfcStructuralPointReaction * > (allocateIfcStructuralPointReaction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralPointReaction(IfcStructuralPointReaction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralPointReaction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralPointReaction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralPointReaction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralPointReaction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralPointReaction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralPointReaction > ExpressDataSet::createIfcStructuralPointReaction(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralPointReaction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralPointReaction * > (allocateIfcStructuralPointReaction(this, Step::Id_UNSET));
    }
}

IfcStructuralPointReaction *ExpressDataSet::cloneIfcStructuralPointReaction(ExpressDataSet *expressDataSet, const IfcStructuralPointReaction &obj, const CopyOp &copyop) {
    IfcStructuralPointReaction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralPointReaction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralPointReaction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralPointReaction *ExpressDataSet::cloneIfcStructuralPointReaction(const IfcStructuralPointReaction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralPointReaction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralPointReaction(this, obj, copyop);
    }
}

IfcStructuralProfileProperties *ExpressDataSet::getIfcStructuralProfileProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralProfileProperties * > (current->second.get());
    }
    else {
        IfcStructuralProfileProperties *ret = static_cast< IfcStructuralProfileProperties * > (allocateIfcStructuralProfileProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralProfileProperties(IfcStructuralProfileProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralProfileProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralProfileProperties > ExpressDataSet::createIfcStructuralProfileProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralProfileProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralProfileProperties * > (allocateIfcStructuralProfileProperties(this, Step::Id_UNSET));
    }
}

IfcStructuralProfileProperties *ExpressDataSet::cloneIfcStructuralProfileProperties(ExpressDataSet *expressDataSet, const IfcStructuralProfileProperties &obj, const CopyOp &copyop) {
    IfcStructuralProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralProfileProperties *ExpressDataSet::cloneIfcStructuralProfileProperties(const IfcStructuralProfileProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralProfileProperties(this, obj, copyop);
    }
}

IfcStructuralResultGroup *ExpressDataSet::getIfcStructuralResultGroup(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralResultGroup * > (current->second.get());
    }
    else {
        IfcStructuralResultGroup *ret = static_cast< IfcStructuralResultGroup * > (allocateIfcStructuralResultGroup(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralResultGroup(IfcStructuralResultGroup *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralResultGroup_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralResultGroup(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralResultGroup *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralResultGroup(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralResultGroup_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralResultGroup > ExpressDataSet::createIfcStructuralResultGroup(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralResultGroup(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralResultGroup * > (allocateIfcStructuralResultGroup(this, Step::Id_UNSET));
    }
}

IfcStructuralResultGroup *ExpressDataSet::cloneIfcStructuralResultGroup(ExpressDataSet *expressDataSet, const IfcStructuralResultGroup &obj, const CopyOp &copyop) {
    IfcStructuralResultGroup *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralResultGroup(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralResultGroup_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralResultGroup *ExpressDataSet::cloneIfcStructuralResultGroup(const IfcStructuralResultGroup &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralResultGroup(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralResultGroup(this, obj, copyop);
    }
}

IfcStructuralSteelProfileProperties *ExpressDataSet::getIfcStructuralSteelProfileProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralSteelProfileProperties * > (current->second.get());
    }
    else {
        IfcStructuralSteelProfileProperties *ret = static_cast< IfcStructuralSteelProfileProperties * > (allocateIfcStructuralSteelProfileProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralSteelProfileProperties(IfcStructuralSteelProfileProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralSteelProfileProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSteelProfileProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralSteelProfileProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSteelProfileProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSteelProfileProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSteelProfileProperties > ExpressDataSet::createIfcStructuralSteelProfileProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralSteelProfileProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralSteelProfileProperties * > (allocateIfcStructuralSteelProfileProperties(this, Step::Id_UNSET));
    }
}

IfcStructuralSteelProfileProperties *ExpressDataSet::cloneIfcStructuralSteelProfileProperties(ExpressDataSet *expressDataSet, const IfcStructuralSteelProfileProperties &obj, const CopyOp &copyop) {
    IfcStructuralSteelProfileProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSteelProfileProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSteelProfileProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSteelProfileProperties *ExpressDataSet::cloneIfcStructuralSteelProfileProperties(const IfcStructuralSteelProfileProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralSteelProfileProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralSteelProfileProperties(this, obj, copyop);
    }
}

IfcStructuralSurfaceConnection *ExpressDataSet::getIfcStructuralSurfaceConnection(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralSurfaceConnection * > (current->second.get());
    }
    else {
        IfcStructuralSurfaceConnection *ret = static_cast< IfcStructuralSurfaceConnection * > (allocateIfcStructuralSurfaceConnection(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralSurfaceConnection(IfcStructuralSurfaceConnection *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceConnection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceConnection(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralSurfaceConnection *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceConnection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceConnection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceConnection > ExpressDataSet::createIfcStructuralSurfaceConnection(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralSurfaceConnection(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralSurfaceConnection * > (allocateIfcStructuralSurfaceConnection(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceConnection *ExpressDataSet::cloneIfcStructuralSurfaceConnection(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceConnection &obj, const CopyOp &copyop) {
    IfcStructuralSurfaceConnection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceConnection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceConnection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceConnection *ExpressDataSet::cloneIfcStructuralSurfaceConnection(const IfcStructuralSurfaceConnection &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralSurfaceConnection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralSurfaceConnection(this, obj, copyop);
    }
}

IfcStructuralSurfaceMember *ExpressDataSet::getIfcStructuralSurfaceMember(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralSurfaceMember * > (current->second.get());
    }
    else {
        IfcStructuralSurfaceMember *ret = static_cast< IfcStructuralSurfaceMember * > (allocateIfcStructuralSurfaceMember(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralSurfaceMember(IfcStructuralSurfaceMember *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceMember_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceMember(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralSurfaceMember *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceMember(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceMember_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceMember > ExpressDataSet::createIfcStructuralSurfaceMember(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralSurfaceMember(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralSurfaceMember * > (allocateIfcStructuralSurfaceMember(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceMember *ExpressDataSet::cloneIfcStructuralSurfaceMember(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceMember &obj, const CopyOp &copyop) {
    IfcStructuralSurfaceMember *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceMember(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceMember_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceMember *ExpressDataSet::cloneIfcStructuralSurfaceMember(const IfcStructuralSurfaceMember &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralSurfaceMember(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralSurfaceMember(this, obj, copyop);
    }
}

IfcStructuralSurfaceMemberVarying *ExpressDataSet::getIfcStructuralSurfaceMemberVarying(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuralSurfaceMemberVarying * > (current->second.get());
    }
    else {
        IfcStructuralSurfaceMemberVarying *ret = static_cast< IfcStructuralSurfaceMemberVarying * > (allocateIfcStructuralSurfaceMemberVarying(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuralSurfaceMemberVarying(IfcStructuralSurfaceMemberVarying *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuralSurfaceMemberVarying_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuralSurfaceMemberVarying(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuralSurfaceMemberVarying *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuralSurfaceMemberVarying(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuralSurfaceMemberVarying_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuralSurfaceMemberVarying > ExpressDataSet::createIfcStructuralSurfaceMemberVarying(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuralSurfaceMemberVarying(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuralSurfaceMemberVarying * > (allocateIfcStructuralSurfaceMemberVarying(this, Step::Id_UNSET));
    }
}

IfcStructuralSurfaceMemberVarying *ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(ExpressDataSet *expressDataSet, const IfcStructuralSurfaceMemberVarying &obj, const CopyOp &copyop) {
    IfcStructuralSurfaceMemberVarying *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuralSurfaceMemberVarying(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuralSurfaceMemberVarying_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuralSurfaceMemberVarying *ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(const IfcStructuralSurfaceMemberVarying &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuralSurfaceMemberVarying(this, obj, copyop);
    }
}

IfcStructuredDimensionCallout *ExpressDataSet::getIfcStructuredDimensionCallout(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStructuredDimensionCallout * > (current->second.get());
    }
    else {
        IfcStructuredDimensionCallout *ret = static_cast< IfcStructuredDimensionCallout * > (allocateIfcStructuredDimensionCallout(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStructuredDimensionCallout(IfcStructuredDimensionCallout *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStructuredDimensionCallout_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStructuredDimensionCallout(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStructuredDimensionCallout *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStructuredDimensionCallout(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStructuredDimensionCallout_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStructuredDimensionCallout > ExpressDataSet::createIfcStructuredDimensionCallout(bool isVolatile) {
    if (isVolatile) {
        return new IfcStructuredDimensionCallout(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStructuredDimensionCallout * > (allocateIfcStructuredDimensionCallout(this, Step::Id_UNSET));
    }
}

IfcStructuredDimensionCallout *ExpressDataSet::cloneIfcStructuredDimensionCallout(ExpressDataSet *expressDataSet, const IfcStructuredDimensionCallout &obj, const CopyOp &copyop) {
    IfcStructuredDimensionCallout *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStructuredDimensionCallout(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStructuredDimensionCallout_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStructuredDimensionCallout *ExpressDataSet::cloneIfcStructuredDimensionCallout(const IfcStructuredDimensionCallout &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStructuredDimensionCallout(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStructuredDimensionCallout(this, obj, copyop);
    }
}

IfcStyledItem *ExpressDataSet::getIfcStyledItem(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStyledItem * > (current->second.get());
    }
    else {
        IfcStyledItem *ret = static_cast< IfcStyledItem * > (allocateIfcStyledItem(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStyledItem(IfcStyledItem *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStyledItem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStyledItem(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStyledItem *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStyledItem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStyledItem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStyledItem > ExpressDataSet::createIfcStyledItem(bool isVolatile) {
    if (isVolatile) {
        return new IfcStyledItem(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStyledItem * > (allocateIfcStyledItem(this, Step::Id_UNSET));
    }
}

IfcStyledItem *ExpressDataSet::cloneIfcStyledItem(ExpressDataSet *expressDataSet, const IfcStyledItem &obj, const CopyOp &copyop) {
    IfcStyledItem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStyledItem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStyledItem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStyledItem *ExpressDataSet::cloneIfcStyledItem(const IfcStyledItem &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStyledItem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStyledItem(this, obj, copyop);
    }
}

IfcStyledRepresentation *ExpressDataSet::getIfcStyledRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcStyledRepresentation * > (current->second.get());
    }
    else {
        IfcStyledRepresentation *ret = static_cast< IfcStyledRepresentation * > (allocateIfcStyledRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcStyledRepresentation(IfcStyledRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcStyledRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcStyledRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcStyledRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcStyledRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcStyledRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcStyledRepresentation > ExpressDataSet::createIfcStyledRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcStyledRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcStyledRepresentation * > (allocateIfcStyledRepresentation(this, Step::Id_UNSET));
    }
}

IfcStyledRepresentation *ExpressDataSet::cloneIfcStyledRepresentation(ExpressDataSet *expressDataSet, const IfcStyledRepresentation &obj, const CopyOp &copyop) {
    IfcStyledRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcStyledRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcStyledRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcStyledRepresentation *ExpressDataSet::cloneIfcStyledRepresentation(const IfcStyledRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcStyledRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcStyledRepresentation(this, obj, copyop);
    }
}

IfcSubContractResource *ExpressDataSet::getIfcSubContractResource(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSubContractResource * > (current->second.get());
    }
    else {
        IfcSubContractResource *ret = static_cast< IfcSubContractResource * > (allocateIfcSubContractResource(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSubContractResource(IfcSubContractResource *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSubContractResource_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSubContractResource(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSubContractResource *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSubContractResource(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSubContractResource_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSubContractResource > ExpressDataSet::createIfcSubContractResource(bool isVolatile) {
    if (isVolatile) {
        return new IfcSubContractResource(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSubContractResource * > (allocateIfcSubContractResource(this, Step::Id_UNSET));
    }
}

IfcSubContractResource *ExpressDataSet::cloneIfcSubContractResource(ExpressDataSet *expressDataSet, const IfcSubContractResource &obj, const CopyOp &copyop) {
    IfcSubContractResource *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSubContractResource(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSubContractResource_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSubContractResource *ExpressDataSet::cloneIfcSubContractResource(const IfcSubContractResource &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSubContractResource(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSubContractResource(this, obj, copyop);
    }
}

IfcSubedge *ExpressDataSet::getIfcSubedge(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSubedge * > (current->second.get());
    }
    else {
        IfcSubedge *ret = static_cast< IfcSubedge * > (allocateIfcSubedge(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSubedge(IfcSubedge *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSubedge_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSubedge(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSubedge *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSubedge(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSubedge_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSubedge > ExpressDataSet::createIfcSubedge(bool isVolatile) {
    if (isVolatile) {
        return new IfcSubedge(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSubedge * > (allocateIfcSubedge(this, Step::Id_UNSET));
    }
}

IfcSubedge *ExpressDataSet::cloneIfcSubedge(ExpressDataSet *expressDataSet, const IfcSubedge &obj, const CopyOp &copyop) {
    IfcSubedge *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSubedge(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSubedge_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSubedge *ExpressDataSet::cloneIfcSubedge(const IfcSubedge &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSubedge(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSubedge(this, obj, copyop);
    }
}

IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::getIfcSurfaceCurveSweptAreaSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceCurveSweptAreaSolid * > (current->second.get());
    }
    else {
        IfcSurfaceCurveSweptAreaSolid *ret = static_cast< IfcSurfaceCurveSweptAreaSolid * > (allocateIfcSurfaceCurveSweptAreaSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceCurveSweptAreaSolid(IfcSurfaceCurveSweptAreaSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceCurveSweptAreaSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceCurveSweptAreaSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceCurveSweptAreaSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceCurveSweptAreaSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceCurveSweptAreaSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceCurveSweptAreaSolid > ExpressDataSet::createIfcSurfaceCurveSweptAreaSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceCurveSweptAreaSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceCurveSweptAreaSolid * > (allocateIfcSurfaceCurveSweptAreaSolid(this, Step::Id_UNSET));
    }
}

IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(ExpressDataSet *expressDataSet, const IfcSurfaceCurveSweptAreaSolid &obj, const CopyOp &copyop) {
    IfcSurfaceCurveSweptAreaSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceCurveSweptAreaSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceCurveSweptAreaSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceCurveSweptAreaSolid *ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(const IfcSurfaceCurveSweptAreaSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceCurveSweptAreaSolid(this, obj, copyop);
    }
}

IfcSurfaceOfLinearExtrusion *ExpressDataSet::getIfcSurfaceOfLinearExtrusion(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceOfLinearExtrusion * > (current->second.get());
    }
    else {
        IfcSurfaceOfLinearExtrusion *ret = static_cast< IfcSurfaceOfLinearExtrusion * > (allocateIfcSurfaceOfLinearExtrusion(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceOfLinearExtrusion(IfcSurfaceOfLinearExtrusion *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceOfLinearExtrusion_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceOfLinearExtrusion(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceOfLinearExtrusion *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceOfLinearExtrusion(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceOfLinearExtrusion_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceOfLinearExtrusion > ExpressDataSet::createIfcSurfaceOfLinearExtrusion(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceOfLinearExtrusion(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceOfLinearExtrusion * > (allocateIfcSurfaceOfLinearExtrusion(this, Step::Id_UNSET));
    }
}

IfcSurfaceOfLinearExtrusion *ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(ExpressDataSet *expressDataSet, const IfcSurfaceOfLinearExtrusion &obj, const CopyOp &copyop) {
    IfcSurfaceOfLinearExtrusion *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceOfLinearExtrusion(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceOfLinearExtrusion_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceOfLinearExtrusion *ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(const IfcSurfaceOfLinearExtrusion &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceOfLinearExtrusion(this, obj, copyop);
    }
}

IfcSurfaceOfRevolution *ExpressDataSet::getIfcSurfaceOfRevolution(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceOfRevolution * > (current->second.get());
    }
    else {
        IfcSurfaceOfRevolution *ret = static_cast< IfcSurfaceOfRevolution * > (allocateIfcSurfaceOfRevolution(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceOfRevolution(IfcSurfaceOfRevolution *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceOfRevolution_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceOfRevolution(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceOfRevolution *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceOfRevolution(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceOfRevolution_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceOfRevolution > ExpressDataSet::createIfcSurfaceOfRevolution(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceOfRevolution(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceOfRevolution * > (allocateIfcSurfaceOfRevolution(this, Step::Id_UNSET));
    }
}

IfcSurfaceOfRevolution *ExpressDataSet::cloneIfcSurfaceOfRevolution(ExpressDataSet *expressDataSet, const IfcSurfaceOfRevolution &obj, const CopyOp &copyop) {
    IfcSurfaceOfRevolution *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceOfRevolution(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceOfRevolution_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceOfRevolution *ExpressDataSet::cloneIfcSurfaceOfRevolution(const IfcSurfaceOfRevolution &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceOfRevolution(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceOfRevolution(this, obj, copyop);
    }
}

IfcSurfaceStyle *ExpressDataSet::getIfcSurfaceStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyle * > (current->second.get());
    }
    else {
        IfcSurfaceStyle *ret = static_cast< IfcSurfaceStyle * > (allocateIfcSurfaceStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyle(IfcSurfaceStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyle > ExpressDataSet::createIfcSurfaceStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyle * > (allocateIfcSurfaceStyle(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyle *ExpressDataSet::cloneIfcSurfaceStyle(ExpressDataSet *expressDataSet, const IfcSurfaceStyle &obj, const CopyOp &copyop) {
    IfcSurfaceStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyle *ExpressDataSet::cloneIfcSurfaceStyle(const IfcSurfaceStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyle(this, obj, copyop);
    }
}

IfcSurfaceStyleLighting *ExpressDataSet::getIfcSurfaceStyleLighting(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyleLighting * > (current->second.get());
    }
    else {
        IfcSurfaceStyleLighting *ret = static_cast< IfcSurfaceStyleLighting * > (allocateIfcSurfaceStyleLighting(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyleLighting(IfcSurfaceStyleLighting *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleLighting_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleLighting(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyleLighting *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleLighting(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleLighting_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleLighting > ExpressDataSet::createIfcSurfaceStyleLighting(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyleLighting(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyleLighting * > (allocateIfcSurfaceStyleLighting(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleLighting *ExpressDataSet::cloneIfcSurfaceStyleLighting(ExpressDataSet *expressDataSet, const IfcSurfaceStyleLighting &obj, const CopyOp &copyop) {
    IfcSurfaceStyleLighting *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleLighting(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleLighting_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleLighting *ExpressDataSet::cloneIfcSurfaceStyleLighting(const IfcSurfaceStyleLighting &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyleLighting(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyleLighting(this, obj, copyop);
    }
}

IfcSurfaceStyleRefraction *ExpressDataSet::getIfcSurfaceStyleRefraction(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyleRefraction * > (current->second.get());
    }
    else {
        IfcSurfaceStyleRefraction *ret = static_cast< IfcSurfaceStyleRefraction * > (allocateIfcSurfaceStyleRefraction(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyleRefraction(IfcSurfaceStyleRefraction *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleRefraction_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleRefraction(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyleRefraction *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleRefraction(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleRefraction_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleRefraction > ExpressDataSet::createIfcSurfaceStyleRefraction(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyleRefraction(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyleRefraction * > (allocateIfcSurfaceStyleRefraction(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleRefraction *ExpressDataSet::cloneIfcSurfaceStyleRefraction(ExpressDataSet *expressDataSet, const IfcSurfaceStyleRefraction &obj, const CopyOp &copyop) {
    IfcSurfaceStyleRefraction *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleRefraction(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleRefraction_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleRefraction *ExpressDataSet::cloneIfcSurfaceStyleRefraction(const IfcSurfaceStyleRefraction &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyleRefraction(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyleRefraction(this, obj, copyop);
    }
}

IfcSurfaceStyleRendering *ExpressDataSet::getIfcSurfaceStyleRendering(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyleRendering * > (current->second.get());
    }
    else {
        IfcSurfaceStyleRendering *ret = static_cast< IfcSurfaceStyleRendering * > (allocateIfcSurfaceStyleRendering(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyleRendering(IfcSurfaceStyleRendering *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleRendering_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleRendering(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyleRendering *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleRendering(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleRendering_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleRendering > ExpressDataSet::createIfcSurfaceStyleRendering(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyleRendering(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyleRendering * > (allocateIfcSurfaceStyleRendering(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleRendering *ExpressDataSet::cloneIfcSurfaceStyleRendering(ExpressDataSet *expressDataSet, const IfcSurfaceStyleRendering &obj, const CopyOp &copyop) {
    IfcSurfaceStyleRendering *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleRendering(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleRendering_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleRendering *ExpressDataSet::cloneIfcSurfaceStyleRendering(const IfcSurfaceStyleRendering &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyleRendering(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyleRendering(this, obj, copyop);
    }
}

IfcSurfaceStyleShading *ExpressDataSet::getIfcSurfaceStyleShading(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyleShading * > (current->second.get());
    }
    else {
        IfcSurfaceStyleShading *ret = static_cast< IfcSurfaceStyleShading * > (allocateIfcSurfaceStyleShading(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyleShading(IfcSurfaceStyleShading *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleShading_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleShading(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyleShading *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleShading(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleShading_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleShading > ExpressDataSet::createIfcSurfaceStyleShading(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyleShading(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyleShading * > (allocateIfcSurfaceStyleShading(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleShading *ExpressDataSet::cloneIfcSurfaceStyleShading(ExpressDataSet *expressDataSet, const IfcSurfaceStyleShading &obj, const CopyOp &copyop) {
    IfcSurfaceStyleShading *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleShading(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleShading_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleShading *ExpressDataSet::cloneIfcSurfaceStyleShading(const IfcSurfaceStyleShading &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyleShading(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyleShading(this, obj, copyop);
    }
}

IfcSurfaceStyleWithTextures *ExpressDataSet::getIfcSurfaceStyleWithTextures(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSurfaceStyleWithTextures * > (current->second.get());
    }
    else {
        IfcSurfaceStyleWithTextures *ret = static_cast< IfcSurfaceStyleWithTextures * > (allocateIfcSurfaceStyleWithTextures(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSurfaceStyleWithTextures(IfcSurfaceStyleWithTextures *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSurfaceStyleWithTextures_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSurfaceStyleWithTextures(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSurfaceStyleWithTextures *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSurfaceStyleWithTextures(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSurfaceStyleWithTextures_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSurfaceStyleWithTextures > ExpressDataSet::createIfcSurfaceStyleWithTextures(bool isVolatile) {
    if (isVolatile) {
        return new IfcSurfaceStyleWithTextures(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSurfaceStyleWithTextures * > (allocateIfcSurfaceStyleWithTextures(this, Step::Id_UNSET));
    }
}

IfcSurfaceStyleWithTextures *ExpressDataSet::cloneIfcSurfaceStyleWithTextures(ExpressDataSet *expressDataSet, const IfcSurfaceStyleWithTextures &obj, const CopyOp &copyop) {
    IfcSurfaceStyleWithTextures *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSurfaceStyleWithTextures(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSurfaceStyleWithTextures_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSurfaceStyleWithTextures *ExpressDataSet::cloneIfcSurfaceStyleWithTextures(const IfcSurfaceStyleWithTextures &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSurfaceStyleWithTextures(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSurfaceStyleWithTextures(this, obj, copyop);
    }
}

IfcSweptDiskSolid *ExpressDataSet::getIfcSweptDiskSolid(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSweptDiskSolid * > (current->second.get());
    }
    else {
        IfcSweptDiskSolid *ret = static_cast< IfcSweptDiskSolid * > (allocateIfcSweptDiskSolid(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSweptDiskSolid(IfcSweptDiskSolid *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSweptDiskSolid_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSweptDiskSolid(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSweptDiskSolid *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSweptDiskSolid(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSweptDiskSolid_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSweptDiskSolid > ExpressDataSet::createIfcSweptDiskSolid(bool isVolatile) {
    if (isVolatile) {
        return new IfcSweptDiskSolid(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSweptDiskSolid * > (allocateIfcSweptDiskSolid(this, Step::Id_UNSET));
    }
}

IfcSweptDiskSolid *ExpressDataSet::cloneIfcSweptDiskSolid(ExpressDataSet *expressDataSet, const IfcSweptDiskSolid &obj, const CopyOp &copyop) {
    IfcSweptDiskSolid *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSweptDiskSolid(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSweptDiskSolid_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSweptDiskSolid *ExpressDataSet::cloneIfcSweptDiskSolid(const IfcSweptDiskSolid &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSweptDiskSolid(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSweptDiskSolid(this, obj, copyop);
    }
}

IfcSwitchingDeviceType *ExpressDataSet::getIfcSwitchingDeviceType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSwitchingDeviceType * > (current->second.get());
    }
    else {
        IfcSwitchingDeviceType *ret = static_cast< IfcSwitchingDeviceType * > (allocateIfcSwitchingDeviceType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSwitchingDeviceType(IfcSwitchingDeviceType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSwitchingDeviceType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSwitchingDeviceType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSwitchingDeviceType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSwitchingDeviceType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSwitchingDeviceType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSwitchingDeviceType > ExpressDataSet::createIfcSwitchingDeviceType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSwitchingDeviceType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSwitchingDeviceType * > (allocateIfcSwitchingDeviceType(this, Step::Id_UNSET));
    }
}

IfcSwitchingDeviceType *ExpressDataSet::cloneIfcSwitchingDeviceType(ExpressDataSet *expressDataSet, const IfcSwitchingDeviceType &obj, const CopyOp &copyop) {
    IfcSwitchingDeviceType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSwitchingDeviceType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSwitchingDeviceType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSwitchingDeviceType *ExpressDataSet::cloneIfcSwitchingDeviceType(const IfcSwitchingDeviceType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSwitchingDeviceType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSwitchingDeviceType(this, obj, copyop);
    }
}

IfcSymbolStyle *ExpressDataSet::getIfcSymbolStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSymbolStyle * > (current->second.get());
    }
    else {
        IfcSymbolStyle *ret = static_cast< IfcSymbolStyle * > (allocateIfcSymbolStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSymbolStyle(IfcSymbolStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSymbolStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSymbolStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSymbolStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSymbolStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSymbolStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSymbolStyle > ExpressDataSet::createIfcSymbolStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcSymbolStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSymbolStyle * > (allocateIfcSymbolStyle(this, Step::Id_UNSET));
    }
}

IfcSymbolStyle *ExpressDataSet::cloneIfcSymbolStyle(ExpressDataSet *expressDataSet, const IfcSymbolStyle &obj, const CopyOp &copyop) {
    IfcSymbolStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSymbolStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSymbolStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSymbolStyle *ExpressDataSet::cloneIfcSymbolStyle(const IfcSymbolStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSymbolStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSymbolStyle(this, obj, copyop);
    }
}

IfcSystem *ExpressDataSet::getIfcSystem(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSystem * > (current->second.get());
    }
    else {
        IfcSystem *ret = static_cast< IfcSystem * > (allocateIfcSystem(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSystem(IfcSystem *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSystem_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSystem(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSystem *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSystem(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSystem_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSystem > ExpressDataSet::createIfcSystem(bool isVolatile) {
    if (isVolatile) {
        return new IfcSystem(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSystem * > (allocateIfcSystem(this, Step::Id_UNSET));
    }
}

IfcSystem *ExpressDataSet::cloneIfcSystem(ExpressDataSet *expressDataSet, const IfcSystem &obj, const CopyOp &copyop) {
    IfcSystem *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSystem(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSystem_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSystem *ExpressDataSet::cloneIfcSystem(const IfcSystem &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSystem(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSystem(this, obj, copyop);
    }
}

IfcSystemFurnitureElementType *ExpressDataSet::getIfcSystemFurnitureElementType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcSystemFurnitureElementType * > (current->second.get());
    }
    else {
        IfcSystemFurnitureElementType *ret = static_cast< IfcSystemFurnitureElementType * > (allocateIfcSystemFurnitureElementType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcSystemFurnitureElementType(IfcSystemFurnitureElementType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcSystemFurnitureElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcSystemFurnitureElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcSystemFurnitureElementType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcSystemFurnitureElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcSystemFurnitureElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcSystemFurnitureElementType > ExpressDataSet::createIfcSystemFurnitureElementType(bool isVolatile) {
    if (isVolatile) {
        return new IfcSystemFurnitureElementType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcSystemFurnitureElementType * > (allocateIfcSystemFurnitureElementType(this, Step::Id_UNSET));
    }
}

IfcSystemFurnitureElementType *ExpressDataSet::cloneIfcSystemFurnitureElementType(ExpressDataSet *expressDataSet, const IfcSystemFurnitureElementType &obj, const CopyOp &copyop) {
    IfcSystemFurnitureElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcSystemFurnitureElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcSystemFurnitureElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcSystemFurnitureElementType *ExpressDataSet::cloneIfcSystemFurnitureElementType(const IfcSystemFurnitureElementType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcSystemFurnitureElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcSystemFurnitureElementType(this, obj, copyop);
    }
}

IfcTShapeProfileDef *ExpressDataSet::getIfcTShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTShapeProfileDef * > (current->second.get());
    }
    else {
        IfcTShapeProfileDef *ret = static_cast< IfcTShapeProfileDef * > (allocateIfcTShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTShapeProfileDef(IfcTShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTShapeProfileDef > ExpressDataSet::createIfcTShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcTShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTShapeProfileDef * > (allocateIfcTShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcTShapeProfileDef *ExpressDataSet::cloneIfcTShapeProfileDef(ExpressDataSet *expressDataSet, const IfcTShapeProfileDef &obj, const CopyOp &copyop) {
    IfcTShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTShapeProfileDef *ExpressDataSet::cloneIfcTShapeProfileDef(const IfcTShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTShapeProfileDef(this, obj, copyop);
    }
}

IfcTable *ExpressDataSet::getIfcTable(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTable * > (current->second.get());
    }
    else {
        IfcTable *ret = static_cast< IfcTable * > (allocateIfcTable(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTable(IfcTable *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTable_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTable(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTable *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTable(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTable_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTable > ExpressDataSet::createIfcTable(bool isVolatile) {
    if (isVolatile) {
        return new IfcTable(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTable * > (allocateIfcTable(this, Step::Id_UNSET));
    }
}

IfcTable *ExpressDataSet::cloneIfcTable(ExpressDataSet *expressDataSet, const IfcTable &obj, const CopyOp &copyop) {
    IfcTable *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTable(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTable_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTable *ExpressDataSet::cloneIfcTable(const IfcTable &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTable(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTable(this, obj, copyop);
    }
}

IfcTableRow *ExpressDataSet::getIfcTableRow(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTableRow * > (current->second.get());
    }
    else {
        IfcTableRow *ret = static_cast< IfcTableRow * > (allocateIfcTableRow(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTableRow(IfcTableRow *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTableRow_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTableRow(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTableRow *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTableRow(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTableRow_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTableRow > ExpressDataSet::createIfcTableRow(bool isVolatile) {
    if (isVolatile) {
        return new IfcTableRow(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTableRow * > (allocateIfcTableRow(this, Step::Id_UNSET));
    }
}

IfcTableRow *ExpressDataSet::cloneIfcTableRow(ExpressDataSet *expressDataSet, const IfcTableRow &obj, const CopyOp &copyop) {
    IfcTableRow *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTableRow(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTableRow_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTableRow *ExpressDataSet::cloneIfcTableRow(const IfcTableRow &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTableRow(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTableRow(this, obj, copyop);
    }
}

IfcTankType *ExpressDataSet::getIfcTankType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTankType * > (current->second.get());
    }
    else {
        IfcTankType *ret = static_cast< IfcTankType * > (allocateIfcTankType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTankType(IfcTankType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTankType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTankType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTankType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTankType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTankType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTankType > ExpressDataSet::createIfcTankType(bool isVolatile) {
    if (isVolatile) {
        return new IfcTankType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTankType * > (allocateIfcTankType(this, Step::Id_UNSET));
    }
}

IfcTankType *ExpressDataSet::cloneIfcTankType(ExpressDataSet *expressDataSet, const IfcTankType &obj, const CopyOp &copyop) {
    IfcTankType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTankType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTankType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTankType *ExpressDataSet::cloneIfcTankType(const IfcTankType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTankType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTankType(this, obj, copyop);
    }
}

IfcTask *ExpressDataSet::getIfcTask(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTask * > (current->second.get());
    }
    else {
        IfcTask *ret = static_cast< IfcTask * > (allocateIfcTask(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTask(IfcTask *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTask_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTask(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTask *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTask(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTask_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTask > ExpressDataSet::createIfcTask(bool isVolatile) {
    if (isVolatile) {
        return new IfcTask(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTask * > (allocateIfcTask(this, Step::Id_UNSET));
    }
}

IfcTask *ExpressDataSet::cloneIfcTask(ExpressDataSet *expressDataSet, const IfcTask &obj, const CopyOp &copyop) {
    IfcTask *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTask(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTask_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTask *ExpressDataSet::cloneIfcTask(const IfcTask &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTask(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTask(this, obj, copyop);
    }
}

IfcTelecomAddress *ExpressDataSet::getIfcTelecomAddress(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTelecomAddress * > (current->second.get());
    }
    else {
        IfcTelecomAddress *ret = static_cast< IfcTelecomAddress * > (allocateIfcTelecomAddress(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTelecomAddress(IfcTelecomAddress *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTelecomAddress_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTelecomAddress(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTelecomAddress *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTelecomAddress(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTelecomAddress_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTelecomAddress > ExpressDataSet::createIfcTelecomAddress(bool isVolatile) {
    if (isVolatile) {
        return new IfcTelecomAddress(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTelecomAddress * > (allocateIfcTelecomAddress(this, Step::Id_UNSET));
    }
}

IfcTelecomAddress *ExpressDataSet::cloneIfcTelecomAddress(ExpressDataSet *expressDataSet, const IfcTelecomAddress &obj, const CopyOp &copyop) {
    IfcTelecomAddress *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTelecomAddress(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTelecomAddress_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTelecomAddress *ExpressDataSet::cloneIfcTelecomAddress(const IfcTelecomAddress &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTelecomAddress(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTelecomAddress(this, obj, copyop);
    }
}

IfcTendon *ExpressDataSet::getIfcTendon(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTendon * > (current->second.get());
    }
    else {
        IfcTendon *ret = static_cast< IfcTendon * > (allocateIfcTendon(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTendon(IfcTendon *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTendon_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTendon(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTendon *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTendon(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTendon_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTendon > ExpressDataSet::createIfcTendon(bool isVolatile) {
    if (isVolatile) {
        return new IfcTendon(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTendon * > (allocateIfcTendon(this, Step::Id_UNSET));
    }
}

IfcTendon *ExpressDataSet::cloneIfcTendon(ExpressDataSet *expressDataSet, const IfcTendon &obj, const CopyOp &copyop) {
    IfcTendon *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTendon(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTendon_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTendon *ExpressDataSet::cloneIfcTendon(const IfcTendon &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTendon(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTendon(this, obj, copyop);
    }
}

IfcTendonAnchor *ExpressDataSet::getIfcTendonAnchor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTendonAnchor * > (current->second.get());
    }
    else {
        IfcTendonAnchor *ret = static_cast< IfcTendonAnchor * > (allocateIfcTendonAnchor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTendonAnchor(IfcTendonAnchor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTendonAnchor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTendonAnchor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTendonAnchor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTendonAnchor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTendonAnchor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTendonAnchor > ExpressDataSet::createIfcTendonAnchor(bool isVolatile) {
    if (isVolatile) {
        return new IfcTendonAnchor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTendonAnchor * > (allocateIfcTendonAnchor(this, Step::Id_UNSET));
    }
}

IfcTendonAnchor *ExpressDataSet::cloneIfcTendonAnchor(ExpressDataSet *expressDataSet, const IfcTendonAnchor &obj, const CopyOp &copyop) {
    IfcTendonAnchor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTendonAnchor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTendonAnchor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTendonAnchor *ExpressDataSet::cloneIfcTendonAnchor(const IfcTendonAnchor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTendonAnchor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTendonAnchor(this, obj, copyop);
    }
}

IfcTerminatorSymbol *ExpressDataSet::getIfcTerminatorSymbol(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTerminatorSymbol * > (current->second.get());
    }
    else {
        IfcTerminatorSymbol *ret = static_cast< IfcTerminatorSymbol * > (allocateIfcTerminatorSymbol(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTerminatorSymbol(IfcTerminatorSymbol *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTerminatorSymbol_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTerminatorSymbol(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTerminatorSymbol *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTerminatorSymbol(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTerminatorSymbol_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTerminatorSymbol > ExpressDataSet::createIfcTerminatorSymbol(bool isVolatile) {
    if (isVolatile) {
        return new IfcTerminatorSymbol(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTerminatorSymbol * > (allocateIfcTerminatorSymbol(this, Step::Id_UNSET));
    }
}

IfcTerminatorSymbol *ExpressDataSet::cloneIfcTerminatorSymbol(ExpressDataSet *expressDataSet, const IfcTerminatorSymbol &obj, const CopyOp &copyop) {
    IfcTerminatorSymbol *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTerminatorSymbol(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTerminatorSymbol_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTerminatorSymbol *ExpressDataSet::cloneIfcTerminatorSymbol(const IfcTerminatorSymbol &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTerminatorSymbol(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTerminatorSymbol(this, obj, copyop);
    }
}

IfcTextLiteral *ExpressDataSet::getIfcTextLiteral(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextLiteral * > (current->second.get());
    }
    else {
        IfcTextLiteral *ret = static_cast< IfcTextLiteral * > (allocateIfcTextLiteral(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextLiteral(IfcTextLiteral *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextLiteral_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextLiteral(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextLiteral *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextLiteral(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextLiteral_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextLiteral > ExpressDataSet::createIfcTextLiteral(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextLiteral(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextLiteral * > (allocateIfcTextLiteral(this, Step::Id_UNSET));
    }
}

IfcTextLiteral *ExpressDataSet::cloneIfcTextLiteral(ExpressDataSet *expressDataSet, const IfcTextLiteral &obj, const CopyOp &copyop) {
    IfcTextLiteral *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextLiteral(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextLiteral_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextLiteral *ExpressDataSet::cloneIfcTextLiteral(const IfcTextLiteral &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextLiteral(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextLiteral(this, obj, copyop);
    }
}

IfcTextLiteralWithExtent *ExpressDataSet::getIfcTextLiteralWithExtent(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextLiteralWithExtent * > (current->second.get());
    }
    else {
        IfcTextLiteralWithExtent *ret = static_cast< IfcTextLiteralWithExtent * > (allocateIfcTextLiteralWithExtent(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextLiteralWithExtent(IfcTextLiteralWithExtent *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextLiteralWithExtent_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextLiteralWithExtent(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextLiteralWithExtent *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextLiteralWithExtent(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextLiteralWithExtent_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextLiteralWithExtent > ExpressDataSet::createIfcTextLiteralWithExtent(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextLiteralWithExtent(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextLiteralWithExtent * > (allocateIfcTextLiteralWithExtent(this, Step::Id_UNSET));
    }
}

IfcTextLiteralWithExtent *ExpressDataSet::cloneIfcTextLiteralWithExtent(ExpressDataSet *expressDataSet, const IfcTextLiteralWithExtent &obj, const CopyOp &copyop) {
    IfcTextLiteralWithExtent *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextLiteralWithExtent(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextLiteralWithExtent_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextLiteralWithExtent *ExpressDataSet::cloneIfcTextLiteralWithExtent(const IfcTextLiteralWithExtent &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextLiteralWithExtent(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextLiteralWithExtent(this, obj, copyop);
    }
}

IfcTextStyle *ExpressDataSet::getIfcTextStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextStyle * > (current->second.get());
    }
    else {
        IfcTextStyle *ret = static_cast< IfcTextStyle * > (allocateIfcTextStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextStyle(IfcTextStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyle > ExpressDataSet::createIfcTextStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextStyle * > (allocateIfcTextStyle(this, Step::Id_UNSET));
    }
}

IfcTextStyle *ExpressDataSet::cloneIfcTextStyle(ExpressDataSet *expressDataSet, const IfcTextStyle &obj, const CopyOp &copyop) {
    IfcTextStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyle *ExpressDataSet::cloneIfcTextStyle(const IfcTextStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextStyle(this, obj, copyop);
    }
}

IfcTextStyleFontModel *ExpressDataSet::getIfcTextStyleFontModel(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextStyleFontModel * > (current->second.get());
    }
    else {
        IfcTextStyleFontModel *ret = static_cast< IfcTextStyleFontModel * > (allocateIfcTextStyleFontModel(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextStyleFontModel(IfcTextStyleFontModel *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextStyleFontModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleFontModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextStyleFontModel *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleFontModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleFontModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleFontModel > ExpressDataSet::createIfcTextStyleFontModel(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextStyleFontModel(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextStyleFontModel * > (allocateIfcTextStyleFontModel(this, Step::Id_UNSET));
    }
}

IfcTextStyleFontModel *ExpressDataSet::cloneIfcTextStyleFontModel(ExpressDataSet *expressDataSet, const IfcTextStyleFontModel &obj, const CopyOp &copyop) {
    IfcTextStyleFontModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleFontModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleFontModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleFontModel *ExpressDataSet::cloneIfcTextStyleFontModel(const IfcTextStyleFontModel &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextStyleFontModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextStyleFontModel(this, obj, copyop);
    }
}

IfcTextStyleForDefinedFont *ExpressDataSet::getIfcTextStyleForDefinedFont(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextStyleForDefinedFont * > (current->second.get());
    }
    else {
        IfcTextStyleForDefinedFont *ret = static_cast< IfcTextStyleForDefinedFont * > (allocateIfcTextStyleForDefinedFont(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextStyleForDefinedFont(IfcTextStyleForDefinedFont *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextStyleForDefinedFont_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleForDefinedFont(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextStyleForDefinedFont *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleForDefinedFont(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleForDefinedFont_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleForDefinedFont > ExpressDataSet::createIfcTextStyleForDefinedFont(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextStyleForDefinedFont(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextStyleForDefinedFont * > (allocateIfcTextStyleForDefinedFont(this, Step::Id_UNSET));
    }
}

IfcTextStyleForDefinedFont *ExpressDataSet::cloneIfcTextStyleForDefinedFont(ExpressDataSet *expressDataSet, const IfcTextStyleForDefinedFont &obj, const CopyOp &copyop) {
    IfcTextStyleForDefinedFont *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleForDefinedFont(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleForDefinedFont_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleForDefinedFont *ExpressDataSet::cloneIfcTextStyleForDefinedFont(const IfcTextStyleForDefinedFont &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextStyleForDefinedFont(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextStyleForDefinedFont(this, obj, copyop);
    }
}

IfcTextStyleTextModel *ExpressDataSet::getIfcTextStyleTextModel(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextStyleTextModel * > (current->second.get());
    }
    else {
        IfcTextStyleTextModel *ret = static_cast< IfcTextStyleTextModel * > (allocateIfcTextStyleTextModel(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextStyleTextModel(IfcTextStyleTextModel *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextStyleTextModel_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleTextModel(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextStyleTextModel *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleTextModel(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleTextModel_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleTextModel > ExpressDataSet::createIfcTextStyleTextModel(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextStyleTextModel(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextStyleTextModel * > (allocateIfcTextStyleTextModel(this, Step::Id_UNSET));
    }
}

IfcTextStyleTextModel *ExpressDataSet::cloneIfcTextStyleTextModel(ExpressDataSet *expressDataSet, const IfcTextStyleTextModel &obj, const CopyOp &copyop) {
    IfcTextStyleTextModel *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleTextModel(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleTextModel_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleTextModel *ExpressDataSet::cloneIfcTextStyleTextModel(const IfcTextStyleTextModel &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextStyleTextModel(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextStyleTextModel(this, obj, copyop);
    }
}

IfcTextStyleWithBoxCharacteristics *ExpressDataSet::getIfcTextStyleWithBoxCharacteristics(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextStyleWithBoxCharacteristics * > (current->second.get());
    }
    else {
        IfcTextStyleWithBoxCharacteristics *ret = static_cast< IfcTextStyleWithBoxCharacteristics * > (allocateIfcTextStyleWithBoxCharacteristics(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextStyleWithBoxCharacteristics(IfcTextStyleWithBoxCharacteristics *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextStyleWithBoxCharacteristics_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextStyleWithBoxCharacteristics(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextStyleWithBoxCharacteristics *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextStyleWithBoxCharacteristics(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextStyleWithBoxCharacteristics_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextStyleWithBoxCharacteristics > ExpressDataSet::createIfcTextStyleWithBoxCharacteristics(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextStyleWithBoxCharacteristics(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextStyleWithBoxCharacteristics * > (allocateIfcTextStyleWithBoxCharacteristics(this, Step::Id_UNSET));
    }
}

IfcTextStyleWithBoxCharacteristics *ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(ExpressDataSet *expressDataSet, const IfcTextStyleWithBoxCharacteristics &obj, const CopyOp &copyop) {
    IfcTextStyleWithBoxCharacteristics *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextStyleWithBoxCharacteristics(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextStyleWithBoxCharacteristics_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextStyleWithBoxCharacteristics *ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(const IfcTextStyleWithBoxCharacteristics &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextStyleWithBoxCharacteristics(this, obj, copyop);
    }
}

IfcTextureCoordinateGenerator *ExpressDataSet::getIfcTextureCoordinateGenerator(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextureCoordinateGenerator * > (current->second.get());
    }
    else {
        IfcTextureCoordinateGenerator *ret = static_cast< IfcTextureCoordinateGenerator * > (allocateIfcTextureCoordinateGenerator(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextureCoordinateGenerator(IfcTextureCoordinateGenerator *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextureCoordinateGenerator_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureCoordinateGenerator(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextureCoordinateGenerator *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureCoordinateGenerator(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureCoordinateGenerator_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureCoordinateGenerator > ExpressDataSet::createIfcTextureCoordinateGenerator(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextureCoordinateGenerator(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextureCoordinateGenerator * > (allocateIfcTextureCoordinateGenerator(this, Step::Id_UNSET));
    }
}

IfcTextureCoordinateGenerator *ExpressDataSet::cloneIfcTextureCoordinateGenerator(ExpressDataSet *expressDataSet, const IfcTextureCoordinateGenerator &obj, const CopyOp &copyop) {
    IfcTextureCoordinateGenerator *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureCoordinateGenerator(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureCoordinateGenerator_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureCoordinateGenerator *ExpressDataSet::cloneIfcTextureCoordinateGenerator(const IfcTextureCoordinateGenerator &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextureCoordinateGenerator(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextureCoordinateGenerator(this, obj, copyop);
    }
}

IfcTextureMap *ExpressDataSet::getIfcTextureMap(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextureMap * > (current->second.get());
    }
    else {
        IfcTextureMap *ret = static_cast< IfcTextureMap * > (allocateIfcTextureMap(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextureMap(IfcTextureMap *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextureMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextureMap *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureMap > ExpressDataSet::createIfcTextureMap(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextureMap(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextureMap * > (allocateIfcTextureMap(this, Step::Id_UNSET));
    }
}

IfcTextureMap *ExpressDataSet::cloneIfcTextureMap(ExpressDataSet *expressDataSet, const IfcTextureMap &obj, const CopyOp &copyop) {
    IfcTextureMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureMap *ExpressDataSet::cloneIfcTextureMap(const IfcTextureMap &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextureMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextureMap(this, obj, copyop);
    }
}

IfcTextureVertex *ExpressDataSet::getIfcTextureVertex(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTextureVertex * > (current->second.get());
    }
    else {
        IfcTextureVertex *ret = static_cast< IfcTextureVertex * > (allocateIfcTextureVertex(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTextureVertex(IfcTextureVertex *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTextureVertex_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTextureVertex(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTextureVertex *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTextureVertex(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTextureVertex_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTextureVertex > ExpressDataSet::createIfcTextureVertex(bool isVolatile) {
    if (isVolatile) {
        return new IfcTextureVertex(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTextureVertex * > (allocateIfcTextureVertex(this, Step::Id_UNSET));
    }
}

IfcTextureVertex *ExpressDataSet::cloneIfcTextureVertex(ExpressDataSet *expressDataSet, const IfcTextureVertex &obj, const CopyOp &copyop) {
    IfcTextureVertex *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTextureVertex(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTextureVertex_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTextureVertex *ExpressDataSet::cloneIfcTextureVertex(const IfcTextureVertex &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTextureVertex(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTextureVertex(this, obj, copyop);
    }
}

IfcThermalMaterialProperties *ExpressDataSet::getIfcThermalMaterialProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcThermalMaterialProperties * > (current->second.get());
    }
    else {
        IfcThermalMaterialProperties *ret = static_cast< IfcThermalMaterialProperties * > (allocateIfcThermalMaterialProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcThermalMaterialProperties(IfcThermalMaterialProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcThermalMaterialProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcThermalMaterialProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcThermalMaterialProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcThermalMaterialProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcThermalMaterialProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcThermalMaterialProperties > ExpressDataSet::createIfcThermalMaterialProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcThermalMaterialProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcThermalMaterialProperties * > (allocateIfcThermalMaterialProperties(this, Step::Id_UNSET));
    }
}

IfcThermalMaterialProperties *ExpressDataSet::cloneIfcThermalMaterialProperties(ExpressDataSet *expressDataSet, const IfcThermalMaterialProperties &obj, const CopyOp &copyop) {
    IfcThermalMaterialProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcThermalMaterialProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcThermalMaterialProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcThermalMaterialProperties *ExpressDataSet::cloneIfcThermalMaterialProperties(const IfcThermalMaterialProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcThermalMaterialProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcThermalMaterialProperties(this, obj, copyop);
    }
}

IfcTimeSeriesReferenceRelationship *ExpressDataSet::getIfcTimeSeriesReferenceRelationship(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTimeSeriesReferenceRelationship * > (current->second.get());
    }
    else {
        IfcTimeSeriesReferenceRelationship *ret = static_cast< IfcTimeSeriesReferenceRelationship * > (allocateIfcTimeSeriesReferenceRelationship(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTimeSeriesReferenceRelationship(IfcTimeSeriesReferenceRelationship *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesReferenceRelationship_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesReferenceRelationship(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTimeSeriesReferenceRelationship *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesReferenceRelationship(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesReferenceRelationship_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesReferenceRelationship > ExpressDataSet::createIfcTimeSeriesReferenceRelationship(bool isVolatile) {
    if (isVolatile) {
        return new IfcTimeSeriesReferenceRelationship(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTimeSeriesReferenceRelationship * > (allocateIfcTimeSeriesReferenceRelationship(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesReferenceRelationship *ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(ExpressDataSet *expressDataSet, const IfcTimeSeriesReferenceRelationship &obj, const CopyOp &copyop) {
    IfcTimeSeriesReferenceRelationship *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesReferenceRelationship(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesReferenceRelationship_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesReferenceRelationship *ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(const IfcTimeSeriesReferenceRelationship &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTimeSeriesReferenceRelationship(this, obj, copyop);
    }
}

IfcTimeSeriesSchedule *ExpressDataSet::getIfcTimeSeriesSchedule(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTimeSeriesSchedule * > (current->second.get());
    }
    else {
        IfcTimeSeriesSchedule *ret = static_cast< IfcTimeSeriesSchedule * > (allocateIfcTimeSeriesSchedule(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTimeSeriesSchedule(IfcTimeSeriesSchedule *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTimeSeriesSchedule *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesSchedule > ExpressDataSet::createIfcTimeSeriesSchedule(bool isVolatile) {
    if (isVolatile) {
        return new IfcTimeSeriesSchedule(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTimeSeriesSchedule * > (allocateIfcTimeSeriesSchedule(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesSchedule *ExpressDataSet::cloneIfcTimeSeriesSchedule(ExpressDataSet *expressDataSet, const IfcTimeSeriesSchedule &obj, const CopyOp &copyop) {
    IfcTimeSeriesSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesSchedule *ExpressDataSet::cloneIfcTimeSeriesSchedule(const IfcTimeSeriesSchedule &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTimeSeriesSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTimeSeriesSchedule(this, obj, copyop);
    }
}

IfcTimeSeriesValue *ExpressDataSet::getIfcTimeSeriesValue(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTimeSeriesValue * > (current->second.get());
    }
    else {
        IfcTimeSeriesValue *ret = static_cast< IfcTimeSeriesValue * > (allocateIfcTimeSeriesValue(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTimeSeriesValue(IfcTimeSeriesValue *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTimeSeriesValue_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTimeSeriesValue(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTimeSeriesValue *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTimeSeriesValue(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTimeSeriesValue_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTimeSeriesValue > ExpressDataSet::createIfcTimeSeriesValue(bool isVolatile) {
    if (isVolatile) {
        return new IfcTimeSeriesValue(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTimeSeriesValue * > (allocateIfcTimeSeriesValue(this, Step::Id_UNSET));
    }
}

IfcTimeSeriesValue *ExpressDataSet::cloneIfcTimeSeriesValue(ExpressDataSet *expressDataSet, const IfcTimeSeriesValue &obj, const CopyOp &copyop) {
    IfcTimeSeriesValue *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTimeSeriesValue(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTimeSeriesValue_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTimeSeriesValue *ExpressDataSet::cloneIfcTimeSeriesValue(const IfcTimeSeriesValue &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTimeSeriesValue(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTimeSeriesValue(this, obj, copyop);
    }
}

IfcTopologyRepresentation *ExpressDataSet::getIfcTopologyRepresentation(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTopologyRepresentation * > (current->second.get());
    }
    else {
        IfcTopologyRepresentation *ret = static_cast< IfcTopologyRepresentation * > (allocateIfcTopologyRepresentation(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTopologyRepresentation(IfcTopologyRepresentation *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTopologyRepresentation_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTopologyRepresentation(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTopologyRepresentation *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTopologyRepresentation(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTopologyRepresentation_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTopologyRepresentation > ExpressDataSet::createIfcTopologyRepresentation(bool isVolatile) {
    if (isVolatile) {
        return new IfcTopologyRepresentation(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTopologyRepresentation * > (allocateIfcTopologyRepresentation(this, Step::Id_UNSET));
    }
}

IfcTopologyRepresentation *ExpressDataSet::cloneIfcTopologyRepresentation(ExpressDataSet *expressDataSet, const IfcTopologyRepresentation &obj, const CopyOp &copyop) {
    IfcTopologyRepresentation *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTopologyRepresentation(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTopologyRepresentation_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTopologyRepresentation *ExpressDataSet::cloneIfcTopologyRepresentation(const IfcTopologyRepresentation &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTopologyRepresentation(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTopologyRepresentation(this, obj, copyop);
    }
}

IfcTransformerType *ExpressDataSet::getIfcTransformerType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTransformerType * > (current->second.get());
    }
    else {
        IfcTransformerType *ret = static_cast< IfcTransformerType * > (allocateIfcTransformerType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTransformerType(IfcTransformerType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTransformerType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransformerType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTransformerType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransformerType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransformerType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransformerType > ExpressDataSet::createIfcTransformerType(bool isVolatile) {
    if (isVolatile) {
        return new IfcTransformerType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTransformerType * > (allocateIfcTransformerType(this, Step::Id_UNSET));
    }
}

IfcTransformerType *ExpressDataSet::cloneIfcTransformerType(ExpressDataSet *expressDataSet, const IfcTransformerType &obj, const CopyOp &copyop) {
    IfcTransformerType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransformerType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransformerType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransformerType *ExpressDataSet::cloneIfcTransformerType(const IfcTransformerType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTransformerType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTransformerType(this, obj, copyop);
    }
}

IfcTransportElement *ExpressDataSet::getIfcTransportElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTransportElement * > (current->second.get());
    }
    else {
        IfcTransportElement *ret = static_cast< IfcTransportElement * > (allocateIfcTransportElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTransportElement(IfcTransportElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTransportElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransportElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTransportElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransportElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransportElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransportElement > ExpressDataSet::createIfcTransportElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcTransportElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTransportElement * > (allocateIfcTransportElement(this, Step::Id_UNSET));
    }
}

IfcTransportElement *ExpressDataSet::cloneIfcTransportElement(ExpressDataSet *expressDataSet, const IfcTransportElement &obj, const CopyOp &copyop) {
    IfcTransportElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransportElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransportElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransportElement *ExpressDataSet::cloneIfcTransportElement(const IfcTransportElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTransportElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTransportElement(this, obj, copyop);
    }
}

IfcTransportElementType *ExpressDataSet::getIfcTransportElementType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTransportElementType * > (current->second.get());
    }
    else {
        IfcTransportElementType *ret = static_cast< IfcTransportElementType * > (allocateIfcTransportElementType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTransportElementType(IfcTransportElementType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTransportElementType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTransportElementType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTransportElementType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTransportElementType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTransportElementType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTransportElementType > ExpressDataSet::createIfcTransportElementType(bool isVolatile) {
    if (isVolatile) {
        return new IfcTransportElementType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTransportElementType * > (allocateIfcTransportElementType(this, Step::Id_UNSET));
    }
}

IfcTransportElementType *ExpressDataSet::cloneIfcTransportElementType(ExpressDataSet *expressDataSet, const IfcTransportElementType &obj, const CopyOp &copyop) {
    IfcTransportElementType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTransportElementType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTransportElementType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTransportElementType *ExpressDataSet::cloneIfcTransportElementType(const IfcTransportElementType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTransportElementType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTransportElementType(this, obj, copyop);
    }
}

IfcTrapeziumProfileDef *ExpressDataSet::getIfcTrapeziumProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTrapeziumProfileDef * > (current->second.get());
    }
    else {
        IfcTrapeziumProfileDef *ret = static_cast< IfcTrapeziumProfileDef * > (allocateIfcTrapeziumProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTrapeziumProfileDef(IfcTrapeziumProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTrapeziumProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTrapeziumProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTrapeziumProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTrapeziumProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTrapeziumProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTrapeziumProfileDef > ExpressDataSet::createIfcTrapeziumProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcTrapeziumProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTrapeziumProfileDef * > (allocateIfcTrapeziumProfileDef(this, Step::Id_UNSET));
    }
}

IfcTrapeziumProfileDef *ExpressDataSet::cloneIfcTrapeziumProfileDef(ExpressDataSet *expressDataSet, const IfcTrapeziumProfileDef &obj, const CopyOp &copyop) {
    IfcTrapeziumProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTrapeziumProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTrapeziumProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTrapeziumProfileDef *ExpressDataSet::cloneIfcTrapeziumProfileDef(const IfcTrapeziumProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTrapeziumProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTrapeziumProfileDef(this, obj, copyop);
    }
}

IfcTrimmedCurve *ExpressDataSet::getIfcTrimmedCurve(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTrimmedCurve * > (current->second.get());
    }
    else {
        IfcTrimmedCurve *ret = static_cast< IfcTrimmedCurve * > (allocateIfcTrimmedCurve(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTrimmedCurve(IfcTrimmedCurve *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTrimmedCurve_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTrimmedCurve(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTrimmedCurve *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTrimmedCurve(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTrimmedCurve_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTrimmedCurve > ExpressDataSet::createIfcTrimmedCurve(bool isVolatile) {
    if (isVolatile) {
        return new IfcTrimmedCurve(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTrimmedCurve * > (allocateIfcTrimmedCurve(this, Step::Id_UNSET));
    }
}

IfcTrimmedCurve *ExpressDataSet::cloneIfcTrimmedCurve(ExpressDataSet *expressDataSet, const IfcTrimmedCurve &obj, const CopyOp &copyop) {
    IfcTrimmedCurve *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTrimmedCurve(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTrimmedCurve_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTrimmedCurve *ExpressDataSet::cloneIfcTrimmedCurve(const IfcTrimmedCurve &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTrimmedCurve(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTrimmedCurve(this, obj, copyop);
    }
}

IfcTubeBundleType *ExpressDataSet::getIfcTubeBundleType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTubeBundleType * > (current->second.get());
    }
    else {
        IfcTubeBundleType *ret = static_cast< IfcTubeBundleType * > (allocateIfcTubeBundleType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTubeBundleType(IfcTubeBundleType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTubeBundleType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTubeBundleType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTubeBundleType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTubeBundleType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTubeBundleType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTubeBundleType > ExpressDataSet::createIfcTubeBundleType(bool isVolatile) {
    if (isVolatile) {
        return new IfcTubeBundleType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTubeBundleType * > (allocateIfcTubeBundleType(this, Step::Id_UNSET));
    }
}

IfcTubeBundleType *ExpressDataSet::cloneIfcTubeBundleType(ExpressDataSet *expressDataSet, const IfcTubeBundleType &obj, const CopyOp &copyop) {
    IfcTubeBundleType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTubeBundleType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTubeBundleType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTubeBundleType *ExpressDataSet::cloneIfcTubeBundleType(const IfcTubeBundleType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTubeBundleType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTubeBundleType(this, obj, copyop);
    }
}

IfcTwoDirectionRepeatFactor *ExpressDataSet::getIfcTwoDirectionRepeatFactor(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTwoDirectionRepeatFactor * > (current->second.get());
    }
    else {
        IfcTwoDirectionRepeatFactor *ret = static_cast< IfcTwoDirectionRepeatFactor * > (allocateIfcTwoDirectionRepeatFactor(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTwoDirectionRepeatFactor(IfcTwoDirectionRepeatFactor *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTwoDirectionRepeatFactor_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTwoDirectionRepeatFactor(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTwoDirectionRepeatFactor *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTwoDirectionRepeatFactor(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTwoDirectionRepeatFactor_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTwoDirectionRepeatFactor > ExpressDataSet::createIfcTwoDirectionRepeatFactor(bool isVolatile) {
    if (isVolatile) {
        return new IfcTwoDirectionRepeatFactor(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTwoDirectionRepeatFactor * > (allocateIfcTwoDirectionRepeatFactor(this, Step::Id_UNSET));
    }
}

IfcTwoDirectionRepeatFactor *ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(ExpressDataSet *expressDataSet, const IfcTwoDirectionRepeatFactor &obj, const CopyOp &copyop) {
    IfcTwoDirectionRepeatFactor *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTwoDirectionRepeatFactor(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTwoDirectionRepeatFactor_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTwoDirectionRepeatFactor *ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(const IfcTwoDirectionRepeatFactor &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTwoDirectionRepeatFactor(this, obj, copyop);
    }
}

IfcTypeObject *ExpressDataSet::getIfcTypeObject(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTypeObject * > (current->second.get());
    }
    else {
        IfcTypeObject *ret = static_cast< IfcTypeObject * > (allocateIfcTypeObject(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTypeObject(IfcTypeObject *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTypeObject_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTypeObject(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTypeObject *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTypeObject(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTypeObject_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTypeObject > ExpressDataSet::createIfcTypeObject(bool isVolatile) {
    if (isVolatile) {
        return new IfcTypeObject(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTypeObject * > (allocateIfcTypeObject(this, Step::Id_UNSET));
    }
}

IfcTypeObject *ExpressDataSet::cloneIfcTypeObject(ExpressDataSet *expressDataSet, const IfcTypeObject &obj, const CopyOp &copyop) {
    IfcTypeObject *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTypeObject(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTypeObject_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTypeObject *ExpressDataSet::cloneIfcTypeObject(const IfcTypeObject &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTypeObject(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTypeObject(this, obj, copyop);
    }
}

IfcTypeProduct *ExpressDataSet::getIfcTypeProduct(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcTypeProduct * > (current->second.get());
    }
    else {
        IfcTypeProduct *ret = static_cast< IfcTypeProduct * > (allocateIfcTypeProduct(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcTypeProduct(IfcTypeProduct *arg) {
    getAll().erase(arg->getKey());
    return m_IfcTypeProduct_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcTypeProduct(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcTypeProduct *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcTypeProduct(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcTypeProduct_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcTypeProduct > ExpressDataSet::createIfcTypeProduct(bool isVolatile) {
    if (isVolatile) {
        return new IfcTypeProduct(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcTypeProduct * > (allocateIfcTypeProduct(this, Step::Id_UNSET));
    }
}

IfcTypeProduct *ExpressDataSet::cloneIfcTypeProduct(ExpressDataSet *expressDataSet, const IfcTypeProduct &obj, const CopyOp &copyop) {
    IfcTypeProduct *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcTypeProduct(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcTypeProduct_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcTypeProduct *ExpressDataSet::cloneIfcTypeProduct(const IfcTypeProduct &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcTypeProduct(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcTypeProduct(this, obj, copyop);
    }
}

IfcUShapeProfileDef *ExpressDataSet::getIfcUShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcUShapeProfileDef * > (current->second.get());
    }
    else {
        IfcUShapeProfileDef *ret = static_cast< IfcUShapeProfileDef * > (allocateIfcUShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcUShapeProfileDef(IfcUShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcUShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcUShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUShapeProfileDef > ExpressDataSet::createIfcUShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcUShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcUShapeProfileDef * > (allocateIfcUShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcUShapeProfileDef *ExpressDataSet::cloneIfcUShapeProfileDef(ExpressDataSet *expressDataSet, const IfcUShapeProfileDef &obj, const CopyOp &copyop) {
    IfcUShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUShapeProfileDef *ExpressDataSet::cloneIfcUShapeProfileDef(const IfcUShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcUShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcUShapeProfileDef(this, obj, copyop);
    }
}

IfcUnitAssignment *ExpressDataSet::getIfcUnitAssignment(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcUnitAssignment * > (current->second.get());
    }
    else {
        IfcUnitAssignment *ret = static_cast< IfcUnitAssignment * > (allocateIfcUnitAssignment(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcUnitAssignment(IfcUnitAssignment *arg) {
    getAll().erase(arg->getKey());
    return m_IfcUnitAssignment_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUnitAssignment(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcUnitAssignment *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUnitAssignment(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUnitAssignment_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUnitAssignment > ExpressDataSet::createIfcUnitAssignment(bool isVolatile) {
    if (isVolatile) {
        return new IfcUnitAssignment(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcUnitAssignment * > (allocateIfcUnitAssignment(this, Step::Id_UNSET));
    }
}

IfcUnitAssignment *ExpressDataSet::cloneIfcUnitAssignment(ExpressDataSet *expressDataSet, const IfcUnitAssignment &obj, const CopyOp &copyop) {
    IfcUnitAssignment *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUnitAssignment(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUnitAssignment_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUnitAssignment *ExpressDataSet::cloneIfcUnitAssignment(const IfcUnitAssignment &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcUnitAssignment(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcUnitAssignment(this, obj, copyop);
    }
}

IfcUnitaryEquipmentType *ExpressDataSet::getIfcUnitaryEquipmentType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcUnitaryEquipmentType * > (current->second.get());
    }
    else {
        IfcUnitaryEquipmentType *ret = static_cast< IfcUnitaryEquipmentType * > (allocateIfcUnitaryEquipmentType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcUnitaryEquipmentType(IfcUnitaryEquipmentType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcUnitaryEquipmentType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcUnitaryEquipmentType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcUnitaryEquipmentType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcUnitaryEquipmentType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcUnitaryEquipmentType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcUnitaryEquipmentType > ExpressDataSet::createIfcUnitaryEquipmentType(bool isVolatile) {
    if (isVolatile) {
        return new IfcUnitaryEquipmentType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcUnitaryEquipmentType * > (allocateIfcUnitaryEquipmentType(this, Step::Id_UNSET));
    }
}

IfcUnitaryEquipmentType *ExpressDataSet::cloneIfcUnitaryEquipmentType(ExpressDataSet *expressDataSet, const IfcUnitaryEquipmentType &obj, const CopyOp &copyop) {
    IfcUnitaryEquipmentType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcUnitaryEquipmentType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcUnitaryEquipmentType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcUnitaryEquipmentType *ExpressDataSet::cloneIfcUnitaryEquipmentType(const IfcUnitaryEquipmentType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcUnitaryEquipmentType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcUnitaryEquipmentType(this, obj, copyop);
    }
}

IfcValveType *ExpressDataSet::getIfcValveType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcValveType * > (current->second.get());
    }
    else {
        IfcValveType *ret = static_cast< IfcValveType * > (allocateIfcValveType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcValveType(IfcValveType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcValveType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcValveType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcValveType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcValveType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcValveType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcValveType > ExpressDataSet::createIfcValveType(bool isVolatile) {
    if (isVolatile) {
        return new IfcValveType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcValveType * > (allocateIfcValveType(this, Step::Id_UNSET));
    }
}

IfcValveType *ExpressDataSet::cloneIfcValveType(ExpressDataSet *expressDataSet, const IfcValveType &obj, const CopyOp &copyop) {
    IfcValveType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcValveType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcValveType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcValveType *ExpressDataSet::cloneIfcValveType(const IfcValveType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcValveType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcValveType(this, obj, copyop);
    }
}

IfcVector *ExpressDataSet::getIfcVector(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVector * > (current->second.get());
    }
    else {
        IfcVector *ret = static_cast< IfcVector * > (allocateIfcVector(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVector(IfcVector *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVector_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVector(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVector *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVector(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVector_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVector > ExpressDataSet::createIfcVector(bool isVolatile) {
    if (isVolatile) {
        return new IfcVector(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVector * > (allocateIfcVector(this, Step::Id_UNSET));
    }
}

IfcVector *ExpressDataSet::cloneIfcVector(ExpressDataSet *expressDataSet, const IfcVector &obj, const CopyOp &copyop) {
    IfcVector *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVector(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVector_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVector *ExpressDataSet::cloneIfcVector(const IfcVector &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVector(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVector(this, obj, copyop);
    }
}

IfcVertex *ExpressDataSet::getIfcVertex(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVertex * > (current->second.get());
    }
    else {
        IfcVertex *ret = static_cast< IfcVertex * > (allocateIfcVertex(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVertex(IfcVertex *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVertex_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertex(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVertex *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertex(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertex_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertex > ExpressDataSet::createIfcVertex(bool isVolatile) {
    if (isVolatile) {
        return new IfcVertex(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVertex * > (allocateIfcVertex(this, Step::Id_UNSET));
    }
}

IfcVertex *ExpressDataSet::cloneIfcVertex(ExpressDataSet *expressDataSet, const IfcVertex &obj, const CopyOp &copyop) {
    IfcVertex *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertex(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertex_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertex *ExpressDataSet::cloneIfcVertex(const IfcVertex &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVertex(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVertex(this, obj, copyop);
    }
}

IfcVertexBasedTextureMap *ExpressDataSet::getIfcVertexBasedTextureMap(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVertexBasedTextureMap * > (current->second.get());
    }
    else {
        IfcVertexBasedTextureMap *ret = static_cast< IfcVertexBasedTextureMap * > (allocateIfcVertexBasedTextureMap(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVertexBasedTextureMap(IfcVertexBasedTextureMap *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVertexBasedTextureMap_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexBasedTextureMap(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVertexBasedTextureMap *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexBasedTextureMap(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexBasedTextureMap_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexBasedTextureMap > ExpressDataSet::createIfcVertexBasedTextureMap(bool isVolatile) {
    if (isVolatile) {
        return new IfcVertexBasedTextureMap(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVertexBasedTextureMap * > (allocateIfcVertexBasedTextureMap(this, Step::Id_UNSET));
    }
}

IfcVertexBasedTextureMap *ExpressDataSet::cloneIfcVertexBasedTextureMap(ExpressDataSet *expressDataSet, const IfcVertexBasedTextureMap &obj, const CopyOp &copyop) {
    IfcVertexBasedTextureMap *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexBasedTextureMap(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexBasedTextureMap_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexBasedTextureMap *ExpressDataSet::cloneIfcVertexBasedTextureMap(const IfcVertexBasedTextureMap &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVertexBasedTextureMap(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVertexBasedTextureMap(this, obj, copyop);
    }
}

IfcVertexLoop *ExpressDataSet::getIfcVertexLoop(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVertexLoop * > (current->second.get());
    }
    else {
        IfcVertexLoop *ret = static_cast< IfcVertexLoop * > (allocateIfcVertexLoop(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVertexLoop(IfcVertexLoop *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVertexLoop_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexLoop(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVertexLoop *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexLoop(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexLoop_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexLoop > ExpressDataSet::createIfcVertexLoop(bool isVolatile) {
    if (isVolatile) {
        return new IfcVertexLoop(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVertexLoop * > (allocateIfcVertexLoop(this, Step::Id_UNSET));
    }
}

IfcVertexLoop *ExpressDataSet::cloneIfcVertexLoop(ExpressDataSet *expressDataSet, const IfcVertexLoop &obj, const CopyOp &copyop) {
    IfcVertexLoop *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexLoop(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexLoop_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexLoop *ExpressDataSet::cloneIfcVertexLoop(const IfcVertexLoop &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVertexLoop(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVertexLoop(this, obj, copyop);
    }
}

IfcVertexPoint *ExpressDataSet::getIfcVertexPoint(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVertexPoint * > (current->second.get());
    }
    else {
        IfcVertexPoint *ret = static_cast< IfcVertexPoint * > (allocateIfcVertexPoint(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVertexPoint(IfcVertexPoint *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVertexPoint_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVertexPoint(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVertexPoint *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVertexPoint(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVertexPoint_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVertexPoint > ExpressDataSet::createIfcVertexPoint(bool isVolatile) {
    if (isVolatile) {
        return new IfcVertexPoint(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVertexPoint * > (allocateIfcVertexPoint(this, Step::Id_UNSET));
    }
}

IfcVertexPoint *ExpressDataSet::cloneIfcVertexPoint(ExpressDataSet *expressDataSet, const IfcVertexPoint &obj, const CopyOp &copyop) {
    IfcVertexPoint *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVertexPoint(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVertexPoint_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVertexPoint *ExpressDataSet::cloneIfcVertexPoint(const IfcVertexPoint &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVertexPoint(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVertexPoint(this, obj, copyop);
    }
}

IfcVibrationIsolatorType *ExpressDataSet::getIfcVibrationIsolatorType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVibrationIsolatorType * > (current->second.get());
    }
    else {
        IfcVibrationIsolatorType *ret = static_cast< IfcVibrationIsolatorType * > (allocateIfcVibrationIsolatorType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVibrationIsolatorType(IfcVibrationIsolatorType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVibrationIsolatorType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVibrationIsolatorType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVibrationIsolatorType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVibrationIsolatorType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVibrationIsolatorType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVibrationIsolatorType > ExpressDataSet::createIfcVibrationIsolatorType(bool isVolatile) {
    if (isVolatile) {
        return new IfcVibrationIsolatorType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVibrationIsolatorType * > (allocateIfcVibrationIsolatorType(this, Step::Id_UNSET));
    }
}

IfcVibrationIsolatorType *ExpressDataSet::cloneIfcVibrationIsolatorType(ExpressDataSet *expressDataSet, const IfcVibrationIsolatorType &obj, const CopyOp &copyop) {
    IfcVibrationIsolatorType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVibrationIsolatorType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVibrationIsolatorType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVibrationIsolatorType *ExpressDataSet::cloneIfcVibrationIsolatorType(const IfcVibrationIsolatorType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVibrationIsolatorType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVibrationIsolatorType(this, obj, copyop);
    }
}

IfcVirtualElement *ExpressDataSet::getIfcVirtualElement(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVirtualElement * > (current->second.get());
    }
    else {
        IfcVirtualElement *ret = static_cast< IfcVirtualElement * > (allocateIfcVirtualElement(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVirtualElement(IfcVirtualElement *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVirtualElement_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVirtualElement(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVirtualElement *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVirtualElement(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVirtualElement_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVirtualElement > ExpressDataSet::createIfcVirtualElement(bool isVolatile) {
    if (isVolatile) {
        return new IfcVirtualElement(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVirtualElement * > (allocateIfcVirtualElement(this, Step::Id_UNSET));
    }
}

IfcVirtualElement *ExpressDataSet::cloneIfcVirtualElement(ExpressDataSet *expressDataSet, const IfcVirtualElement &obj, const CopyOp &copyop) {
    IfcVirtualElement *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVirtualElement(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVirtualElement_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVirtualElement *ExpressDataSet::cloneIfcVirtualElement(const IfcVirtualElement &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVirtualElement(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVirtualElement(this, obj, copyop);
    }
}

IfcVirtualGridIntersection *ExpressDataSet::getIfcVirtualGridIntersection(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcVirtualGridIntersection * > (current->second.get());
    }
    else {
        IfcVirtualGridIntersection *ret = static_cast< IfcVirtualGridIntersection * > (allocateIfcVirtualGridIntersection(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcVirtualGridIntersection(IfcVirtualGridIntersection *arg) {
    getAll().erase(arg->getKey());
    return m_IfcVirtualGridIntersection_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcVirtualGridIntersection(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcVirtualGridIntersection *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcVirtualGridIntersection(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcVirtualGridIntersection_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcVirtualGridIntersection > ExpressDataSet::createIfcVirtualGridIntersection(bool isVolatile) {
    if (isVolatile) {
        return new IfcVirtualGridIntersection(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcVirtualGridIntersection * > (allocateIfcVirtualGridIntersection(this, Step::Id_UNSET));
    }
}

IfcVirtualGridIntersection *ExpressDataSet::cloneIfcVirtualGridIntersection(ExpressDataSet *expressDataSet, const IfcVirtualGridIntersection &obj, const CopyOp &copyop) {
    IfcVirtualGridIntersection *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcVirtualGridIntersection(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcVirtualGridIntersection_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcVirtualGridIntersection *ExpressDataSet::cloneIfcVirtualGridIntersection(const IfcVirtualGridIntersection &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcVirtualGridIntersection(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcVirtualGridIntersection(this, obj, copyop);
    }
}

IfcWall *ExpressDataSet::getIfcWall(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWall * > (current->second.get());
    }
    else {
        IfcWall *ret = static_cast< IfcWall * > (allocateIfcWall(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWall(IfcWall *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWall_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWall(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWall *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWall(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWall_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWall > ExpressDataSet::createIfcWall(bool isVolatile) {
    if (isVolatile) {
        return new IfcWall(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWall * > (allocateIfcWall(this, Step::Id_UNSET));
    }
}

IfcWall *ExpressDataSet::cloneIfcWall(ExpressDataSet *expressDataSet, const IfcWall &obj, const CopyOp &copyop) {
    IfcWall *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWall(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWall_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWall *ExpressDataSet::cloneIfcWall(const IfcWall &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWall(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWall(this, obj, copyop);
    }
}

IfcWallStandardCase *ExpressDataSet::getIfcWallStandardCase(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWallStandardCase * > (current->second.get());
    }
    else {
        IfcWallStandardCase *ret = static_cast< IfcWallStandardCase * > (allocateIfcWallStandardCase(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWallStandardCase(IfcWallStandardCase *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWallStandardCase_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWallStandardCase(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWallStandardCase *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWallStandardCase(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWallStandardCase_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWallStandardCase > ExpressDataSet::createIfcWallStandardCase(bool isVolatile) {
    if (isVolatile) {
        return new IfcWallStandardCase(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWallStandardCase * > (allocateIfcWallStandardCase(this, Step::Id_UNSET));
    }
}

IfcWallStandardCase *ExpressDataSet::cloneIfcWallStandardCase(ExpressDataSet *expressDataSet, const IfcWallStandardCase &obj, const CopyOp &copyop) {
    IfcWallStandardCase *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWallStandardCase(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWallStandardCase_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWallStandardCase *ExpressDataSet::cloneIfcWallStandardCase(const IfcWallStandardCase &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWallStandardCase(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWallStandardCase(this, obj, copyop);
    }
}

IfcWallType *ExpressDataSet::getIfcWallType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWallType * > (current->second.get());
    }
    else {
        IfcWallType *ret = static_cast< IfcWallType * > (allocateIfcWallType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWallType(IfcWallType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWallType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWallType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWallType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWallType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWallType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWallType > ExpressDataSet::createIfcWallType(bool isVolatile) {
    if (isVolatile) {
        return new IfcWallType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWallType * > (allocateIfcWallType(this, Step::Id_UNSET));
    }
}

IfcWallType *ExpressDataSet::cloneIfcWallType(ExpressDataSet *expressDataSet, const IfcWallType &obj, const CopyOp &copyop) {
    IfcWallType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWallType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWallType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWallType *ExpressDataSet::cloneIfcWallType(const IfcWallType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWallType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWallType(this, obj, copyop);
    }
}

IfcWasteTerminalType *ExpressDataSet::getIfcWasteTerminalType(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWasteTerminalType * > (current->second.get());
    }
    else {
        IfcWasteTerminalType *ret = static_cast< IfcWasteTerminalType * > (allocateIfcWasteTerminalType(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWasteTerminalType(IfcWasteTerminalType *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWasteTerminalType_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWasteTerminalType(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWasteTerminalType *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWasteTerminalType(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWasteTerminalType_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWasteTerminalType > ExpressDataSet::createIfcWasteTerminalType(bool isVolatile) {
    if (isVolatile) {
        return new IfcWasteTerminalType(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWasteTerminalType * > (allocateIfcWasteTerminalType(this, Step::Id_UNSET));
    }
}

IfcWasteTerminalType *ExpressDataSet::cloneIfcWasteTerminalType(ExpressDataSet *expressDataSet, const IfcWasteTerminalType &obj, const CopyOp &copyop) {
    IfcWasteTerminalType *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWasteTerminalType(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWasteTerminalType_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWasteTerminalType *ExpressDataSet::cloneIfcWasteTerminalType(const IfcWasteTerminalType &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWasteTerminalType(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWasteTerminalType(this, obj, copyop);
    }
}

IfcWaterProperties *ExpressDataSet::getIfcWaterProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWaterProperties * > (current->second.get());
    }
    else {
        IfcWaterProperties *ret = static_cast< IfcWaterProperties * > (allocateIfcWaterProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWaterProperties(IfcWaterProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWaterProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWaterProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWaterProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWaterProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWaterProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWaterProperties > ExpressDataSet::createIfcWaterProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcWaterProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWaterProperties * > (allocateIfcWaterProperties(this, Step::Id_UNSET));
    }
}

IfcWaterProperties *ExpressDataSet::cloneIfcWaterProperties(ExpressDataSet *expressDataSet, const IfcWaterProperties &obj, const CopyOp &copyop) {
    IfcWaterProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWaterProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWaterProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWaterProperties *ExpressDataSet::cloneIfcWaterProperties(const IfcWaterProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWaterProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWaterProperties(this, obj, copyop);
    }
}

IfcWindow *ExpressDataSet::getIfcWindow(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWindow * > (current->second.get());
    }
    else {
        IfcWindow *ret = static_cast< IfcWindow * > (allocateIfcWindow(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWindow(IfcWindow *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWindow_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindow(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWindow *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindow(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindow_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindow > ExpressDataSet::createIfcWindow(bool isVolatile) {
    if (isVolatile) {
        return new IfcWindow(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWindow * > (allocateIfcWindow(this, Step::Id_UNSET));
    }
}

IfcWindow *ExpressDataSet::cloneIfcWindow(ExpressDataSet *expressDataSet, const IfcWindow &obj, const CopyOp &copyop) {
    IfcWindow *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindow(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindow_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindow *ExpressDataSet::cloneIfcWindow(const IfcWindow &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWindow(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWindow(this, obj, copyop);
    }
}

IfcWindowLiningProperties *ExpressDataSet::getIfcWindowLiningProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWindowLiningProperties * > (current->second.get());
    }
    else {
        IfcWindowLiningProperties *ret = static_cast< IfcWindowLiningProperties * > (allocateIfcWindowLiningProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWindowLiningProperties(IfcWindowLiningProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWindowLiningProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowLiningProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWindowLiningProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowLiningProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowLiningProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowLiningProperties > ExpressDataSet::createIfcWindowLiningProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcWindowLiningProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWindowLiningProperties * > (allocateIfcWindowLiningProperties(this, Step::Id_UNSET));
    }
}

IfcWindowLiningProperties *ExpressDataSet::cloneIfcWindowLiningProperties(ExpressDataSet *expressDataSet, const IfcWindowLiningProperties &obj, const CopyOp &copyop) {
    IfcWindowLiningProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowLiningProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowLiningProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowLiningProperties *ExpressDataSet::cloneIfcWindowLiningProperties(const IfcWindowLiningProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWindowLiningProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWindowLiningProperties(this, obj, copyop);
    }
}

IfcWindowPanelProperties *ExpressDataSet::getIfcWindowPanelProperties(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWindowPanelProperties * > (current->second.get());
    }
    else {
        IfcWindowPanelProperties *ret = static_cast< IfcWindowPanelProperties * > (allocateIfcWindowPanelProperties(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWindowPanelProperties(IfcWindowPanelProperties *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWindowPanelProperties_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowPanelProperties(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWindowPanelProperties *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowPanelProperties(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowPanelProperties_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowPanelProperties > ExpressDataSet::createIfcWindowPanelProperties(bool isVolatile) {
    if (isVolatile) {
        return new IfcWindowPanelProperties(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWindowPanelProperties * > (allocateIfcWindowPanelProperties(this, Step::Id_UNSET));
    }
}

IfcWindowPanelProperties *ExpressDataSet::cloneIfcWindowPanelProperties(ExpressDataSet *expressDataSet, const IfcWindowPanelProperties &obj, const CopyOp &copyop) {
    IfcWindowPanelProperties *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowPanelProperties(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowPanelProperties_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowPanelProperties *ExpressDataSet::cloneIfcWindowPanelProperties(const IfcWindowPanelProperties &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWindowPanelProperties(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWindowPanelProperties(this, obj, copyop);
    }
}

IfcWindowStyle *ExpressDataSet::getIfcWindowStyle(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWindowStyle * > (current->second.get());
    }
    else {
        IfcWindowStyle *ret = static_cast< IfcWindowStyle * > (allocateIfcWindowStyle(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWindowStyle(IfcWindowStyle *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWindowStyle_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWindowStyle(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWindowStyle *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWindowStyle(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWindowStyle_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWindowStyle > ExpressDataSet::createIfcWindowStyle(bool isVolatile) {
    if (isVolatile) {
        return new IfcWindowStyle(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWindowStyle * > (allocateIfcWindowStyle(this, Step::Id_UNSET));
    }
}

IfcWindowStyle *ExpressDataSet::cloneIfcWindowStyle(ExpressDataSet *expressDataSet, const IfcWindowStyle &obj, const CopyOp &copyop) {
    IfcWindowStyle *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWindowStyle(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWindowStyle_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWindowStyle *ExpressDataSet::cloneIfcWindowStyle(const IfcWindowStyle &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWindowStyle(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWindowStyle(this, obj, copyop);
    }
}

IfcWorkPlan *ExpressDataSet::getIfcWorkPlan(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWorkPlan * > (current->second.get());
    }
    else {
        IfcWorkPlan *ret = static_cast< IfcWorkPlan * > (allocateIfcWorkPlan(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWorkPlan(IfcWorkPlan *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWorkPlan_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWorkPlan(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWorkPlan *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWorkPlan(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWorkPlan_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWorkPlan > ExpressDataSet::createIfcWorkPlan(bool isVolatile) {
    if (isVolatile) {
        return new IfcWorkPlan(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWorkPlan * > (allocateIfcWorkPlan(this, Step::Id_UNSET));
    }
}

IfcWorkPlan *ExpressDataSet::cloneIfcWorkPlan(ExpressDataSet *expressDataSet, const IfcWorkPlan &obj, const CopyOp &copyop) {
    IfcWorkPlan *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWorkPlan(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWorkPlan_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWorkPlan *ExpressDataSet::cloneIfcWorkPlan(const IfcWorkPlan &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWorkPlan(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWorkPlan(this, obj, copyop);
    }
}

IfcWorkSchedule *ExpressDataSet::getIfcWorkSchedule(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcWorkSchedule * > (current->second.get());
    }
    else {
        IfcWorkSchedule *ret = static_cast< IfcWorkSchedule * > (allocateIfcWorkSchedule(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcWorkSchedule(IfcWorkSchedule *arg) {
    getAll().erase(arg->getKey());
    return m_IfcWorkSchedule_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcWorkSchedule(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcWorkSchedule *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcWorkSchedule(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcWorkSchedule_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcWorkSchedule > ExpressDataSet::createIfcWorkSchedule(bool isVolatile) {
    if (isVolatile) {
        return new IfcWorkSchedule(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcWorkSchedule * > (allocateIfcWorkSchedule(this, Step::Id_UNSET));
    }
}

IfcWorkSchedule *ExpressDataSet::cloneIfcWorkSchedule(ExpressDataSet *expressDataSet, const IfcWorkSchedule &obj, const CopyOp &copyop) {
    IfcWorkSchedule *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcWorkSchedule(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcWorkSchedule_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcWorkSchedule *ExpressDataSet::cloneIfcWorkSchedule(const IfcWorkSchedule &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcWorkSchedule(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcWorkSchedule(this, obj, copyop);
    }
}

IfcZShapeProfileDef *ExpressDataSet::getIfcZShapeProfileDef(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcZShapeProfileDef * > (current->second.get());
    }
    else {
        IfcZShapeProfileDef *ret = static_cast< IfcZShapeProfileDef * > (allocateIfcZShapeProfileDef(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcZShapeProfileDef(IfcZShapeProfileDef *arg) {
    getAll().erase(arg->getKey());
    return m_IfcZShapeProfileDef_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcZShapeProfileDef(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcZShapeProfileDef *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcZShapeProfileDef(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcZShapeProfileDef_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcZShapeProfileDef > ExpressDataSet::createIfcZShapeProfileDef(bool isVolatile) {
    if (isVolatile) {
        return new IfcZShapeProfileDef(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcZShapeProfileDef * > (allocateIfcZShapeProfileDef(this, Step::Id_UNSET));
    }
}

IfcZShapeProfileDef *ExpressDataSet::cloneIfcZShapeProfileDef(ExpressDataSet *expressDataSet, const IfcZShapeProfileDef &obj, const CopyOp &copyop) {
    IfcZShapeProfileDef *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcZShapeProfileDef(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcZShapeProfileDef_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcZShapeProfileDef *ExpressDataSet::cloneIfcZShapeProfileDef(const IfcZShapeProfileDef &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcZShapeProfileDef(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcZShapeProfileDef(this, obj, copyop);
    }
}

IfcZone *ExpressDataSet::getIfcZone(Step::Id id) {
    Step::MapOfEntities::iterator current = getAll().find(id);
    if (current == getAll().end()) {
        return NULL;
    }
    if (!current->second->isOfType(Step::BaseSPFObject::getClassType())) {
        return static_cast< IfcZone * > (current->second.get());
    }
    else {
        IfcZone *ret = static_cast< IfcZone * > (allocateIfcZone(this, id));
        return ret;
    }
}

bool ExpressDataSet::removeIfcZone(IfcZone *arg) {
    getAll().erase(arg->getKey());
    return m_IfcZone_Map.erase(arg->getKey()) > 0;
}

Step::BaseEntity *ExpressDataSet::allocateIfcZone(Step::BaseExpressDataSet *expressDataSet, Step::Id id) {
    Step::SPFData *arg;
    IfcZone *ret;
    if (id == Step::Id_UNSET) {
        id = static_cast< ExpressDataSet * > (expressDataSet)->getNewId();
        arg = 0;
    }
    else {
        arg = static_cast< ExpressDataSet * > (expressDataSet)->getArgs(id);
    }
    ret = new IfcZone(id, arg);
    static_cast< ExpressDataSet * > (expressDataSet)->m_IfcZone_Map[id] = ret;
    static_cast< ExpressDataSet * > (expressDataSet)->registerObject(id, ret);
    return ret;
}

Step::RefPtr< IfcZone > ExpressDataSet::createIfcZone(bool isVolatile) {
    if (isVolatile) {
        return new IfcZone(Step::Id_UNSET, 0);
    }
    else {
        return static_cast< IfcZone * > (allocateIfcZone(this, Step::Id_UNSET));
    }
}

IfcZone *ExpressDataSet::cloneIfcZone(ExpressDataSet *expressDataSet, const IfcZone &obj, const CopyOp &copyop) {
    IfcZone *ret;
    Step::Id id = expressDataSet->getNewId();
    ret = new IfcZone(id, 0);
    ret->setKey(id);
    expressDataSet->m_IfcZone_Map[id] = ret;
    expressDataSet->registerObject(id, ret);
    copyop.associate(&obj, ret);
    ret->copy(obj, copyop);
    return ret;
}

IfcZone *ExpressDataSet::cloneIfcZone(const IfcZone &obj, const CopyOp &copyop) {
    if (copyop.getExpressDataSet()) {
        return ExpressDataSet::cloneIfcZone(const_cast< CopyOp & > (copyop).getExpressDataSet(), obj, copyop);
    }
    else {
        return ExpressDataSet::cloneIfcZone(this, obj, copyop);
    }
}

Step::RefLinkedList< Ifc2DCompositeCurve > &ExpressDataSet::getAllIfc2DCompositeCurve() {
    return m_refIfc2DCompositeCurveList;
}

Step::RefLinkedList< IfcActionRequest > &ExpressDataSet::getAllIfcActionRequest() {
    return m_refIfcActionRequestList;
}

Step::RefLinkedList< IfcActor > &ExpressDataSet::getAllIfcActor() {
    return m_refIfcActorList;
}

Step::RefLinkedList< IfcActorRole > &ExpressDataSet::getAllIfcActorRole() {
    return m_refIfcActorRoleList;
}

Step::RefLinkedList< IfcActuatorType > &ExpressDataSet::getAllIfcActuatorType() {
    return m_refIfcActuatorTypeList;
}

Step::RefLinkedList< IfcAddress > &ExpressDataSet::getAllIfcAddress() {
    return m_refIfcAddressList;
}

Step::RefLinkedList< IfcAirTerminalBoxType > &ExpressDataSet::getAllIfcAirTerminalBoxType() {
    return m_refIfcAirTerminalBoxTypeList;
}

Step::RefLinkedList< IfcAirTerminalType > &ExpressDataSet::getAllIfcAirTerminalType() {
    return m_refIfcAirTerminalTypeList;
}

Step::RefLinkedList< IfcAirToAirHeatRecoveryType > &ExpressDataSet::getAllIfcAirToAirHeatRecoveryType() {
    return m_refIfcAirToAirHeatRecoveryTypeList;
}

Step::RefLinkedList< IfcAlarmType > &ExpressDataSet::getAllIfcAlarmType() {
    return m_refIfcAlarmTypeList;
}

Step::RefLinkedList< IfcAngularDimension > &ExpressDataSet::getAllIfcAngularDimension() {
    return m_refIfcAngularDimensionList;
}

Step::RefLinkedList< IfcAnnotation > &ExpressDataSet::getAllIfcAnnotation() {
    return m_refIfcAnnotationList;
}

Step::RefLinkedList< IfcAnnotationCurveOccurrence > &ExpressDataSet::getAllIfcAnnotationCurveOccurrence() {
    return m_refIfcAnnotationCurveOccurrenceList;
}

Step::RefLinkedList< IfcAnnotationFillArea > &ExpressDataSet::getAllIfcAnnotationFillArea() {
    return m_refIfcAnnotationFillAreaList;
}

Step::RefLinkedList< IfcAnnotationFillAreaOccurrence > &ExpressDataSet::getAllIfcAnnotationFillAreaOccurrence() {
    return m_refIfcAnnotationFillAreaOccurrenceList;
}

Step::RefLinkedList< IfcAnnotationOccurrence > &ExpressDataSet::getAllIfcAnnotationOccurrence() {
    return m_refIfcAnnotationOccurrenceList;
}

Step::RefLinkedList< IfcAnnotationSurface > &ExpressDataSet::getAllIfcAnnotationSurface() {
    return m_refIfcAnnotationSurfaceList;
}

Step::RefLinkedList< IfcAnnotationSurfaceOccurrence > &ExpressDataSet::getAllIfcAnnotationSurfaceOccurrence() {
    return m_refIfcAnnotationSurfaceOccurrenceList;
}

Step::RefLinkedList< IfcAnnotationSymbolOccurrence > &ExpressDataSet::getAllIfcAnnotationSymbolOccurrence() {
    return m_refIfcAnnotationSymbolOccurrenceList;
}

Step::RefLinkedList< IfcAnnotationTextOccurrence > &ExpressDataSet::getAllIfcAnnotationTextOccurrence() {
    return m_refIfcAnnotationTextOccurrenceList;
}

Step::RefLinkedList< IfcApplication > &ExpressDataSet::getAllIfcApplication() {
    return m_refIfcApplicationList;
}

Step::RefLinkedList< IfcAppliedValue > &ExpressDataSet::getAllIfcAppliedValue() {
    return m_refIfcAppliedValueList;
}

Step::RefLinkedList< IfcAppliedValueRelationship > &ExpressDataSet::getAllIfcAppliedValueRelationship() {
    return m_refIfcAppliedValueRelationshipList;
}

Step::RefLinkedList< IfcApproval > &ExpressDataSet::getAllIfcApproval() {
    return m_refIfcApprovalList;
}

Step::RefLinkedList< IfcApprovalActorRelationship > &ExpressDataSet::getAllIfcApprovalActorRelationship() {
    return m_refIfcApprovalActorRelationshipList;
}

Step::RefLinkedList< IfcApprovalPropertyRelationship > &ExpressDataSet::getAllIfcApprovalPropertyRelationship() {
    return m_refIfcApprovalPropertyRelationshipList;
}

Step::RefLinkedList< IfcApprovalRelationship > &ExpressDataSet::getAllIfcApprovalRelationship() {
    return m_refIfcApprovalRelationshipList;
}

Step::RefLinkedList< IfcArbitraryClosedProfileDef > &ExpressDataSet::getAllIfcArbitraryClosedProfileDef() {
    return m_refIfcArbitraryClosedProfileDefList;
}

Step::RefLinkedList< IfcArbitraryOpenProfileDef > &ExpressDataSet::getAllIfcArbitraryOpenProfileDef() {
    return m_refIfcArbitraryOpenProfileDefList;
}

Step::RefLinkedList< IfcArbitraryProfileDefWithVoids > &ExpressDataSet::getAllIfcArbitraryProfileDefWithVoids() {
    return m_refIfcArbitraryProfileDefWithVoidsList;
}

Step::RefLinkedList< IfcAsset > &ExpressDataSet::getAllIfcAsset() {
    return m_refIfcAssetList;
}

Step::RefLinkedList< IfcAsymmetricIShapeProfileDef > &ExpressDataSet::getAllIfcAsymmetricIShapeProfileDef() {
    return m_refIfcAsymmetricIShapeProfileDefList;
}

Step::RefLinkedList< IfcAxis1Placement > &ExpressDataSet::getAllIfcAxis1Placement() {
    return m_refIfcAxis1PlacementList;
}

Step::RefLinkedList< IfcAxis2Placement2D > &ExpressDataSet::getAllIfcAxis2Placement2D() {
    return m_refIfcAxis2Placement2DList;
}

Step::RefLinkedList< IfcAxis2Placement3D > &ExpressDataSet::getAllIfcAxis2Placement3D() {
    return m_refIfcAxis2Placement3DList;
}

Step::RefLinkedList< IfcBSplineCurve > &ExpressDataSet::getAllIfcBSplineCurve() {
    return m_refIfcBSplineCurveList;
}

Step::RefLinkedList< IfcBeam > &ExpressDataSet::getAllIfcBeam() {
    return m_refIfcBeamList;
}

Step::RefLinkedList< IfcBeamType > &ExpressDataSet::getAllIfcBeamType() {
    return m_refIfcBeamTypeList;
}

Step::RefLinkedList< IfcBezierCurve > &ExpressDataSet::getAllIfcBezierCurve() {
    return m_refIfcBezierCurveList;
}

Step::RefLinkedList< IfcBlobTexture > &ExpressDataSet::getAllIfcBlobTexture() {
    return m_refIfcBlobTextureList;
}

Step::RefLinkedList< IfcBlock > &ExpressDataSet::getAllIfcBlock() {
    return m_refIfcBlockList;
}

Step::RefLinkedList< IfcBoilerType > &ExpressDataSet::getAllIfcBoilerType() {
    return m_refIfcBoilerTypeList;
}

Step::RefLinkedList< IfcBooleanClippingResult > &ExpressDataSet::getAllIfcBooleanClippingResult() {
    return m_refIfcBooleanClippingResultList;
}

Step::RefLinkedList< IfcBooleanResult > &ExpressDataSet::getAllIfcBooleanResult() {
    return m_refIfcBooleanResultList;
}

Step::RefLinkedList< IfcBoundaryCondition > &ExpressDataSet::getAllIfcBoundaryCondition() {
    return m_refIfcBoundaryConditionList;
}

Step::RefLinkedList< IfcBoundaryEdgeCondition > &ExpressDataSet::getAllIfcBoundaryEdgeCondition() {
    return m_refIfcBoundaryEdgeConditionList;
}

Step::RefLinkedList< IfcBoundaryFaceCondition > &ExpressDataSet::getAllIfcBoundaryFaceCondition() {
    return m_refIfcBoundaryFaceConditionList;
}

Step::RefLinkedList< IfcBoundaryNodeCondition > &ExpressDataSet::getAllIfcBoundaryNodeCondition() {
    return m_refIfcBoundaryNodeConditionList;
}

Step::RefLinkedList< IfcBoundaryNodeConditionWarping > &ExpressDataSet::getAllIfcBoundaryNodeConditionWarping() {
    return m_refIfcBoundaryNodeConditionWarpingList;
}

Step::RefLinkedList< IfcBoundedCurve > &ExpressDataSet::getAllIfcBoundedCurve() {
    return m_refIfcBoundedCurveList;
}

Step::RefLinkedList< IfcBoundedSurface > &ExpressDataSet::getAllIfcBoundedSurface() {
    return m_refIfcBoundedSurfaceList;
}

Step::RefLinkedList< IfcBoundingBox > &ExpressDataSet::getAllIfcBoundingBox() {
    return m_refIfcBoundingBoxList;
}

Step::RefLinkedList< IfcBoxedHalfSpace > &ExpressDataSet::getAllIfcBoxedHalfSpace() {
    return m_refIfcBoxedHalfSpaceList;
}

Step::RefLinkedList< IfcBuilding > &ExpressDataSet::getAllIfcBuilding() {
    return m_refIfcBuildingList;
}

Step::RefLinkedList< IfcBuildingElement > &ExpressDataSet::getAllIfcBuildingElement() {
    return m_refIfcBuildingElementList;
}

Step::RefLinkedList< IfcBuildingElementComponent > &ExpressDataSet::getAllIfcBuildingElementComponent() {
    return m_refIfcBuildingElementComponentList;
}

Step::RefLinkedList< IfcBuildingElementPart > &ExpressDataSet::getAllIfcBuildingElementPart() {
    return m_refIfcBuildingElementPartList;
}

Step::RefLinkedList< IfcBuildingElementProxy > &ExpressDataSet::getAllIfcBuildingElementProxy() {
    return m_refIfcBuildingElementProxyList;
}

Step::RefLinkedList< IfcBuildingElementProxyType > &ExpressDataSet::getAllIfcBuildingElementProxyType() {
    return m_refIfcBuildingElementProxyTypeList;
}

Step::RefLinkedList< IfcBuildingElementType > &ExpressDataSet::getAllIfcBuildingElementType() {
    return m_refIfcBuildingElementTypeList;
}

Step::RefLinkedList< IfcBuildingStorey > &ExpressDataSet::getAllIfcBuildingStorey() {
    return m_refIfcBuildingStoreyList;
}

Step::RefLinkedList< IfcCShapeProfileDef > &ExpressDataSet::getAllIfcCShapeProfileDef() {
    return m_refIfcCShapeProfileDefList;
}

Step::RefLinkedList< IfcCableCarrierFittingType > &ExpressDataSet::getAllIfcCableCarrierFittingType() {
    return m_refIfcCableCarrierFittingTypeList;
}

Step::RefLinkedList< IfcCableCarrierSegmentType > &ExpressDataSet::getAllIfcCableCarrierSegmentType() {
    return m_refIfcCableCarrierSegmentTypeList;
}

Step::RefLinkedList< IfcCableSegmentType > &ExpressDataSet::getAllIfcCableSegmentType() {
    return m_refIfcCableSegmentTypeList;
}

Step::RefLinkedList< IfcCalendarDate > &ExpressDataSet::getAllIfcCalendarDate() {
    return m_refIfcCalendarDateList;
}

Step::RefLinkedList< IfcCartesianPoint > &ExpressDataSet::getAllIfcCartesianPoint() {
    return m_refIfcCartesianPointList;
}

Step::RefLinkedList< IfcCartesianTransformationOperator > &ExpressDataSet::getAllIfcCartesianTransformationOperator() {
    return m_refIfcCartesianTransformationOperatorList;
}

Step::RefLinkedList< IfcCartesianTransformationOperator2D > &ExpressDataSet::getAllIfcCartesianTransformationOperator2D() {
    return m_refIfcCartesianTransformationOperator2DList;
}

Step::RefLinkedList< IfcCartesianTransformationOperator2DnonUniform > &ExpressDataSet::getAllIfcCartesianTransformationOperator2DnonUniform() {
    return m_refIfcCartesianTransformationOperator2DnonUniformList;
}

Step::RefLinkedList< IfcCartesianTransformationOperator3D > &ExpressDataSet::getAllIfcCartesianTransformationOperator3D() {
    return m_refIfcCartesianTransformationOperator3DList;
}

Step::RefLinkedList< IfcCartesianTransformationOperator3DnonUniform > &ExpressDataSet::getAllIfcCartesianTransformationOperator3DnonUniform() {
    return m_refIfcCartesianTransformationOperator3DnonUniformList;
}

Step::RefLinkedList< IfcCenterLineProfileDef > &ExpressDataSet::getAllIfcCenterLineProfileDef() {
    return m_refIfcCenterLineProfileDefList;
}

Step::RefLinkedList< IfcChamferEdgeFeature > &ExpressDataSet::getAllIfcChamferEdgeFeature() {
    return m_refIfcChamferEdgeFeatureList;
}

Step::RefLinkedList< IfcChillerType > &ExpressDataSet::getAllIfcChillerType() {
    return m_refIfcChillerTypeList;
}

Step::RefLinkedList< IfcCircle > &ExpressDataSet::getAllIfcCircle() {
    return m_refIfcCircleList;
}

Step::RefLinkedList< IfcCircleHollowProfileDef > &ExpressDataSet::getAllIfcCircleHollowProfileDef() {
    return m_refIfcCircleHollowProfileDefList;
}

Step::RefLinkedList< IfcCircleProfileDef > &ExpressDataSet::getAllIfcCircleProfileDef() {
    return m_refIfcCircleProfileDefList;
}

Step::RefLinkedList< IfcClassification > &ExpressDataSet::getAllIfcClassification() {
    return m_refIfcClassificationList;
}

Step::RefLinkedList< IfcClassificationItem > &ExpressDataSet::getAllIfcClassificationItem() {
    return m_refIfcClassificationItemList;
}

Step::RefLinkedList< IfcClassificationItemRelationship > &ExpressDataSet::getAllIfcClassificationItemRelationship() {
    return m_refIfcClassificationItemRelationshipList;
}

Step::RefLinkedList< IfcClassificationNotation > &ExpressDataSet::getAllIfcClassificationNotation() {
    return m_refIfcClassificationNotationList;
}

Step::RefLinkedList< IfcClassificationNotationFacet > &ExpressDataSet::getAllIfcClassificationNotationFacet() {
    return m_refIfcClassificationNotationFacetList;
}

Step::RefLinkedList< IfcClassificationReference > &ExpressDataSet::getAllIfcClassificationReference() {
    return m_refIfcClassificationReferenceList;
}

Step::RefLinkedList< IfcClosedShell > &ExpressDataSet::getAllIfcClosedShell() {
    return m_refIfcClosedShellList;
}

Step::RefLinkedList< IfcCoilType > &ExpressDataSet::getAllIfcCoilType() {
    return m_refIfcCoilTypeList;
}

Step::RefLinkedList< IfcColourRgb > &ExpressDataSet::getAllIfcColourRgb() {
    return m_refIfcColourRgbList;
}

Step::RefLinkedList< IfcColourSpecification > &ExpressDataSet::getAllIfcColourSpecification() {
    return m_refIfcColourSpecificationList;
}

Step::RefLinkedList< IfcColumn > &ExpressDataSet::getAllIfcColumn() {
    return m_refIfcColumnList;
}

Step::RefLinkedList< IfcColumnType > &ExpressDataSet::getAllIfcColumnType() {
    return m_refIfcColumnTypeList;
}

Step::RefLinkedList< IfcComplexProperty > &ExpressDataSet::getAllIfcComplexProperty() {
    return m_refIfcComplexPropertyList;
}

Step::RefLinkedList< IfcCompositeCurve > &ExpressDataSet::getAllIfcCompositeCurve() {
    return m_refIfcCompositeCurveList;
}

Step::RefLinkedList< IfcCompositeCurveSegment > &ExpressDataSet::getAllIfcCompositeCurveSegment() {
    return m_refIfcCompositeCurveSegmentList;
}

Step::RefLinkedList< IfcCompositeProfileDef > &ExpressDataSet::getAllIfcCompositeProfileDef() {
    return m_refIfcCompositeProfileDefList;
}

Step::RefLinkedList< IfcCompressorType > &ExpressDataSet::getAllIfcCompressorType() {
    return m_refIfcCompressorTypeList;
}

Step::RefLinkedList< IfcCondenserType > &ExpressDataSet::getAllIfcCondenserType() {
    return m_refIfcCondenserTypeList;
}

Step::RefLinkedList< IfcCondition > &ExpressDataSet::getAllIfcCondition() {
    return m_refIfcConditionList;
}

Step::RefLinkedList< IfcConditionCriterion > &ExpressDataSet::getAllIfcConditionCriterion() {
    return m_refIfcConditionCriterionList;
}

Step::RefLinkedList< IfcConic > &ExpressDataSet::getAllIfcConic() {
    return m_refIfcConicList;
}

Step::RefLinkedList< IfcConnectedFaceSet > &ExpressDataSet::getAllIfcConnectedFaceSet() {
    return m_refIfcConnectedFaceSetList;
}

Step::RefLinkedList< IfcConnectionCurveGeometry > &ExpressDataSet::getAllIfcConnectionCurveGeometry() {
    return m_refIfcConnectionCurveGeometryList;
}

Step::RefLinkedList< IfcConnectionGeometry > &ExpressDataSet::getAllIfcConnectionGeometry() {
    return m_refIfcConnectionGeometryList;
}

Step::RefLinkedList< IfcConnectionPointEccentricity > &ExpressDataSet::getAllIfcConnectionPointEccentricity() {
    return m_refIfcConnectionPointEccentricityList;
}

Step::RefLinkedList< IfcConnectionPointGeometry > &ExpressDataSet::getAllIfcConnectionPointGeometry() {
    return m_refIfcConnectionPointGeometryList;
}

Step::RefLinkedList< IfcConnectionPortGeometry > &ExpressDataSet::getAllIfcConnectionPortGeometry() {
    return m_refIfcConnectionPortGeometryList;
}

Step::RefLinkedList< IfcConnectionSurfaceGeometry > &ExpressDataSet::getAllIfcConnectionSurfaceGeometry() {
    return m_refIfcConnectionSurfaceGeometryList;
}

Step::RefLinkedList< IfcConstraint > &ExpressDataSet::getAllIfcConstraint() {
    return m_refIfcConstraintList;
}

Step::RefLinkedList< IfcConstraintAggregationRelationship > &ExpressDataSet::getAllIfcConstraintAggregationRelationship() {
    return m_refIfcConstraintAggregationRelationshipList;
}

Step::RefLinkedList< IfcConstraintClassificationRelationship > &ExpressDataSet::getAllIfcConstraintClassificationRelationship() {
    return m_refIfcConstraintClassificationRelationshipList;
}

Step::RefLinkedList< IfcConstraintRelationship > &ExpressDataSet::getAllIfcConstraintRelationship() {
    return m_refIfcConstraintRelationshipList;
}

Step::RefLinkedList< IfcConstructionEquipmentResource > &ExpressDataSet::getAllIfcConstructionEquipmentResource() {
    return m_refIfcConstructionEquipmentResourceList;
}

Step::RefLinkedList< IfcConstructionMaterialResource > &ExpressDataSet::getAllIfcConstructionMaterialResource() {
    return m_refIfcConstructionMaterialResourceList;
}

Step::RefLinkedList< IfcConstructionProductResource > &ExpressDataSet::getAllIfcConstructionProductResource() {
    return m_refIfcConstructionProductResourceList;
}

Step::RefLinkedList< IfcConstructionResource > &ExpressDataSet::getAllIfcConstructionResource() {
    return m_refIfcConstructionResourceList;
}

Step::RefLinkedList< IfcContextDependentUnit > &ExpressDataSet::getAllIfcContextDependentUnit() {
    return m_refIfcContextDependentUnitList;
}

Step::RefLinkedList< IfcControl > &ExpressDataSet::getAllIfcControl() {
    return m_refIfcControlList;
}

Step::RefLinkedList< IfcControllerType > &ExpressDataSet::getAllIfcControllerType() {
    return m_refIfcControllerTypeList;
}

Step::RefLinkedList< IfcConversionBasedUnit > &ExpressDataSet::getAllIfcConversionBasedUnit() {
    return m_refIfcConversionBasedUnitList;
}

Step::RefLinkedList< IfcCooledBeamType > &ExpressDataSet::getAllIfcCooledBeamType() {
    return m_refIfcCooledBeamTypeList;
}

Step::RefLinkedList< IfcCoolingTowerType > &ExpressDataSet::getAllIfcCoolingTowerType() {
    return m_refIfcCoolingTowerTypeList;
}

Step::RefLinkedList< IfcCoordinatedUniversalTimeOffset > &ExpressDataSet::getAllIfcCoordinatedUniversalTimeOffset() {
    return m_refIfcCoordinatedUniversalTimeOffsetList;
}

Step::RefLinkedList< IfcCostItem > &ExpressDataSet::getAllIfcCostItem() {
    return m_refIfcCostItemList;
}

Step::RefLinkedList< IfcCostSchedule > &ExpressDataSet::getAllIfcCostSchedule() {
    return m_refIfcCostScheduleList;
}

Step::RefLinkedList< IfcCostValue > &ExpressDataSet::getAllIfcCostValue() {
    return m_refIfcCostValueList;
}

Step::RefLinkedList< IfcCovering > &ExpressDataSet::getAllIfcCovering() {
    return m_refIfcCoveringList;
}

Step::RefLinkedList< IfcCoveringType > &ExpressDataSet::getAllIfcCoveringType() {
    return m_refIfcCoveringTypeList;
}

Step::RefLinkedList< IfcCraneRailAShapeProfileDef > &ExpressDataSet::getAllIfcCraneRailAShapeProfileDef() {
    return m_refIfcCraneRailAShapeProfileDefList;
}

Step::RefLinkedList< IfcCraneRailFShapeProfileDef > &ExpressDataSet::getAllIfcCraneRailFShapeProfileDef() {
    return m_refIfcCraneRailFShapeProfileDefList;
}

Step::RefLinkedList< IfcCrewResource > &ExpressDataSet::getAllIfcCrewResource() {
    return m_refIfcCrewResourceList;
}

Step::RefLinkedList< IfcCsgPrimitive3D > &ExpressDataSet::getAllIfcCsgPrimitive3D() {
    return m_refIfcCsgPrimitive3DList;
}

Step::RefLinkedList< IfcCsgSolid > &ExpressDataSet::getAllIfcCsgSolid() {
    return m_refIfcCsgSolidList;
}

Step::RefLinkedList< IfcCurrencyRelationship > &ExpressDataSet::getAllIfcCurrencyRelationship() {
    return m_refIfcCurrencyRelationshipList;
}

Step::RefLinkedList< IfcCurtainWall > &ExpressDataSet::getAllIfcCurtainWall() {
    return m_refIfcCurtainWallList;
}

Step::RefLinkedList< IfcCurtainWallType > &ExpressDataSet::getAllIfcCurtainWallType() {
    return m_refIfcCurtainWallTypeList;
}

Step::RefLinkedList< IfcCurve > &ExpressDataSet::getAllIfcCurve() {
    return m_refIfcCurveList;
}

Step::RefLinkedList< IfcCurveBoundedPlane > &ExpressDataSet::getAllIfcCurveBoundedPlane() {
    return m_refIfcCurveBoundedPlaneList;
}

Step::RefLinkedList< IfcCurveStyle > &ExpressDataSet::getAllIfcCurveStyle() {
    return m_refIfcCurveStyleList;
}

Step::RefLinkedList< IfcCurveStyleFont > &ExpressDataSet::getAllIfcCurveStyleFont() {
    return m_refIfcCurveStyleFontList;
}

Step::RefLinkedList< IfcCurveStyleFontAndScaling > &ExpressDataSet::getAllIfcCurveStyleFontAndScaling() {
    return m_refIfcCurveStyleFontAndScalingList;
}

Step::RefLinkedList< IfcCurveStyleFontPattern > &ExpressDataSet::getAllIfcCurveStyleFontPattern() {
    return m_refIfcCurveStyleFontPatternList;
}

Step::RefLinkedList< IfcDamperType > &ExpressDataSet::getAllIfcDamperType() {
    return m_refIfcDamperTypeList;
}

Step::RefLinkedList< IfcDateAndTime > &ExpressDataSet::getAllIfcDateAndTime() {
    return m_refIfcDateAndTimeList;
}

Step::RefLinkedList< IfcDefinedSymbol > &ExpressDataSet::getAllIfcDefinedSymbol() {
    return m_refIfcDefinedSymbolList;
}

Step::RefLinkedList< IfcDerivedProfileDef > &ExpressDataSet::getAllIfcDerivedProfileDef() {
    return m_refIfcDerivedProfileDefList;
}

Step::RefLinkedList< IfcDerivedUnit > &ExpressDataSet::getAllIfcDerivedUnit() {
    return m_refIfcDerivedUnitList;
}

Step::RefLinkedList< IfcDerivedUnitElement > &ExpressDataSet::getAllIfcDerivedUnitElement() {
    return m_refIfcDerivedUnitElementList;
}

Step::RefLinkedList< IfcDiameterDimension > &ExpressDataSet::getAllIfcDiameterDimension() {
    return m_refIfcDiameterDimensionList;
}

Step::RefLinkedList< IfcDimensionCalloutRelationship > &ExpressDataSet::getAllIfcDimensionCalloutRelationship() {
    return m_refIfcDimensionCalloutRelationshipList;
}

Step::RefLinkedList< IfcDimensionCurve > &ExpressDataSet::getAllIfcDimensionCurve() {
    return m_refIfcDimensionCurveList;
}

Step::RefLinkedList< IfcDimensionCurveDirectedCallout > &ExpressDataSet::getAllIfcDimensionCurveDirectedCallout() {
    return m_refIfcDimensionCurveDirectedCalloutList;
}

Step::RefLinkedList< IfcDimensionCurveTerminator > &ExpressDataSet::getAllIfcDimensionCurveTerminator() {
    return m_refIfcDimensionCurveTerminatorList;
}

Step::RefLinkedList< IfcDimensionPair > &ExpressDataSet::getAllIfcDimensionPair() {
    return m_refIfcDimensionPairList;
}

Step::RefLinkedList< IfcDimensionalExponents > &ExpressDataSet::getAllIfcDimensionalExponents() {
    return m_refIfcDimensionalExponentsList;
}

Step::RefLinkedList< IfcDirection > &ExpressDataSet::getAllIfcDirection() {
    return m_refIfcDirectionList;
}

Step::RefLinkedList< IfcDiscreteAccessory > &ExpressDataSet::getAllIfcDiscreteAccessory() {
    return m_refIfcDiscreteAccessoryList;
}

Step::RefLinkedList< IfcDiscreteAccessoryType > &ExpressDataSet::getAllIfcDiscreteAccessoryType() {
    return m_refIfcDiscreteAccessoryTypeList;
}

Step::RefLinkedList< IfcDistributionChamberElement > &ExpressDataSet::getAllIfcDistributionChamberElement() {
    return m_refIfcDistributionChamberElementList;
}

Step::RefLinkedList< IfcDistributionChamberElementType > &ExpressDataSet::getAllIfcDistributionChamberElementType() {
    return m_refIfcDistributionChamberElementTypeList;
}

Step::RefLinkedList< IfcDistributionControlElement > &ExpressDataSet::getAllIfcDistributionControlElement() {
    return m_refIfcDistributionControlElementList;
}

Step::RefLinkedList< IfcDistributionControlElementType > &ExpressDataSet::getAllIfcDistributionControlElementType() {
    return m_refIfcDistributionControlElementTypeList;
}

Step::RefLinkedList< IfcDistributionElement > &ExpressDataSet::getAllIfcDistributionElement() {
    return m_refIfcDistributionElementList;
}

Step::RefLinkedList< IfcDistributionElementType > &ExpressDataSet::getAllIfcDistributionElementType() {
    return m_refIfcDistributionElementTypeList;
}

Step::RefLinkedList< IfcDistributionFlowElement > &ExpressDataSet::getAllIfcDistributionFlowElement() {
    return m_refIfcDistributionFlowElementList;
}

Step::RefLinkedList< IfcDistributionFlowElementType > &ExpressDataSet::getAllIfcDistributionFlowElementType() {
    return m_refIfcDistributionFlowElementTypeList;
}

Step::RefLinkedList< IfcDistributionPort > &ExpressDataSet::getAllIfcDistributionPort() {
    return m_refIfcDistributionPortList;
}

Step::RefLinkedList< IfcDocumentElectronicFormat > &ExpressDataSet::getAllIfcDocumentElectronicFormat() {
    return m_refIfcDocumentElectronicFormatList;
}

Step::RefLinkedList< IfcDocumentInformation > &ExpressDataSet::getAllIfcDocumentInformation() {
    return m_refIfcDocumentInformationList;
}

Step::RefLinkedList< IfcDocumentInformationRelationship > &ExpressDataSet::getAllIfcDocumentInformationRelationship() {
    return m_refIfcDocumentInformationRelationshipList;
}

Step::RefLinkedList< IfcDocumentReference > &ExpressDataSet::getAllIfcDocumentReference() {
    return m_refIfcDocumentReferenceList;
}

Step::RefLinkedList< IfcDoor > &ExpressDataSet::getAllIfcDoor() {
    return m_refIfcDoorList;
}

Step::RefLinkedList< IfcDoorLiningProperties > &ExpressDataSet::getAllIfcDoorLiningProperties() {
    return m_refIfcDoorLiningPropertiesList;
}

Step::RefLinkedList< IfcDoorPanelProperties > &ExpressDataSet::getAllIfcDoorPanelProperties() {
    return m_refIfcDoorPanelPropertiesList;
}

Step::RefLinkedList< IfcDoorStyle > &ExpressDataSet::getAllIfcDoorStyle() {
    return m_refIfcDoorStyleList;
}

Step::RefLinkedList< IfcDraughtingCallout > &ExpressDataSet::getAllIfcDraughtingCallout() {
    return m_refIfcDraughtingCalloutList;
}

Step::RefLinkedList< IfcDraughtingCalloutRelationship > &ExpressDataSet::getAllIfcDraughtingCalloutRelationship() {
    return m_refIfcDraughtingCalloutRelationshipList;
}

Step::RefLinkedList< IfcDraughtingPreDefinedColour > &ExpressDataSet::getAllIfcDraughtingPreDefinedColour() {
    return m_refIfcDraughtingPreDefinedColourList;
}

Step::RefLinkedList< IfcDraughtingPreDefinedCurveFont > &ExpressDataSet::getAllIfcDraughtingPreDefinedCurveFont() {
    return m_refIfcDraughtingPreDefinedCurveFontList;
}

Step::RefLinkedList< IfcDraughtingPreDefinedTextFont > &ExpressDataSet::getAllIfcDraughtingPreDefinedTextFont() {
    return m_refIfcDraughtingPreDefinedTextFontList;
}

Step::RefLinkedList< IfcDuctFittingType > &ExpressDataSet::getAllIfcDuctFittingType() {
    return m_refIfcDuctFittingTypeList;
}

Step::RefLinkedList< IfcDuctSegmentType > &ExpressDataSet::getAllIfcDuctSegmentType() {
    return m_refIfcDuctSegmentTypeList;
}

Step::RefLinkedList< IfcDuctSilencerType > &ExpressDataSet::getAllIfcDuctSilencerType() {
    return m_refIfcDuctSilencerTypeList;
}

Step::RefLinkedList< IfcEdge > &ExpressDataSet::getAllIfcEdge() {
    return m_refIfcEdgeList;
}

Step::RefLinkedList< IfcEdgeCurve > &ExpressDataSet::getAllIfcEdgeCurve() {
    return m_refIfcEdgeCurveList;
}

Step::RefLinkedList< IfcEdgeFeature > &ExpressDataSet::getAllIfcEdgeFeature() {
    return m_refIfcEdgeFeatureList;
}

Step::RefLinkedList< IfcEdgeLoop > &ExpressDataSet::getAllIfcEdgeLoop() {
    return m_refIfcEdgeLoopList;
}

Step::RefLinkedList< IfcElectricApplianceType > &ExpressDataSet::getAllIfcElectricApplianceType() {
    return m_refIfcElectricApplianceTypeList;
}

Step::RefLinkedList< IfcElectricDistributionPoint > &ExpressDataSet::getAllIfcElectricDistributionPoint() {
    return m_refIfcElectricDistributionPointList;
}

Step::RefLinkedList< IfcElectricFlowStorageDeviceType > &ExpressDataSet::getAllIfcElectricFlowStorageDeviceType() {
    return m_refIfcElectricFlowStorageDeviceTypeList;
}

Step::RefLinkedList< IfcElectricGeneratorType > &ExpressDataSet::getAllIfcElectricGeneratorType() {
    return m_refIfcElectricGeneratorTypeList;
}

Step::RefLinkedList< IfcElectricHeaterType > &ExpressDataSet::getAllIfcElectricHeaterType() {
    return m_refIfcElectricHeaterTypeList;
}

Step::RefLinkedList< IfcElectricMotorType > &ExpressDataSet::getAllIfcElectricMotorType() {
    return m_refIfcElectricMotorTypeList;
}

Step::RefLinkedList< IfcElectricTimeControlType > &ExpressDataSet::getAllIfcElectricTimeControlType() {
    return m_refIfcElectricTimeControlTypeList;
}

Step::RefLinkedList< IfcElectricalBaseProperties > &ExpressDataSet::getAllIfcElectricalBaseProperties() {
    return m_refIfcElectricalBasePropertiesList;
}

Step::RefLinkedList< IfcElectricalCircuit > &ExpressDataSet::getAllIfcElectricalCircuit() {
    return m_refIfcElectricalCircuitList;
}

Step::RefLinkedList< IfcElectricalElement > &ExpressDataSet::getAllIfcElectricalElement() {
    return m_refIfcElectricalElementList;
}

Step::RefLinkedList< IfcElement > &ExpressDataSet::getAllIfcElement() {
    return m_refIfcElementList;
}

Step::RefLinkedList< IfcElementAssembly > &ExpressDataSet::getAllIfcElementAssembly() {
    return m_refIfcElementAssemblyList;
}

Step::RefLinkedList< IfcElementComponent > &ExpressDataSet::getAllIfcElementComponent() {
    return m_refIfcElementComponentList;
}

Step::RefLinkedList< IfcElementComponentType > &ExpressDataSet::getAllIfcElementComponentType() {
    return m_refIfcElementComponentTypeList;
}

Step::RefLinkedList< IfcElementQuantity > &ExpressDataSet::getAllIfcElementQuantity() {
    return m_refIfcElementQuantityList;
}

Step::RefLinkedList< IfcElementType > &ExpressDataSet::getAllIfcElementType() {
    return m_refIfcElementTypeList;
}

Step::RefLinkedList< IfcElementarySurface > &ExpressDataSet::getAllIfcElementarySurface() {
    return m_refIfcElementarySurfaceList;
}

Step::RefLinkedList< IfcEllipse > &ExpressDataSet::getAllIfcEllipse() {
    return m_refIfcEllipseList;
}

Step::RefLinkedList< IfcEllipseProfileDef > &ExpressDataSet::getAllIfcEllipseProfileDef() {
    return m_refIfcEllipseProfileDefList;
}

Step::RefLinkedList< IfcEnergyConversionDevice > &ExpressDataSet::getAllIfcEnergyConversionDevice() {
    return m_refIfcEnergyConversionDeviceList;
}

Step::RefLinkedList< IfcEnergyConversionDeviceType > &ExpressDataSet::getAllIfcEnergyConversionDeviceType() {
    return m_refIfcEnergyConversionDeviceTypeList;
}

Step::RefLinkedList< IfcEnergyProperties > &ExpressDataSet::getAllIfcEnergyProperties() {
    return m_refIfcEnergyPropertiesList;
}

Step::RefLinkedList< IfcEnvironmentalImpactValue > &ExpressDataSet::getAllIfcEnvironmentalImpactValue() {
    return m_refIfcEnvironmentalImpactValueList;
}

Step::RefLinkedList< IfcEquipmentElement > &ExpressDataSet::getAllIfcEquipmentElement() {
    return m_refIfcEquipmentElementList;
}

Step::RefLinkedList< IfcEquipmentStandard > &ExpressDataSet::getAllIfcEquipmentStandard() {
    return m_refIfcEquipmentStandardList;
}

Step::RefLinkedList< IfcEvaporativeCoolerType > &ExpressDataSet::getAllIfcEvaporativeCoolerType() {
    return m_refIfcEvaporativeCoolerTypeList;
}

Step::RefLinkedList< IfcEvaporatorType > &ExpressDataSet::getAllIfcEvaporatorType() {
    return m_refIfcEvaporatorTypeList;
}

Step::RefLinkedList< IfcExtendedMaterialProperties > &ExpressDataSet::getAllIfcExtendedMaterialProperties() {
    return m_refIfcExtendedMaterialPropertiesList;
}

Step::RefLinkedList< IfcExternalReference > &ExpressDataSet::getAllIfcExternalReference() {
    return m_refIfcExternalReferenceList;
}

Step::RefLinkedList< IfcExternallyDefinedHatchStyle > &ExpressDataSet::getAllIfcExternallyDefinedHatchStyle() {
    return m_refIfcExternallyDefinedHatchStyleList;
}

Step::RefLinkedList< IfcExternallyDefinedSurfaceStyle > &ExpressDataSet::getAllIfcExternallyDefinedSurfaceStyle() {
    return m_refIfcExternallyDefinedSurfaceStyleList;
}

Step::RefLinkedList< IfcExternallyDefinedSymbol > &ExpressDataSet::getAllIfcExternallyDefinedSymbol() {
    return m_refIfcExternallyDefinedSymbolList;
}

Step::RefLinkedList< IfcExternallyDefinedTextFont > &ExpressDataSet::getAllIfcExternallyDefinedTextFont() {
    return m_refIfcExternallyDefinedTextFontList;
}

Step::RefLinkedList< IfcExtrudedAreaSolid > &ExpressDataSet::getAllIfcExtrudedAreaSolid() {
    return m_refIfcExtrudedAreaSolidList;
}

Step::RefLinkedList< IfcFace > &ExpressDataSet::getAllIfcFace() {
    return m_refIfcFaceList;
}

Step::RefLinkedList< IfcFaceBasedSurfaceModel > &ExpressDataSet::getAllIfcFaceBasedSurfaceModel() {
    return m_refIfcFaceBasedSurfaceModelList;
}

Step::RefLinkedList< IfcFaceBound > &ExpressDataSet::getAllIfcFaceBound() {
    return m_refIfcFaceBoundList;
}

Step::RefLinkedList< IfcFaceOuterBound > &ExpressDataSet::getAllIfcFaceOuterBound() {
    return m_refIfcFaceOuterBoundList;
}

Step::RefLinkedList< IfcFaceSurface > &ExpressDataSet::getAllIfcFaceSurface() {
    return m_refIfcFaceSurfaceList;
}

Step::RefLinkedList< IfcFacetedBrep > &ExpressDataSet::getAllIfcFacetedBrep() {
    return m_refIfcFacetedBrepList;
}

Step::RefLinkedList< IfcFacetedBrepWithVoids > &ExpressDataSet::getAllIfcFacetedBrepWithVoids() {
    return m_refIfcFacetedBrepWithVoidsList;
}

Step::RefLinkedList< IfcFailureConnectionCondition > &ExpressDataSet::getAllIfcFailureConnectionCondition() {
    return m_refIfcFailureConnectionConditionList;
}

Step::RefLinkedList< IfcFanType > &ExpressDataSet::getAllIfcFanType() {
    return m_refIfcFanTypeList;
}

Step::RefLinkedList< IfcFastener > &ExpressDataSet::getAllIfcFastener() {
    return m_refIfcFastenerList;
}

Step::RefLinkedList< IfcFastenerType > &ExpressDataSet::getAllIfcFastenerType() {
    return m_refIfcFastenerTypeList;
}

Step::RefLinkedList< IfcFeatureElement > &ExpressDataSet::getAllIfcFeatureElement() {
    return m_refIfcFeatureElementList;
}

Step::RefLinkedList< IfcFeatureElementAddition > &ExpressDataSet::getAllIfcFeatureElementAddition() {
    return m_refIfcFeatureElementAdditionList;
}

Step::RefLinkedList< IfcFeatureElementSubtraction > &ExpressDataSet::getAllIfcFeatureElementSubtraction() {
    return m_refIfcFeatureElementSubtractionList;
}

Step::RefLinkedList< IfcFillAreaStyle > &ExpressDataSet::getAllIfcFillAreaStyle() {
    return m_refIfcFillAreaStyleList;
}

Step::RefLinkedList< IfcFillAreaStyleHatching > &ExpressDataSet::getAllIfcFillAreaStyleHatching() {
    return m_refIfcFillAreaStyleHatchingList;
}

Step::RefLinkedList< IfcFillAreaStyleTileSymbolWithStyle > &ExpressDataSet::getAllIfcFillAreaStyleTileSymbolWithStyle() {
    return m_refIfcFillAreaStyleTileSymbolWithStyleList;
}

Step::RefLinkedList< IfcFillAreaStyleTiles > &ExpressDataSet::getAllIfcFillAreaStyleTiles() {
    return m_refIfcFillAreaStyleTilesList;
}

Step::RefLinkedList< IfcFilterType > &ExpressDataSet::getAllIfcFilterType() {
    return m_refIfcFilterTypeList;
}

Step::RefLinkedList< IfcFireSuppressionTerminalType > &ExpressDataSet::getAllIfcFireSuppressionTerminalType() {
    return m_refIfcFireSuppressionTerminalTypeList;
}

Step::RefLinkedList< IfcFlowController > &ExpressDataSet::getAllIfcFlowController() {
    return m_refIfcFlowControllerList;
}

Step::RefLinkedList< IfcFlowControllerType > &ExpressDataSet::getAllIfcFlowControllerType() {
    return m_refIfcFlowControllerTypeList;
}

Step::RefLinkedList< IfcFlowFitting > &ExpressDataSet::getAllIfcFlowFitting() {
    return m_refIfcFlowFittingList;
}

Step::RefLinkedList< IfcFlowFittingType > &ExpressDataSet::getAllIfcFlowFittingType() {
    return m_refIfcFlowFittingTypeList;
}

Step::RefLinkedList< IfcFlowInstrumentType > &ExpressDataSet::getAllIfcFlowInstrumentType() {
    return m_refIfcFlowInstrumentTypeList;
}

Step::RefLinkedList< IfcFlowMeterType > &ExpressDataSet::getAllIfcFlowMeterType() {
    return m_refIfcFlowMeterTypeList;
}

Step::RefLinkedList< IfcFlowMovingDevice > &ExpressDataSet::getAllIfcFlowMovingDevice() {
    return m_refIfcFlowMovingDeviceList;
}

Step::RefLinkedList< IfcFlowMovingDeviceType > &ExpressDataSet::getAllIfcFlowMovingDeviceType() {
    return m_refIfcFlowMovingDeviceTypeList;
}

Step::RefLinkedList< IfcFlowSegment > &ExpressDataSet::getAllIfcFlowSegment() {
    return m_refIfcFlowSegmentList;
}

Step::RefLinkedList< IfcFlowSegmentType > &ExpressDataSet::getAllIfcFlowSegmentType() {
    return m_refIfcFlowSegmentTypeList;
}

Step::RefLinkedList< IfcFlowStorageDevice > &ExpressDataSet::getAllIfcFlowStorageDevice() {
    return m_refIfcFlowStorageDeviceList;
}

Step::RefLinkedList< IfcFlowStorageDeviceType > &ExpressDataSet::getAllIfcFlowStorageDeviceType() {
    return m_refIfcFlowStorageDeviceTypeList;
}

Step::RefLinkedList< IfcFlowTerminal > &ExpressDataSet::getAllIfcFlowTerminal() {
    return m_refIfcFlowTerminalList;
}

Step::RefLinkedList< IfcFlowTerminalType > &ExpressDataSet::getAllIfcFlowTerminalType() {
    return m_refIfcFlowTerminalTypeList;
}

Step::RefLinkedList< IfcFlowTreatmentDevice > &ExpressDataSet::getAllIfcFlowTreatmentDevice() {
    return m_refIfcFlowTreatmentDeviceList;
}

Step::RefLinkedList< IfcFlowTreatmentDeviceType > &ExpressDataSet::getAllIfcFlowTreatmentDeviceType() {
    return m_refIfcFlowTreatmentDeviceTypeList;
}

Step::RefLinkedList< IfcFluidFlowProperties > &ExpressDataSet::getAllIfcFluidFlowProperties() {
    return m_refIfcFluidFlowPropertiesList;
}

Step::RefLinkedList< IfcFooting > &ExpressDataSet::getAllIfcFooting() {
    return m_refIfcFootingList;
}

Step::RefLinkedList< IfcFuelProperties > &ExpressDataSet::getAllIfcFuelProperties() {
    return m_refIfcFuelPropertiesList;
}

Step::RefLinkedList< IfcFurnishingElement > &ExpressDataSet::getAllIfcFurnishingElement() {
    return m_refIfcFurnishingElementList;
}

Step::RefLinkedList< IfcFurnishingElementType > &ExpressDataSet::getAllIfcFurnishingElementType() {
    return m_refIfcFurnishingElementTypeList;
}

Step::RefLinkedList< IfcFurnitureStandard > &ExpressDataSet::getAllIfcFurnitureStandard() {
    return m_refIfcFurnitureStandardList;
}

Step::RefLinkedList< IfcFurnitureType > &ExpressDataSet::getAllIfcFurnitureType() {
    return m_refIfcFurnitureTypeList;
}

Step::RefLinkedList< IfcGasTerminalType > &ExpressDataSet::getAllIfcGasTerminalType() {
    return m_refIfcGasTerminalTypeList;
}

Step::RefLinkedList< IfcGeneralMaterialProperties > &ExpressDataSet::getAllIfcGeneralMaterialProperties() {
    return m_refIfcGeneralMaterialPropertiesList;
}

Step::RefLinkedList< IfcGeneralProfileProperties > &ExpressDataSet::getAllIfcGeneralProfileProperties() {
    return m_refIfcGeneralProfilePropertiesList;
}

Step::RefLinkedList< IfcGeometricCurveSet > &ExpressDataSet::getAllIfcGeometricCurveSet() {
    return m_refIfcGeometricCurveSetList;
}

Step::RefLinkedList< IfcGeometricRepresentationContext > &ExpressDataSet::getAllIfcGeometricRepresentationContext() {
    return m_refIfcGeometricRepresentationContextList;
}

Step::RefLinkedList< IfcGeometricRepresentationItem > &ExpressDataSet::getAllIfcGeometricRepresentationItem() {
    return m_refIfcGeometricRepresentationItemList;
}

Step::RefLinkedList< IfcGeometricRepresentationSubContext > &ExpressDataSet::getAllIfcGeometricRepresentationSubContext() {
    return m_refIfcGeometricRepresentationSubContextList;
}

Step::RefLinkedList< IfcGeometricSet > &ExpressDataSet::getAllIfcGeometricSet() {
    return m_refIfcGeometricSetList;
}

Step::RefLinkedList< IfcGrid > &ExpressDataSet::getAllIfcGrid() {
    return m_refIfcGridList;
}

Step::RefLinkedList< IfcGridAxis > &ExpressDataSet::getAllIfcGridAxis() {
    return m_refIfcGridAxisList;
}

Step::RefLinkedList< IfcGridPlacement > &ExpressDataSet::getAllIfcGridPlacement() {
    return m_refIfcGridPlacementList;
}

Step::RefLinkedList< IfcGroup > &ExpressDataSet::getAllIfcGroup() {
    return m_refIfcGroupList;
}

Step::RefLinkedList< IfcHalfSpaceSolid > &ExpressDataSet::getAllIfcHalfSpaceSolid() {
    return m_refIfcHalfSpaceSolidList;
}

Step::RefLinkedList< IfcHeatExchangerType > &ExpressDataSet::getAllIfcHeatExchangerType() {
    return m_refIfcHeatExchangerTypeList;
}

Step::RefLinkedList< IfcHumidifierType > &ExpressDataSet::getAllIfcHumidifierType() {
    return m_refIfcHumidifierTypeList;
}

Step::RefLinkedList< IfcHygroscopicMaterialProperties > &ExpressDataSet::getAllIfcHygroscopicMaterialProperties() {
    return m_refIfcHygroscopicMaterialPropertiesList;
}

Step::RefLinkedList< IfcIShapeProfileDef > &ExpressDataSet::getAllIfcIShapeProfileDef() {
    return m_refIfcIShapeProfileDefList;
}

Step::RefLinkedList< IfcImageTexture > &ExpressDataSet::getAllIfcImageTexture() {
    return m_refIfcImageTextureList;
}

Step::RefLinkedList< IfcInventory > &ExpressDataSet::getAllIfcInventory() {
    return m_refIfcInventoryList;
}

Step::RefLinkedList< IfcIrregularTimeSeries > &ExpressDataSet::getAllIfcIrregularTimeSeries() {
    return m_refIfcIrregularTimeSeriesList;
}

Step::RefLinkedList< IfcIrregularTimeSeriesValue > &ExpressDataSet::getAllIfcIrregularTimeSeriesValue() {
    return m_refIfcIrregularTimeSeriesValueList;
}

Step::RefLinkedList< IfcJunctionBoxType > &ExpressDataSet::getAllIfcJunctionBoxType() {
    return m_refIfcJunctionBoxTypeList;
}

Step::RefLinkedList< IfcLShapeProfileDef > &ExpressDataSet::getAllIfcLShapeProfileDef() {
    return m_refIfcLShapeProfileDefList;
}

Step::RefLinkedList< IfcLaborResource > &ExpressDataSet::getAllIfcLaborResource() {
    return m_refIfcLaborResourceList;
}

Step::RefLinkedList< IfcLampType > &ExpressDataSet::getAllIfcLampType() {
    return m_refIfcLampTypeList;
}

Step::RefLinkedList< IfcLibraryInformation > &ExpressDataSet::getAllIfcLibraryInformation() {
    return m_refIfcLibraryInformationList;
}

Step::RefLinkedList< IfcLibraryReference > &ExpressDataSet::getAllIfcLibraryReference() {
    return m_refIfcLibraryReferenceList;
}

Step::RefLinkedList< IfcLightDistributionData > &ExpressDataSet::getAllIfcLightDistributionData() {
    return m_refIfcLightDistributionDataList;
}

Step::RefLinkedList< IfcLightFixtureType > &ExpressDataSet::getAllIfcLightFixtureType() {
    return m_refIfcLightFixtureTypeList;
}

Step::RefLinkedList< IfcLightIntensityDistribution > &ExpressDataSet::getAllIfcLightIntensityDistribution() {
    return m_refIfcLightIntensityDistributionList;
}

Step::RefLinkedList< IfcLightSource > &ExpressDataSet::getAllIfcLightSource() {
    return m_refIfcLightSourceList;
}

Step::RefLinkedList< IfcLightSourceAmbient > &ExpressDataSet::getAllIfcLightSourceAmbient() {
    return m_refIfcLightSourceAmbientList;
}

Step::RefLinkedList< IfcLightSourceDirectional > &ExpressDataSet::getAllIfcLightSourceDirectional() {
    return m_refIfcLightSourceDirectionalList;
}

Step::RefLinkedList< IfcLightSourceGoniometric > &ExpressDataSet::getAllIfcLightSourceGoniometric() {
    return m_refIfcLightSourceGoniometricList;
}

Step::RefLinkedList< IfcLightSourcePositional > &ExpressDataSet::getAllIfcLightSourcePositional() {
    return m_refIfcLightSourcePositionalList;
}

Step::RefLinkedList< IfcLightSourceSpot > &ExpressDataSet::getAllIfcLightSourceSpot() {
    return m_refIfcLightSourceSpotList;
}

Step::RefLinkedList< IfcLine > &ExpressDataSet::getAllIfcLine() {
    return m_refIfcLineList;
}

Step::RefLinkedList< IfcLinearDimension > &ExpressDataSet::getAllIfcLinearDimension() {
    return m_refIfcLinearDimensionList;
}

Step::RefLinkedList< IfcLocalPlacement > &ExpressDataSet::getAllIfcLocalPlacement() {
    return m_refIfcLocalPlacementList;
}

Step::RefLinkedList< IfcLocalTime > &ExpressDataSet::getAllIfcLocalTime() {
    return m_refIfcLocalTimeList;
}

Step::RefLinkedList< IfcLoop > &ExpressDataSet::getAllIfcLoop() {
    return m_refIfcLoopList;
}

Step::RefLinkedList< IfcManifoldSolidBrep > &ExpressDataSet::getAllIfcManifoldSolidBrep() {
    return m_refIfcManifoldSolidBrepList;
}

Step::RefLinkedList< IfcMappedItem > &ExpressDataSet::getAllIfcMappedItem() {
    return m_refIfcMappedItemList;
}

Step::RefLinkedList< IfcMaterial > &ExpressDataSet::getAllIfcMaterial() {
    return m_refIfcMaterialList;
}

Step::RefLinkedList< IfcMaterialClassificationRelationship > &ExpressDataSet::getAllIfcMaterialClassificationRelationship() {
    return m_refIfcMaterialClassificationRelationshipList;
}

Step::RefLinkedList< IfcMaterialDefinitionRepresentation > &ExpressDataSet::getAllIfcMaterialDefinitionRepresentation() {
    return m_refIfcMaterialDefinitionRepresentationList;
}

Step::RefLinkedList< IfcMaterialLayer > &ExpressDataSet::getAllIfcMaterialLayer() {
    return m_refIfcMaterialLayerList;
}

Step::RefLinkedList< IfcMaterialLayerSet > &ExpressDataSet::getAllIfcMaterialLayerSet() {
    return m_refIfcMaterialLayerSetList;
}

Step::RefLinkedList< IfcMaterialLayerSetUsage > &ExpressDataSet::getAllIfcMaterialLayerSetUsage() {
    return m_refIfcMaterialLayerSetUsageList;
}

Step::RefLinkedList< IfcMaterialList > &ExpressDataSet::getAllIfcMaterialList() {
    return m_refIfcMaterialListList;
}

Step::RefLinkedList< IfcMaterialProperties > &ExpressDataSet::getAllIfcMaterialProperties() {
    return m_refIfcMaterialPropertiesList;
}

Step::RefLinkedList< IfcMeasureWithUnit > &ExpressDataSet::getAllIfcMeasureWithUnit() {
    return m_refIfcMeasureWithUnitList;
}

Step::RefLinkedList< IfcMechanicalConcreteMaterialProperties > &ExpressDataSet::getAllIfcMechanicalConcreteMaterialProperties() {
    return m_refIfcMechanicalConcreteMaterialPropertiesList;
}

Step::RefLinkedList< IfcMechanicalFastener > &ExpressDataSet::getAllIfcMechanicalFastener() {
    return m_refIfcMechanicalFastenerList;
}

Step::RefLinkedList< IfcMechanicalFastenerType > &ExpressDataSet::getAllIfcMechanicalFastenerType() {
    return m_refIfcMechanicalFastenerTypeList;
}

Step::RefLinkedList< IfcMechanicalMaterialProperties > &ExpressDataSet::getAllIfcMechanicalMaterialProperties() {
    return m_refIfcMechanicalMaterialPropertiesList;
}

Step::RefLinkedList< IfcMechanicalSteelMaterialProperties > &ExpressDataSet::getAllIfcMechanicalSteelMaterialProperties() {
    return m_refIfcMechanicalSteelMaterialPropertiesList;
}

Step::RefLinkedList< IfcMember > &ExpressDataSet::getAllIfcMember() {
    return m_refIfcMemberList;
}

Step::RefLinkedList< IfcMemberType > &ExpressDataSet::getAllIfcMemberType() {
    return m_refIfcMemberTypeList;
}

Step::RefLinkedList< IfcMetric > &ExpressDataSet::getAllIfcMetric() {
    return m_refIfcMetricList;
}

Step::RefLinkedList< IfcMonetaryUnit > &ExpressDataSet::getAllIfcMonetaryUnit() {
    return m_refIfcMonetaryUnitList;
}

Step::RefLinkedList< IfcMotorConnectionType > &ExpressDataSet::getAllIfcMotorConnectionType() {
    return m_refIfcMotorConnectionTypeList;
}

Step::RefLinkedList< IfcMove > &ExpressDataSet::getAllIfcMove() {
    return m_refIfcMoveList;
}

Step::RefLinkedList< IfcNamedUnit > &ExpressDataSet::getAllIfcNamedUnit() {
    return m_refIfcNamedUnitList;
}

Step::RefLinkedList< IfcObject > &ExpressDataSet::getAllIfcObject() {
    return m_refIfcObjectList;
}

Step::RefLinkedList< IfcObjectDefinition > &ExpressDataSet::getAllIfcObjectDefinition() {
    return m_refIfcObjectDefinitionList;
}

Step::RefLinkedList< IfcObjectPlacement > &ExpressDataSet::getAllIfcObjectPlacement() {
    return m_refIfcObjectPlacementList;
}

Step::RefLinkedList< IfcObjective > &ExpressDataSet::getAllIfcObjective() {
    return m_refIfcObjectiveList;
}

Step::RefLinkedList< IfcOccupant > &ExpressDataSet::getAllIfcOccupant() {
    return m_refIfcOccupantList;
}

Step::RefLinkedList< IfcOffsetCurve2D > &ExpressDataSet::getAllIfcOffsetCurve2D() {
    return m_refIfcOffsetCurve2DList;
}

Step::RefLinkedList< IfcOffsetCurve3D > &ExpressDataSet::getAllIfcOffsetCurve3D() {
    return m_refIfcOffsetCurve3DList;
}

Step::RefLinkedList< IfcOneDirectionRepeatFactor > &ExpressDataSet::getAllIfcOneDirectionRepeatFactor() {
    return m_refIfcOneDirectionRepeatFactorList;
}

Step::RefLinkedList< IfcOpenShell > &ExpressDataSet::getAllIfcOpenShell() {
    return m_refIfcOpenShellList;
}

Step::RefLinkedList< IfcOpeningElement > &ExpressDataSet::getAllIfcOpeningElement() {
    return m_refIfcOpeningElementList;
}

Step::RefLinkedList< IfcOpticalMaterialProperties > &ExpressDataSet::getAllIfcOpticalMaterialProperties() {
    return m_refIfcOpticalMaterialPropertiesList;
}

Step::RefLinkedList< IfcOrderAction > &ExpressDataSet::getAllIfcOrderAction() {
    return m_refIfcOrderActionList;
}

Step::RefLinkedList< IfcOrganization > &ExpressDataSet::getAllIfcOrganization() {
    return m_refIfcOrganizationList;
}

Step::RefLinkedList< IfcOrganizationRelationship > &ExpressDataSet::getAllIfcOrganizationRelationship() {
    return m_refIfcOrganizationRelationshipList;
}

Step::RefLinkedList< IfcOrientedEdge > &ExpressDataSet::getAllIfcOrientedEdge() {
    return m_refIfcOrientedEdgeList;
}

Step::RefLinkedList< IfcOutletType > &ExpressDataSet::getAllIfcOutletType() {
    return m_refIfcOutletTypeList;
}

Step::RefLinkedList< IfcOwnerHistory > &ExpressDataSet::getAllIfcOwnerHistory() {
    return m_refIfcOwnerHistoryList;
}

Step::RefLinkedList< IfcParameterizedProfileDef > &ExpressDataSet::getAllIfcParameterizedProfileDef() {
    return m_refIfcParameterizedProfileDefList;
}

Step::RefLinkedList< IfcPath > &ExpressDataSet::getAllIfcPath() {
    return m_refIfcPathList;
}

Step::RefLinkedList< IfcPerformanceHistory > &ExpressDataSet::getAllIfcPerformanceHistory() {
    return m_refIfcPerformanceHistoryList;
}

Step::RefLinkedList< IfcPermeableCoveringProperties > &ExpressDataSet::getAllIfcPermeableCoveringProperties() {
    return m_refIfcPermeableCoveringPropertiesList;
}

Step::RefLinkedList< IfcPermit > &ExpressDataSet::getAllIfcPermit() {
    return m_refIfcPermitList;
}

Step::RefLinkedList< IfcPerson > &ExpressDataSet::getAllIfcPerson() {
    return m_refIfcPersonList;
}

Step::RefLinkedList< IfcPersonAndOrganization > &ExpressDataSet::getAllIfcPersonAndOrganization() {
    return m_refIfcPersonAndOrganizationList;
}

Step::RefLinkedList< IfcPhysicalComplexQuantity > &ExpressDataSet::getAllIfcPhysicalComplexQuantity() {
    return m_refIfcPhysicalComplexQuantityList;
}

Step::RefLinkedList< IfcPhysicalQuantity > &ExpressDataSet::getAllIfcPhysicalQuantity() {
    return m_refIfcPhysicalQuantityList;
}

Step::RefLinkedList< IfcPhysicalSimpleQuantity > &ExpressDataSet::getAllIfcPhysicalSimpleQuantity() {
    return m_refIfcPhysicalSimpleQuantityList;
}

Step::RefLinkedList< IfcPile > &ExpressDataSet::getAllIfcPile() {
    return m_refIfcPileList;
}

Step::RefLinkedList< IfcPipeFittingType > &ExpressDataSet::getAllIfcPipeFittingType() {
    return m_refIfcPipeFittingTypeList;
}

Step::RefLinkedList< IfcPipeSegmentType > &ExpressDataSet::getAllIfcPipeSegmentType() {
    return m_refIfcPipeSegmentTypeList;
}

Step::RefLinkedList< IfcPixelTexture > &ExpressDataSet::getAllIfcPixelTexture() {
    return m_refIfcPixelTextureList;
}

Step::RefLinkedList< IfcPlacement > &ExpressDataSet::getAllIfcPlacement() {
    return m_refIfcPlacementList;
}

Step::RefLinkedList< IfcPlanarBox > &ExpressDataSet::getAllIfcPlanarBox() {
    return m_refIfcPlanarBoxList;
}

Step::RefLinkedList< IfcPlanarExtent > &ExpressDataSet::getAllIfcPlanarExtent() {
    return m_refIfcPlanarExtentList;
}

Step::RefLinkedList< IfcPlane > &ExpressDataSet::getAllIfcPlane() {
    return m_refIfcPlaneList;
}

Step::RefLinkedList< IfcPlate > &ExpressDataSet::getAllIfcPlate() {
    return m_refIfcPlateList;
}

Step::RefLinkedList< IfcPlateType > &ExpressDataSet::getAllIfcPlateType() {
    return m_refIfcPlateTypeList;
}

Step::RefLinkedList< IfcPoint > &ExpressDataSet::getAllIfcPoint() {
    return m_refIfcPointList;
}

Step::RefLinkedList< IfcPointOnCurve > &ExpressDataSet::getAllIfcPointOnCurve() {
    return m_refIfcPointOnCurveList;
}

Step::RefLinkedList< IfcPointOnSurface > &ExpressDataSet::getAllIfcPointOnSurface() {
    return m_refIfcPointOnSurfaceList;
}

Step::RefLinkedList< IfcPolyLoop > &ExpressDataSet::getAllIfcPolyLoop() {
    return m_refIfcPolyLoopList;
}

Step::RefLinkedList< IfcPolygonalBoundedHalfSpace > &ExpressDataSet::getAllIfcPolygonalBoundedHalfSpace() {
    return m_refIfcPolygonalBoundedHalfSpaceList;
}

Step::RefLinkedList< IfcPolyline > &ExpressDataSet::getAllIfcPolyline() {
    return m_refIfcPolylineList;
}

Step::RefLinkedList< IfcPort > &ExpressDataSet::getAllIfcPort() {
    return m_refIfcPortList;
}

Step::RefLinkedList< IfcPostalAddress > &ExpressDataSet::getAllIfcPostalAddress() {
    return m_refIfcPostalAddressList;
}

Step::RefLinkedList< IfcPreDefinedColour > &ExpressDataSet::getAllIfcPreDefinedColour() {
    return m_refIfcPreDefinedColourList;
}

Step::RefLinkedList< IfcPreDefinedCurveFont > &ExpressDataSet::getAllIfcPreDefinedCurveFont() {
    return m_refIfcPreDefinedCurveFontList;
}

Step::RefLinkedList< IfcPreDefinedDimensionSymbol > &ExpressDataSet::getAllIfcPreDefinedDimensionSymbol() {
    return m_refIfcPreDefinedDimensionSymbolList;
}

Step::RefLinkedList< IfcPreDefinedItem > &ExpressDataSet::getAllIfcPreDefinedItem() {
    return m_refIfcPreDefinedItemList;
}

Step::RefLinkedList< IfcPreDefinedPointMarkerSymbol > &ExpressDataSet::getAllIfcPreDefinedPointMarkerSymbol() {
    return m_refIfcPreDefinedPointMarkerSymbolList;
}

Step::RefLinkedList< IfcPreDefinedSymbol > &ExpressDataSet::getAllIfcPreDefinedSymbol() {
    return m_refIfcPreDefinedSymbolList;
}

Step::RefLinkedList< IfcPreDefinedTerminatorSymbol > &ExpressDataSet::getAllIfcPreDefinedTerminatorSymbol() {
    return m_refIfcPreDefinedTerminatorSymbolList;
}

Step::RefLinkedList< IfcPreDefinedTextFont > &ExpressDataSet::getAllIfcPreDefinedTextFont() {
    return m_refIfcPreDefinedTextFontList;
}

Step::RefLinkedList< IfcPresentationLayerAssignment > &ExpressDataSet::getAllIfcPresentationLayerAssignment() {
    return m_refIfcPresentationLayerAssignmentList;
}

Step::RefLinkedList< IfcPresentationLayerWithStyle > &ExpressDataSet::getAllIfcPresentationLayerWithStyle() {
    return m_refIfcPresentationLayerWithStyleList;
}

Step::RefLinkedList< IfcPresentationStyle > &ExpressDataSet::getAllIfcPresentationStyle() {
    return m_refIfcPresentationStyleList;
}

Step::RefLinkedList< IfcPresentationStyleAssignment > &ExpressDataSet::getAllIfcPresentationStyleAssignment() {
    return m_refIfcPresentationStyleAssignmentList;
}

Step::RefLinkedList< IfcProcedure > &ExpressDataSet::getAllIfcProcedure() {
    return m_refIfcProcedureList;
}

Step::RefLinkedList< IfcProcess > &ExpressDataSet::getAllIfcProcess() {
    return m_refIfcProcessList;
}

Step::RefLinkedList< IfcProduct > &ExpressDataSet::getAllIfcProduct() {
    return m_refIfcProductList;
}

Step::RefLinkedList< IfcProductDefinitionShape > &ExpressDataSet::getAllIfcProductDefinitionShape() {
    return m_refIfcProductDefinitionShapeList;
}

Step::RefLinkedList< IfcProductRepresentation > &ExpressDataSet::getAllIfcProductRepresentation() {
    return m_refIfcProductRepresentationList;
}

Step::RefLinkedList< IfcProductsOfCombustionProperties > &ExpressDataSet::getAllIfcProductsOfCombustionProperties() {
    return m_refIfcProductsOfCombustionPropertiesList;
}

Step::RefLinkedList< IfcProfileDef > &ExpressDataSet::getAllIfcProfileDef() {
    return m_refIfcProfileDefList;
}

Step::RefLinkedList< IfcProfileProperties > &ExpressDataSet::getAllIfcProfileProperties() {
    return m_refIfcProfilePropertiesList;
}

Step::RefLinkedList< IfcProject > &ExpressDataSet::getAllIfcProject() {
    return m_refIfcProjectList;
}

Step::RefLinkedList< IfcProjectOrder > &ExpressDataSet::getAllIfcProjectOrder() {
    return m_refIfcProjectOrderList;
}

Step::RefLinkedList< IfcProjectOrderRecord > &ExpressDataSet::getAllIfcProjectOrderRecord() {
    return m_refIfcProjectOrderRecordList;
}

Step::RefLinkedList< IfcProjectionCurve > &ExpressDataSet::getAllIfcProjectionCurve() {
    return m_refIfcProjectionCurveList;
}

Step::RefLinkedList< IfcProjectionElement > &ExpressDataSet::getAllIfcProjectionElement() {
    return m_refIfcProjectionElementList;
}

Step::RefLinkedList< IfcProperty > &ExpressDataSet::getAllIfcProperty() {
    return m_refIfcPropertyList;
}

Step::RefLinkedList< IfcPropertyBoundedValue > &ExpressDataSet::getAllIfcPropertyBoundedValue() {
    return m_refIfcPropertyBoundedValueList;
}

Step::RefLinkedList< IfcPropertyConstraintRelationship > &ExpressDataSet::getAllIfcPropertyConstraintRelationship() {
    return m_refIfcPropertyConstraintRelationshipList;
}

Step::RefLinkedList< IfcPropertyDefinition > &ExpressDataSet::getAllIfcPropertyDefinition() {
    return m_refIfcPropertyDefinitionList;
}

Step::RefLinkedList< IfcPropertyDependencyRelationship > &ExpressDataSet::getAllIfcPropertyDependencyRelationship() {
    return m_refIfcPropertyDependencyRelationshipList;
}

Step::RefLinkedList< IfcPropertyEnumeratedValue > &ExpressDataSet::getAllIfcPropertyEnumeratedValue() {
    return m_refIfcPropertyEnumeratedValueList;
}

Step::RefLinkedList< IfcPropertyEnumeration > &ExpressDataSet::getAllIfcPropertyEnumeration() {
    return m_refIfcPropertyEnumerationList;
}

Step::RefLinkedList< IfcPropertyListValue > &ExpressDataSet::getAllIfcPropertyListValue() {
    return m_refIfcPropertyListValueList;
}

Step::RefLinkedList< IfcPropertyReferenceValue > &ExpressDataSet::getAllIfcPropertyReferenceValue() {
    return m_refIfcPropertyReferenceValueList;
}

Step::RefLinkedList< IfcPropertySet > &ExpressDataSet::getAllIfcPropertySet() {
    return m_refIfcPropertySetList;
}

Step::RefLinkedList< IfcPropertySetDefinition > &ExpressDataSet::getAllIfcPropertySetDefinition() {
    return m_refIfcPropertySetDefinitionList;
}

Step::RefLinkedList< IfcPropertySingleValue > &ExpressDataSet::getAllIfcPropertySingleValue() {
    return m_refIfcPropertySingleValueList;
}

Step::RefLinkedList< IfcPropertyTableValue > &ExpressDataSet::getAllIfcPropertyTableValue() {
    return m_refIfcPropertyTableValueList;
}

Step::RefLinkedList< IfcProtectiveDeviceType > &ExpressDataSet::getAllIfcProtectiveDeviceType() {
    return m_refIfcProtectiveDeviceTypeList;
}

Step::RefLinkedList< IfcProxy > &ExpressDataSet::getAllIfcProxy() {
    return m_refIfcProxyList;
}

Step::RefLinkedList< IfcPumpType > &ExpressDataSet::getAllIfcPumpType() {
    return m_refIfcPumpTypeList;
}

Step::RefLinkedList< IfcQuantityArea > &ExpressDataSet::getAllIfcQuantityArea() {
    return m_refIfcQuantityAreaList;
}

Step::RefLinkedList< IfcQuantityCount > &ExpressDataSet::getAllIfcQuantityCount() {
    return m_refIfcQuantityCountList;
}

Step::RefLinkedList< IfcQuantityLength > &ExpressDataSet::getAllIfcQuantityLength() {
    return m_refIfcQuantityLengthList;
}

Step::RefLinkedList< IfcQuantityTime > &ExpressDataSet::getAllIfcQuantityTime() {
    return m_refIfcQuantityTimeList;
}

Step::RefLinkedList< IfcQuantityVolume > &ExpressDataSet::getAllIfcQuantityVolume() {
    return m_refIfcQuantityVolumeList;
}

Step::RefLinkedList< IfcQuantityWeight > &ExpressDataSet::getAllIfcQuantityWeight() {
    return m_refIfcQuantityWeightList;
}

Step::RefLinkedList< IfcRadiusDimension > &ExpressDataSet::getAllIfcRadiusDimension() {
    return m_refIfcRadiusDimensionList;
}

Step::RefLinkedList< IfcRailing > &ExpressDataSet::getAllIfcRailing() {
    return m_refIfcRailingList;
}

Step::RefLinkedList< IfcRailingType > &ExpressDataSet::getAllIfcRailingType() {
    return m_refIfcRailingTypeList;
}

Step::RefLinkedList< IfcRamp > &ExpressDataSet::getAllIfcRamp() {
    return m_refIfcRampList;
}

Step::RefLinkedList< IfcRampFlight > &ExpressDataSet::getAllIfcRampFlight() {
    return m_refIfcRampFlightList;
}

Step::RefLinkedList< IfcRampFlightType > &ExpressDataSet::getAllIfcRampFlightType() {
    return m_refIfcRampFlightTypeList;
}

Step::RefLinkedList< IfcRationalBezierCurve > &ExpressDataSet::getAllIfcRationalBezierCurve() {
    return m_refIfcRationalBezierCurveList;
}

Step::RefLinkedList< IfcRectangleHollowProfileDef > &ExpressDataSet::getAllIfcRectangleHollowProfileDef() {
    return m_refIfcRectangleHollowProfileDefList;
}

Step::RefLinkedList< IfcRectangleProfileDef > &ExpressDataSet::getAllIfcRectangleProfileDef() {
    return m_refIfcRectangleProfileDefList;
}

Step::RefLinkedList< IfcRectangularPyramid > &ExpressDataSet::getAllIfcRectangularPyramid() {
    return m_refIfcRectangularPyramidList;
}

Step::RefLinkedList< IfcRectangularTrimmedSurface > &ExpressDataSet::getAllIfcRectangularTrimmedSurface() {
    return m_refIfcRectangularTrimmedSurfaceList;
}

Step::RefLinkedList< IfcReferencesValueDocument > &ExpressDataSet::getAllIfcReferencesValueDocument() {
    return m_refIfcReferencesValueDocumentList;
}

Step::RefLinkedList< IfcRegularTimeSeries > &ExpressDataSet::getAllIfcRegularTimeSeries() {
    return m_refIfcRegularTimeSeriesList;
}

Step::RefLinkedList< IfcReinforcementBarProperties > &ExpressDataSet::getAllIfcReinforcementBarProperties() {
    return m_refIfcReinforcementBarPropertiesList;
}

Step::RefLinkedList< IfcReinforcementDefinitionProperties > &ExpressDataSet::getAllIfcReinforcementDefinitionProperties() {
    return m_refIfcReinforcementDefinitionPropertiesList;
}

Step::RefLinkedList< IfcReinforcingBar > &ExpressDataSet::getAllIfcReinforcingBar() {
    return m_refIfcReinforcingBarList;
}

Step::RefLinkedList< IfcReinforcingElement > &ExpressDataSet::getAllIfcReinforcingElement() {
    return m_refIfcReinforcingElementList;
}

Step::RefLinkedList< IfcReinforcingMesh > &ExpressDataSet::getAllIfcReinforcingMesh() {
    return m_refIfcReinforcingMeshList;
}

Step::RefLinkedList< IfcRelAggregates > &ExpressDataSet::getAllIfcRelAggregates() {
    return m_refIfcRelAggregatesList;
}

Step::RefLinkedList< IfcRelAssigns > &ExpressDataSet::getAllIfcRelAssigns() {
    return m_refIfcRelAssignsList;
}

Step::RefLinkedList< IfcRelAssignsTasks > &ExpressDataSet::getAllIfcRelAssignsTasks() {
    return m_refIfcRelAssignsTasksList;
}

Step::RefLinkedList< IfcRelAssignsToActor > &ExpressDataSet::getAllIfcRelAssignsToActor() {
    return m_refIfcRelAssignsToActorList;
}

Step::RefLinkedList< IfcRelAssignsToControl > &ExpressDataSet::getAllIfcRelAssignsToControl() {
    return m_refIfcRelAssignsToControlList;
}

Step::RefLinkedList< IfcRelAssignsToGroup > &ExpressDataSet::getAllIfcRelAssignsToGroup() {
    return m_refIfcRelAssignsToGroupList;
}

Step::RefLinkedList< IfcRelAssignsToProcess > &ExpressDataSet::getAllIfcRelAssignsToProcess() {
    return m_refIfcRelAssignsToProcessList;
}

Step::RefLinkedList< IfcRelAssignsToProduct > &ExpressDataSet::getAllIfcRelAssignsToProduct() {
    return m_refIfcRelAssignsToProductList;
}

Step::RefLinkedList< IfcRelAssignsToProjectOrder > &ExpressDataSet::getAllIfcRelAssignsToProjectOrder() {
    return m_refIfcRelAssignsToProjectOrderList;
}

Step::RefLinkedList< IfcRelAssignsToResource > &ExpressDataSet::getAllIfcRelAssignsToResource() {
    return m_refIfcRelAssignsToResourceList;
}

Step::RefLinkedList< IfcRelAssociates > &ExpressDataSet::getAllIfcRelAssociates() {
    return m_refIfcRelAssociatesList;
}

Step::RefLinkedList< IfcRelAssociatesAppliedValue > &ExpressDataSet::getAllIfcRelAssociatesAppliedValue() {
    return m_refIfcRelAssociatesAppliedValueList;
}

Step::RefLinkedList< IfcRelAssociatesApproval > &ExpressDataSet::getAllIfcRelAssociatesApproval() {
    return m_refIfcRelAssociatesApprovalList;
}

Step::RefLinkedList< IfcRelAssociatesClassification > &ExpressDataSet::getAllIfcRelAssociatesClassification() {
    return m_refIfcRelAssociatesClassificationList;
}

Step::RefLinkedList< IfcRelAssociatesConstraint > &ExpressDataSet::getAllIfcRelAssociatesConstraint() {
    return m_refIfcRelAssociatesConstraintList;
}

Step::RefLinkedList< IfcRelAssociatesDocument > &ExpressDataSet::getAllIfcRelAssociatesDocument() {
    return m_refIfcRelAssociatesDocumentList;
}

Step::RefLinkedList< IfcRelAssociatesLibrary > &ExpressDataSet::getAllIfcRelAssociatesLibrary() {
    return m_refIfcRelAssociatesLibraryList;
}

Step::RefLinkedList< IfcRelAssociatesMaterial > &ExpressDataSet::getAllIfcRelAssociatesMaterial() {
    return m_refIfcRelAssociatesMaterialList;
}

Step::RefLinkedList< IfcRelAssociatesProfileProperties > &ExpressDataSet::getAllIfcRelAssociatesProfileProperties() {
    return m_refIfcRelAssociatesProfilePropertiesList;
}

Step::RefLinkedList< IfcRelConnects > &ExpressDataSet::getAllIfcRelConnects() {
    return m_refIfcRelConnectsList;
}

Step::RefLinkedList< IfcRelConnectsElements > &ExpressDataSet::getAllIfcRelConnectsElements() {
    return m_refIfcRelConnectsElementsList;
}

Step::RefLinkedList< IfcRelConnectsPathElements > &ExpressDataSet::getAllIfcRelConnectsPathElements() {
    return m_refIfcRelConnectsPathElementsList;
}

Step::RefLinkedList< IfcRelConnectsPortToElement > &ExpressDataSet::getAllIfcRelConnectsPortToElement() {
    return m_refIfcRelConnectsPortToElementList;
}

Step::RefLinkedList< IfcRelConnectsPorts > &ExpressDataSet::getAllIfcRelConnectsPorts() {
    return m_refIfcRelConnectsPortsList;
}

Step::RefLinkedList< IfcRelConnectsStructuralActivity > &ExpressDataSet::getAllIfcRelConnectsStructuralActivity() {
    return m_refIfcRelConnectsStructuralActivityList;
}

Step::RefLinkedList< IfcRelConnectsStructuralElement > &ExpressDataSet::getAllIfcRelConnectsStructuralElement() {
    return m_refIfcRelConnectsStructuralElementList;
}

Step::RefLinkedList< IfcRelConnectsStructuralMember > &ExpressDataSet::getAllIfcRelConnectsStructuralMember() {
    return m_refIfcRelConnectsStructuralMemberList;
}

Step::RefLinkedList< IfcRelConnectsWithEccentricity > &ExpressDataSet::getAllIfcRelConnectsWithEccentricity() {
    return m_refIfcRelConnectsWithEccentricityList;
}

Step::RefLinkedList< IfcRelConnectsWithRealizingElements > &ExpressDataSet::getAllIfcRelConnectsWithRealizingElements() {
    return m_refIfcRelConnectsWithRealizingElementsList;
}

Step::RefLinkedList< IfcRelContainedInSpatialStructure > &ExpressDataSet::getAllIfcRelContainedInSpatialStructure() {
    return m_refIfcRelContainedInSpatialStructureList;
}

Step::RefLinkedList< IfcRelCoversBldgElements > &ExpressDataSet::getAllIfcRelCoversBldgElements() {
    return m_refIfcRelCoversBldgElementsList;
}

Step::RefLinkedList< IfcRelCoversSpaces > &ExpressDataSet::getAllIfcRelCoversSpaces() {
    return m_refIfcRelCoversSpacesList;
}

Step::RefLinkedList< IfcRelDecomposes > &ExpressDataSet::getAllIfcRelDecomposes() {
    return m_refIfcRelDecomposesList;
}

Step::RefLinkedList< IfcRelDefines > &ExpressDataSet::getAllIfcRelDefines() {
    return m_refIfcRelDefinesList;
}

Step::RefLinkedList< IfcRelDefinesByProperties > &ExpressDataSet::getAllIfcRelDefinesByProperties() {
    return m_refIfcRelDefinesByPropertiesList;
}

Step::RefLinkedList< IfcRelDefinesByType > &ExpressDataSet::getAllIfcRelDefinesByType() {
    return m_refIfcRelDefinesByTypeList;
}

Step::RefLinkedList< IfcRelFillsElement > &ExpressDataSet::getAllIfcRelFillsElement() {
    return m_refIfcRelFillsElementList;
}

Step::RefLinkedList< IfcRelFlowControlElements > &ExpressDataSet::getAllIfcRelFlowControlElements() {
    return m_refIfcRelFlowControlElementsList;
}

Step::RefLinkedList< IfcRelInteractionRequirements > &ExpressDataSet::getAllIfcRelInteractionRequirements() {
    return m_refIfcRelInteractionRequirementsList;
}

Step::RefLinkedList< IfcRelNests > &ExpressDataSet::getAllIfcRelNests() {
    return m_refIfcRelNestsList;
}

Step::RefLinkedList< IfcRelOccupiesSpaces > &ExpressDataSet::getAllIfcRelOccupiesSpaces() {
    return m_refIfcRelOccupiesSpacesList;
}

Step::RefLinkedList< IfcRelOverridesProperties > &ExpressDataSet::getAllIfcRelOverridesProperties() {
    return m_refIfcRelOverridesPropertiesList;
}

Step::RefLinkedList< IfcRelProjectsElement > &ExpressDataSet::getAllIfcRelProjectsElement() {
    return m_refIfcRelProjectsElementList;
}

Step::RefLinkedList< IfcRelReferencedInSpatialStructure > &ExpressDataSet::getAllIfcRelReferencedInSpatialStructure() {
    return m_refIfcRelReferencedInSpatialStructureList;
}

Step::RefLinkedList< IfcRelSchedulesCostItems > &ExpressDataSet::getAllIfcRelSchedulesCostItems() {
    return m_refIfcRelSchedulesCostItemsList;
}

Step::RefLinkedList< IfcRelSequence > &ExpressDataSet::getAllIfcRelSequence() {
    return m_refIfcRelSequenceList;
}

Step::RefLinkedList< IfcRelServicesBuildings > &ExpressDataSet::getAllIfcRelServicesBuildings() {
    return m_refIfcRelServicesBuildingsList;
}

Step::RefLinkedList< IfcRelSpaceBoundary > &ExpressDataSet::getAllIfcRelSpaceBoundary() {
    return m_refIfcRelSpaceBoundaryList;
}

Step::RefLinkedList< IfcRelVoidsElement > &ExpressDataSet::getAllIfcRelVoidsElement() {
    return m_refIfcRelVoidsElementList;
}

Step::RefLinkedList< IfcRelationship > &ExpressDataSet::getAllIfcRelationship() {
    return m_refIfcRelationshipList;
}

Step::RefLinkedList< IfcRelaxation > &ExpressDataSet::getAllIfcRelaxation() {
    return m_refIfcRelaxationList;
}

Step::RefLinkedList< IfcRepresentation > &ExpressDataSet::getAllIfcRepresentation() {
    return m_refIfcRepresentationList;
}

Step::RefLinkedList< IfcRepresentationContext > &ExpressDataSet::getAllIfcRepresentationContext() {
    return m_refIfcRepresentationContextList;
}

Step::RefLinkedList< IfcRepresentationItem > &ExpressDataSet::getAllIfcRepresentationItem() {
    return m_refIfcRepresentationItemList;
}

Step::RefLinkedList< IfcRepresentationMap > &ExpressDataSet::getAllIfcRepresentationMap() {
    return m_refIfcRepresentationMapList;
}

Step::RefLinkedList< IfcResource > &ExpressDataSet::getAllIfcResource() {
    return m_refIfcResourceList;
}

Step::RefLinkedList< IfcRevolvedAreaSolid > &ExpressDataSet::getAllIfcRevolvedAreaSolid() {
    return m_refIfcRevolvedAreaSolidList;
}

Step::RefLinkedList< IfcRibPlateProfileProperties > &ExpressDataSet::getAllIfcRibPlateProfileProperties() {
    return m_refIfcRibPlateProfilePropertiesList;
}

Step::RefLinkedList< IfcRightCircularCone > &ExpressDataSet::getAllIfcRightCircularCone() {
    return m_refIfcRightCircularConeList;
}

Step::RefLinkedList< IfcRightCircularCylinder > &ExpressDataSet::getAllIfcRightCircularCylinder() {
    return m_refIfcRightCircularCylinderList;
}

Step::RefLinkedList< IfcRoof > &ExpressDataSet::getAllIfcRoof() {
    return m_refIfcRoofList;
}

Step::RefLinkedList< IfcRoot > &ExpressDataSet::getAllIfcRoot() {
    return m_refIfcRootList;
}

Step::RefLinkedList< IfcRoundedEdgeFeature > &ExpressDataSet::getAllIfcRoundedEdgeFeature() {
    return m_refIfcRoundedEdgeFeatureList;
}

Step::RefLinkedList< IfcRoundedRectangleProfileDef > &ExpressDataSet::getAllIfcRoundedRectangleProfileDef() {
    return m_refIfcRoundedRectangleProfileDefList;
}

Step::RefLinkedList< IfcSIUnit > &ExpressDataSet::getAllIfcSIUnit() {
    return m_refIfcSIUnitList;
}

Step::RefLinkedList< IfcSanitaryTerminalType > &ExpressDataSet::getAllIfcSanitaryTerminalType() {
    return m_refIfcSanitaryTerminalTypeList;
}

Step::RefLinkedList< IfcScheduleTimeControl > &ExpressDataSet::getAllIfcScheduleTimeControl() {
    return m_refIfcScheduleTimeControlList;
}

Step::RefLinkedList< IfcSectionProperties > &ExpressDataSet::getAllIfcSectionProperties() {
    return m_refIfcSectionPropertiesList;
}

Step::RefLinkedList< IfcSectionReinforcementProperties > &ExpressDataSet::getAllIfcSectionReinforcementProperties() {
    return m_refIfcSectionReinforcementPropertiesList;
}

Step::RefLinkedList< IfcSectionedSpine > &ExpressDataSet::getAllIfcSectionedSpine() {
    return m_refIfcSectionedSpineList;
}

Step::RefLinkedList< IfcSensorType > &ExpressDataSet::getAllIfcSensorType() {
    return m_refIfcSensorTypeList;
}

Step::RefLinkedList< IfcServiceLife > &ExpressDataSet::getAllIfcServiceLife() {
    return m_refIfcServiceLifeList;
}

Step::RefLinkedList< IfcServiceLifeFactor > &ExpressDataSet::getAllIfcServiceLifeFactor() {
    return m_refIfcServiceLifeFactorList;
}

Step::RefLinkedList< IfcShapeAspect > &ExpressDataSet::getAllIfcShapeAspect() {
    return m_refIfcShapeAspectList;
}

Step::RefLinkedList< IfcShapeModel > &ExpressDataSet::getAllIfcShapeModel() {
    return m_refIfcShapeModelList;
}

Step::RefLinkedList< IfcShapeRepresentation > &ExpressDataSet::getAllIfcShapeRepresentation() {
    return m_refIfcShapeRepresentationList;
}

Step::RefLinkedList< IfcShellBasedSurfaceModel > &ExpressDataSet::getAllIfcShellBasedSurfaceModel() {
    return m_refIfcShellBasedSurfaceModelList;
}

Step::RefLinkedList< IfcSimpleProperty > &ExpressDataSet::getAllIfcSimpleProperty() {
    return m_refIfcSimplePropertyList;
}

Step::RefLinkedList< IfcSite > &ExpressDataSet::getAllIfcSite() {
    return m_refIfcSiteList;
}

Step::RefLinkedList< IfcSlab > &ExpressDataSet::getAllIfcSlab() {
    return m_refIfcSlabList;
}

Step::RefLinkedList< IfcSlabType > &ExpressDataSet::getAllIfcSlabType() {
    return m_refIfcSlabTypeList;
}

Step::RefLinkedList< IfcSlippageConnectionCondition > &ExpressDataSet::getAllIfcSlippageConnectionCondition() {
    return m_refIfcSlippageConnectionConditionList;
}

Step::RefLinkedList< IfcSolidModel > &ExpressDataSet::getAllIfcSolidModel() {
    return m_refIfcSolidModelList;
}

Step::RefLinkedList< IfcSoundProperties > &ExpressDataSet::getAllIfcSoundProperties() {
    return m_refIfcSoundPropertiesList;
}

Step::RefLinkedList< IfcSoundValue > &ExpressDataSet::getAllIfcSoundValue() {
    return m_refIfcSoundValueList;
}

Step::RefLinkedList< IfcSpace > &ExpressDataSet::getAllIfcSpace() {
    return m_refIfcSpaceList;
}

Step::RefLinkedList< IfcSpaceHeaterType > &ExpressDataSet::getAllIfcSpaceHeaterType() {
    return m_refIfcSpaceHeaterTypeList;
}

Step::RefLinkedList< IfcSpaceProgram > &ExpressDataSet::getAllIfcSpaceProgram() {
    return m_refIfcSpaceProgramList;
}

Step::RefLinkedList< IfcSpaceThermalLoadProperties > &ExpressDataSet::getAllIfcSpaceThermalLoadProperties() {
    return m_refIfcSpaceThermalLoadPropertiesList;
}

Step::RefLinkedList< IfcSpaceType > &ExpressDataSet::getAllIfcSpaceType() {
    return m_refIfcSpaceTypeList;
}

Step::RefLinkedList< IfcSpatialStructureElement > &ExpressDataSet::getAllIfcSpatialStructureElement() {
    return m_refIfcSpatialStructureElementList;
}

Step::RefLinkedList< IfcSpatialStructureElementType > &ExpressDataSet::getAllIfcSpatialStructureElementType() {
    return m_refIfcSpatialStructureElementTypeList;
}

Step::RefLinkedList< IfcSphere > &ExpressDataSet::getAllIfcSphere() {
    return m_refIfcSphereList;
}

Step::RefLinkedList< IfcStackTerminalType > &ExpressDataSet::getAllIfcStackTerminalType() {
    return m_refIfcStackTerminalTypeList;
}

Step::RefLinkedList< IfcStair > &ExpressDataSet::getAllIfcStair() {
    return m_refIfcStairList;
}

Step::RefLinkedList< IfcStairFlight > &ExpressDataSet::getAllIfcStairFlight() {
    return m_refIfcStairFlightList;
}

Step::RefLinkedList< IfcStairFlightType > &ExpressDataSet::getAllIfcStairFlightType() {
    return m_refIfcStairFlightTypeList;
}

Step::RefLinkedList< IfcStructuralAction > &ExpressDataSet::getAllIfcStructuralAction() {
    return m_refIfcStructuralActionList;
}

Step::RefLinkedList< IfcStructuralActivity > &ExpressDataSet::getAllIfcStructuralActivity() {
    return m_refIfcStructuralActivityList;
}

Step::RefLinkedList< IfcStructuralAnalysisModel > &ExpressDataSet::getAllIfcStructuralAnalysisModel() {
    return m_refIfcStructuralAnalysisModelList;
}

Step::RefLinkedList< IfcStructuralConnection > &ExpressDataSet::getAllIfcStructuralConnection() {
    return m_refIfcStructuralConnectionList;
}

Step::RefLinkedList< IfcStructuralConnectionCondition > &ExpressDataSet::getAllIfcStructuralConnectionCondition() {
    return m_refIfcStructuralConnectionConditionList;
}

Step::RefLinkedList< IfcStructuralCurveConnection > &ExpressDataSet::getAllIfcStructuralCurveConnection() {
    return m_refIfcStructuralCurveConnectionList;
}

Step::RefLinkedList< IfcStructuralCurveMember > &ExpressDataSet::getAllIfcStructuralCurveMember() {
    return m_refIfcStructuralCurveMemberList;
}

Step::RefLinkedList< IfcStructuralCurveMemberVarying > &ExpressDataSet::getAllIfcStructuralCurveMemberVarying() {
    return m_refIfcStructuralCurveMemberVaryingList;
}

Step::RefLinkedList< IfcStructuralItem > &ExpressDataSet::getAllIfcStructuralItem() {
    return m_refIfcStructuralItemList;
}

Step::RefLinkedList< IfcStructuralLinearAction > &ExpressDataSet::getAllIfcStructuralLinearAction() {
    return m_refIfcStructuralLinearActionList;
}

Step::RefLinkedList< IfcStructuralLinearActionVarying > &ExpressDataSet::getAllIfcStructuralLinearActionVarying() {
    return m_refIfcStructuralLinearActionVaryingList;
}

Step::RefLinkedList< IfcStructuralLoad > &ExpressDataSet::getAllIfcStructuralLoad() {
    return m_refIfcStructuralLoadList;
}

Step::RefLinkedList< IfcStructuralLoadGroup > &ExpressDataSet::getAllIfcStructuralLoadGroup() {
    return m_refIfcStructuralLoadGroupList;
}

Step::RefLinkedList< IfcStructuralLoadLinearForce > &ExpressDataSet::getAllIfcStructuralLoadLinearForce() {
    return m_refIfcStructuralLoadLinearForceList;
}

Step::RefLinkedList< IfcStructuralLoadPlanarForce > &ExpressDataSet::getAllIfcStructuralLoadPlanarForce() {
    return m_refIfcStructuralLoadPlanarForceList;
}

Step::RefLinkedList< IfcStructuralLoadSingleDisplacement > &ExpressDataSet::getAllIfcStructuralLoadSingleDisplacement() {
    return m_refIfcStructuralLoadSingleDisplacementList;
}

Step::RefLinkedList< IfcStructuralLoadSingleDisplacementDistortion > &ExpressDataSet::getAllIfcStructuralLoadSingleDisplacementDistortion() {
    return m_refIfcStructuralLoadSingleDisplacementDistortionList;
}

Step::RefLinkedList< IfcStructuralLoadSingleForce > &ExpressDataSet::getAllIfcStructuralLoadSingleForce() {
    return m_refIfcStructuralLoadSingleForceList;
}

Step::RefLinkedList< IfcStructuralLoadSingleForceWarping > &ExpressDataSet::getAllIfcStructuralLoadSingleForceWarping() {
    return m_refIfcStructuralLoadSingleForceWarpingList;
}

Step::RefLinkedList< IfcStructuralLoadStatic > &ExpressDataSet::getAllIfcStructuralLoadStatic() {
    return m_refIfcStructuralLoadStaticList;
}

Step::RefLinkedList< IfcStructuralLoadTemperature > &ExpressDataSet::getAllIfcStructuralLoadTemperature() {
    return m_refIfcStructuralLoadTemperatureList;
}

Step::RefLinkedList< IfcStructuralMember > &ExpressDataSet::getAllIfcStructuralMember() {
    return m_refIfcStructuralMemberList;
}

Step::RefLinkedList< IfcStructuralPlanarAction > &ExpressDataSet::getAllIfcStructuralPlanarAction() {
    return m_refIfcStructuralPlanarActionList;
}

Step::RefLinkedList< IfcStructuralPlanarActionVarying > &ExpressDataSet::getAllIfcStructuralPlanarActionVarying() {
    return m_refIfcStructuralPlanarActionVaryingList;
}

Step::RefLinkedList< IfcStructuralPointAction > &ExpressDataSet::getAllIfcStructuralPointAction() {
    return m_refIfcStructuralPointActionList;
}

Step::RefLinkedList< IfcStructuralPointConnection > &ExpressDataSet::getAllIfcStructuralPointConnection() {
    return m_refIfcStructuralPointConnectionList;
}

Step::RefLinkedList< IfcStructuralPointReaction > &ExpressDataSet::getAllIfcStructuralPointReaction() {
    return m_refIfcStructuralPointReactionList;
}

Step::RefLinkedList< IfcStructuralProfileProperties > &ExpressDataSet::getAllIfcStructuralProfileProperties() {
    return m_refIfcStructuralProfilePropertiesList;
}

Step::RefLinkedList< IfcStructuralReaction > &ExpressDataSet::getAllIfcStructuralReaction() {
    return m_refIfcStructuralReactionList;
}

Step::RefLinkedList< IfcStructuralResultGroup > &ExpressDataSet::getAllIfcStructuralResultGroup() {
    return m_refIfcStructuralResultGroupList;
}

Step::RefLinkedList< IfcStructuralSteelProfileProperties > &ExpressDataSet::getAllIfcStructuralSteelProfileProperties() {
    return m_refIfcStructuralSteelProfilePropertiesList;
}

Step::RefLinkedList< IfcStructuralSurfaceConnection > &ExpressDataSet::getAllIfcStructuralSurfaceConnection() {
    return m_refIfcStructuralSurfaceConnectionList;
}

Step::RefLinkedList< IfcStructuralSurfaceMember > &ExpressDataSet::getAllIfcStructuralSurfaceMember() {
    return m_refIfcStructuralSurfaceMemberList;
}

Step::RefLinkedList< IfcStructuralSurfaceMemberVarying > &ExpressDataSet::getAllIfcStructuralSurfaceMemberVarying() {
    return m_refIfcStructuralSurfaceMemberVaryingList;
}

Step::RefLinkedList< IfcStructuredDimensionCallout > &ExpressDataSet::getAllIfcStructuredDimensionCallout() {
    return m_refIfcStructuredDimensionCalloutList;
}

Step::RefLinkedList< IfcStyleModel > &ExpressDataSet::getAllIfcStyleModel() {
    return m_refIfcStyleModelList;
}

Step::RefLinkedList< IfcStyledItem > &ExpressDataSet::getAllIfcStyledItem() {
    return m_refIfcStyledItemList;
}

Step::RefLinkedList< IfcStyledRepresentation > &ExpressDataSet::getAllIfcStyledRepresentation() {
    return m_refIfcStyledRepresentationList;
}

Step::RefLinkedList< IfcSubContractResource > &ExpressDataSet::getAllIfcSubContractResource() {
    return m_refIfcSubContractResourceList;
}

Step::RefLinkedList< IfcSubedge > &ExpressDataSet::getAllIfcSubedge() {
    return m_refIfcSubedgeList;
}

Step::RefLinkedList< IfcSurface > &ExpressDataSet::getAllIfcSurface() {
    return m_refIfcSurfaceList;
}

Step::RefLinkedList< IfcSurfaceCurveSweptAreaSolid > &ExpressDataSet::getAllIfcSurfaceCurveSweptAreaSolid() {
    return m_refIfcSurfaceCurveSweptAreaSolidList;
}

Step::RefLinkedList< IfcSurfaceOfLinearExtrusion > &ExpressDataSet::getAllIfcSurfaceOfLinearExtrusion() {
    return m_refIfcSurfaceOfLinearExtrusionList;
}

Step::RefLinkedList< IfcSurfaceOfRevolution > &ExpressDataSet::getAllIfcSurfaceOfRevolution() {
    return m_refIfcSurfaceOfRevolutionList;
}

Step::RefLinkedList< IfcSurfaceStyle > &ExpressDataSet::getAllIfcSurfaceStyle() {
    return m_refIfcSurfaceStyleList;
}

Step::RefLinkedList< IfcSurfaceStyleLighting > &ExpressDataSet::getAllIfcSurfaceStyleLighting() {
    return m_refIfcSurfaceStyleLightingList;
}

Step::RefLinkedList< IfcSurfaceStyleRefraction > &ExpressDataSet::getAllIfcSurfaceStyleRefraction() {
    return m_refIfcSurfaceStyleRefractionList;
}

Step::RefLinkedList< IfcSurfaceStyleRendering > &ExpressDataSet::getAllIfcSurfaceStyleRendering() {
    return m_refIfcSurfaceStyleRenderingList;
}

Step::RefLinkedList< IfcSurfaceStyleShading > &ExpressDataSet::getAllIfcSurfaceStyleShading() {
    return m_refIfcSurfaceStyleShadingList;
}

Step::RefLinkedList< IfcSurfaceStyleWithTextures > &ExpressDataSet::getAllIfcSurfaceStyleWithTextures() {
    return m_refIfcSurfaceStyleWithTexturesList;
}

Step::RefLinkedList< IfcSurfaceTexture > &ExpressDataSet::getAllIfcSurfaceTexture() {
    return m_refIfcSurfaceTextureList;
}

Step::RefLinkedList< IfcSweptAreaSolid > &ExpressDataSet::getAllIfcSweptAreaSolid() {
    return m_refIfcSweptAreaSolidList;
}

Step::RefLinkedList< IfcSweptDiskSolid > &ExpressDataSet::getAllIfcSweptDiskSolid() {
    return m_refIfcSweptDiskSolidList;
}

Step::RefLinkedList< IfcSweptSurface > &ExpressDataSet::getAllIfcSweptSurface() {
    return m_refIfcSweptSurfaceList;
}

Step::RefLinkedList< IfcSwitchingDeviceType > &ExpressDataSet::getAllIfcSwitchingDeviceType() {
    return m_refIfcSwitchingDeviceTypeList;
}

Step::RefLinkedList< IfcSymbolStyle > &ExpressDataSet::getAllIfcSymbolStyle() {
    return m_refIfcSymbolStyleList;
}

Step::RefLinkedList< IfcSystem > &ExpressDataSet::getAllIfcSystem() {
    return m_refIfcSystemList;
}

Step::RefLinkedList< IfcSystemFurnitureElementType > &ExpressDataSet::getAllIfcSystemFurnitureElementType() {
    return m_refIfcSystemFurnitureElementTypeList;
}

Step::RefLinkedList< IfcTShapeProfileDef > &ExpressDataSet::getAllIfcTShapeProfileDef() {
    return m_refIfcTShapeProfileDefList;
}

Step::RefLinkedList< IfcTable > &ExpressDataSet::getAllIfcTable() {
    return m_refIfcTableList;
}

Step::RefLinkedList< IfcTableRow > &ExpressDataSet::getAllIfcTableRow() {
    return m_refIfcTableRowList;
}

Step::RefLinkedList< IfcTankType > &ExpressDataSet::getAllIfcTankType() {
    return m_refIfcTankTypeList;
}

Step::RefLinkedList< IfcTask > &ExpressDataSet::getAllIfcTask() {
    return m_refIfcTaskList;
}

Step::RefLinkedList< IfcTelecomAddress > &ExpressDataSet::getAllIfcTelecomAddress() {
    return m_refIfcTelecomAddressList;
}

Step::RefLinkedList< IfcTendon > &ExpressDataSet::getAllIfcTendon() {
    return m_refIfcTendonList;
}

Step::RefLinkedList< IfcTendonAnchor > &ExpressDataSet::getAllIfcTendonAnchor() {
    return m_refIfcTendonAnchorList;
}

Step::RefLinkedList< IfcTerminatorSymbol > &ExpressDataSet::getAllIfcTerminatorSymbol() {
    return m_refIfcTerminatorSymbolList;
}

Step::RefLinkedList< IfcTextLiteral > &ExpressDataSet::getAllIfcTextLiteral() {
    return m_refIfcTextLiteralList;
}

Step::RefLinkedList< IfcTextLiteralWithExtent > &ExpressDataSet::getAllIfcTextLiteralWithExtent() {
    return m_refIfcTextLiteralWithExtentList;
}

Step::RefLinkedList< IfcTextStyle > &ExpressDataSet::getAllIfcTextStyle() {
    return m_refIfcTextStyleList;
}

Step::RefLinkedList< IfcTextStyleFontModel > &ExpressDataSet::getAllIfcTextStyleFontModel() {
    return m_refIfcTextStyleFontModelList;
}

Step::RefLinkedList< IfcTextStyleForDefinedFont > &ExpressDataSet::getAllIfcTextStyleForDefinedFont() {
    return m_refIfcTextStyleForDefinedFontList;
}

Step::RefLinkedList< IfcTextStyleTextModel > &ExpressDataSet::getAllIfcTextStyleTextModel() {
    return m_refIfcTextStyleTextModelList;
}

Step::RefLinkedList< IfcTextStyleWithBoxCharacteristics > &ExpressDataSet::getAllIfcTextStyleWithBoxCharacteristics() {
    return m_refIfcTextStyleWithBoxCharacteristicsList;
}

Step::RefLinkedList< IfcTextureCoordinate > &ExpressDataSet::getAllIfcTextureCoordinate() {
    return m_refIfcTextureCoordinateList;
}

Step::RefLinkedList< IfcTextureCoordinateGenerator > &ExpressDataSet::getAllIfcTextureCoordinateGenerator() {
    return m_refIfcTextureCoordinateGeneratorList;
}

Step::RefLinkedList< IfcTextureMap > &ExpressDataSet::getAllIfcTextureMap() {
    return m_refIfcTextureMapList;
}

Step::RefLinkedList< IfcTextureVertex > &ExpressDataSet::getAllIfcTextureVertex() {
    return m_refIfcTextureVertexList;
}

Step::RefLinkedList< IfcThermalMaterialProperties > &ExpressDataSet::getAllIfcThermalMaterialProperties() {
    return m_refIfcThermalMaterialPropertiesList;
}

Step::RefLinkedList< IfcTimeSeries > &ExpressDataSet::getAllIfcTimeSeries() {
    return m_refIfcTimeSeriesList;
}

Step::RefLinkedList< IfcTimeSeriesReferenceRelationship > &ExpressDataSet::getAllIfcTimeSeriesReferenceRelationship() {
    return m_refIfcTimeSeriesReferenceRelationshipList;
}

Step::RefLinkedList< IfcTimeSeriesSchedule > &ExpressDataSet::getAllIfcTimeSeriesSchedule() {
    return m_refIfcTimeSeriesScheduleList;
}

Step::RefLinkedList< IfcTimeSeriesValue > &ExpressDataSet::getAllIfcTimeSeriesValue() {
    return m_refIfcTimeSeriesValueList;
}

Step::RefLinkedList< IfcTopologicalRepresentationItem > &ExpressDataSet::getAllIfcTopologicalRepresentationItem() {
    return m_refIfcTopologicalRepresentationItemList;
}

Step::RefLinkedList< IfcTopologyRepresentation > &ExpressDataSet::getAllIfcTopologyRepresentation() {
    return m_refIfcTopologyRepresentationList;
}

Step::RefLinkedList< IfcTransformerType > &ExpressDataSet::getAllIfcTransformerType() {
    return m_refIfcTransformerTypeList;
}

Step::RefLinkedList< IfcTransportElement > &ExpressDataSet::getAllIfcTransportElement() {
    return m_refIfcTransportElementList;
}

Step::RefLinkedList< IfcTransportElementType > &ExpressDataSet::getAllIfcTransportElementType() {
    return m_refIfcTransportElementTypeList;
}

Step::RefLinkedList< IfcTrapeziumProfileDef > &ExpressDataSet::getAllIfcTrapeziumProfileDef() {
    return m_refIfcTrapeziumProfileDefList;
}

Step::RefLinkedList< IfcTrimmedCurve > &ExpressDataSet::getAllIfcTrimmedCurve() {
    return m_refIfcTrimmedCurveList;
}

Step::RefLinkedList< IfcTubeBundleType > &ExpressDataSet::getAllIfcTubeBundleType() {
    return m_refIfcTubeBundleTypeList;
}

Step::RefLinkedList< IfcTwoDirectionRepeatFactor > &ExpressDataSet::getAllIfcTwoDirectionRepeatFactor() {
    return m_refIfcTwoDirectionRepeatFactorList;
}

Step::RefLinkedList< IfcTypeObject > &ExpressDataSet::getAllIfcTypeObject() {
    return m_refIfcTypeObjectList;
}

Step::RefLinkedList< IfcTypeProduct > &ExpressDataSet::getAllIfcTypeProduct() {
    return m_refIfcTypeProductList;
}

Step::RefLinkedList< IfcUShapeProfileDef > &ExpressDataSet::getAllIfcUShapeProfileDef() {
    return m_refIfcUShapeProfileDefList;
}

Step::RefLinkedList< IfcUnitAssignment > &ExpressDataSet::getAllIfcUnitAssignment() {
    return m_refIfcUnitAssignmentList;
}

Step::RefLinkedList< IfcUnitaryEquipmentType > &ExpressDataSet::getAllIfcUnitaryEquipmentType() {
    return m_refIfcUnitaryEquipmentTypeList;
}

Step::RefLinkedList< IfcValveType > &ExpressDataSet::getAllIfcValveType() {
    return m_refIfcValveTypeList;
}

Step::RefLinkedList< IfcVector > &ExpressDataSet::getAllIfcVector() {
    return m_refIfcVectorList;
}

Step::RefLinkedList< IfcVertex > &ExpressDataSet::getAllIfcVertex() {
    return m_refIfcVertexList;
}

Step::RefLinkedList< IfcVertexBasedTextureMap > &ExpressDataSet::getAllIfcVertexBasedTextureMap() {
    return m_refIfcVertexBasedTextureMapList;
}

Step::RefLinkedList< IfcVertexLoop > &ExpressDataSet::getAllIfcVertexLoop() {
    return m_refIfcVertexLoopList;
}

Step::RefLinkedList< IfcVertexPoint > &ExpressDataSet::getAllIfcVertexPoint() {
    return m_refIfcVertexPointList;
}

Step::RefLinkedList< IfcVibrationIsolatorType > &ExpressDataSet::getAllIfcVibrationIsolatorType() {
    return m_refIfcVibrationIsolatorTypeList;
}

Step::RefLinkedList< IfcVirtualElement > &ExpressDataSet::getAllIfcVirtualElement() {
    return m_refIfcVirtualElementList;
}

Step::RefLinkedList< IfcVirtualGridIntersection > &ExpressDataSet::getAllIfcVirtualGridIntersection() {
    return m_refIfcVirtualGridIntersectionList;
}

Step::RefLinkedList< IfcWall > &ExpressDataSet::getAllIfcWall() {
    return m_refIfcWallList;
}

Step::RefLinkedList< IfcWallStandardCase > &ExpressDataSet::getAllIfcWallStandardCase() {
    return m_refIfcWallStandardCaseList;
}

Step::RefLinkedList< IfcWallType > &ExpressDataSet::getAllIfcWallType() {
    return m_refIfcWallTypeList;
}

Step::RefLinkedList< IfcWasteTerminalType > &ExpressDataSet::getAllIfcWasteTerminalType() {
    return m_refIfcWasteTerminalTypeList;
}

Step::RefLinkedList< IfcWaterProperties > &ExpressDataSet::getAllIfcWaterProperties() {
    return m_refIfcWaterPropertiesList;
}

Step::RefLinkedList< IfcWindow > &ExpressDataSet::getAllIfcWindow() {
    return m_refIfcWindowList;
}

Step::RefLinkedList< IfcWindowLiningProperties > &ExpressDataSet::getAllIfcWindowLiningProperties() {
    return m_refIfcWindowLiningPropertiesList;
}

Step::RefLinkedList< IfcWindowPanelProperties > &ExpressDataSet::getAllIfcWindowPanelProperties() {
    return m_refIfcWindowPanelPropertiesList;
}

Step::RefLinkedList< IfcWindowStyle > &ExpressDataSet::getAllIfcWindowStyle() {
    return m_refIfcWindowStyleList;
}

Step::RefLinkedList< IfcWorkControl > &ExpressDataSet::getAllIfcWorkControl() {
    return m_refIfcWorkControlList;
}

Step::RefLinkedList< IfcWorkPlan > &ExpressDataSet::getAllIfcWorkPlan() {
    return m_refIfcWorkPlanList;
}

Step::RefLinkedList< IfcWorkSchedule > &ExpressDataSet::getAllIfcWorkSchedule() {
    return m_refIfcWorkScheduleList;
}

Step::RefLinkedList< IfcZShapeProfileDef > &ExpressDataSet::getAllIfcZShapeProfileDef() {
    return m_refIfcZShapeProfileDefList;
}

Step::RefLinkedList< IfcZone > &ExpressDataSet::getAllIfcZone() {
    return m_refIfcZoneList;
}

