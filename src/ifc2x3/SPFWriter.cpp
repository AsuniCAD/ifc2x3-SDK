/*
//////////////////////////////////
// This File has been generated //
// by Expressik light generator //
//  Powered by : Eve CSTB       //
//////////////////////////////////

 * *************************************************************************
 *                                                                         *
 *     STEP Early Classes C++                                              *
 *                                                                         *
 *     Copyright (C) 2009 CSTB                                             *
 *                                                                         *
 *                                                                         *
 *   For further information please contact                                *
 *                                                                         *
 *         eve@cstb.fr                                                     *
 *   or                                                                    *
 *         Mod-Eve, CSTB                                                   *
 *         290, route des Lucioles                                         *
 *         BP 209                                                          *
 *         06904 Sophia Antipolis, France                                  *
 *                                                                         *
 ***************************************************************************
*/

#include "ifc2x3/SPFWriter.h"

#include "ifc2x3/ExpressDataSet.h"
#include "ifc2x3/Ifc2DCompositeCurve.h"
#include "ifc2x3/IfcActionRequest.h"
#include "ifc2x3/IfcActor.h"
#include "ifc2x3/IfcActorRole.h"
#include "ifc2x3/IfcActorSelect.h"
#include "ifc2x3/IfcActuatorType.h"
#include "ifc2x3/IfcAddress.h"
#include "ifc2x3/IfcAirTerminalBoxType.h"
#include "ifc2x3/IfcAirTerminalType.h"
#include "ifc2x3/IfcAirToAirHeatRecoveryType.h"
#include "ifc2x3/IfcAlarmType.h"
#include "ifc2x3/IfcAngularDimension.h"
#include "ifc2x3/IfcAnnotation.h"
#include "ifc2x3/IfcAnnotationCurveOccurrence.h"
#include "ifc2x3/IfcAnnotationFillArea.h"
#include "ifc2x3/IfcAnnotationFillAreaOccurrence.h"
#include "ifc2x3/IfcAnnotationOccurrence.h"
#include "ifc2x3/IfcAnnotationSurface.h"
#include "ifc2x3/IfcAnnotationSurfaceOccurrence.h"
#include "ifc2x3/IfcAnnotationSymbolOccurrence.h"
#include "ifc2x3/IfcAnnotationTextOccurrence.h"
#include "ifc2x3/IfcApplication.h"
#include "ifc2x3/IfcAppliedValue.h"
#include "ifc2x3/IfcAppliedValueRelationship.h"
#include "ifc2x3/IfcAppliedValueSelect.h"
#include "ifc2x3/IfcApproval.h"
#include "ifc2x3/IfcApprovalActorRelationship.h"
#include "ifc2x3/IfcApprovalPropertyRelationship.h"
#include "ifc2x3/IfcApprovalRelationship.h"
#include "ifc2x3/IfcArbitraryClosedProfileDef.h"
#include "ifc2x3/IfcArbitraryOpenProfileDef.h"
#include "ifc2x3/IfcArbitraryProfileDefWithVoids.h"
#include "ifc2x3/IfcAsset.h"
#include "ifc2x3/IfcAsymmetricIShapeProfileDef.h"
#include "ifc2x3/IfcAxis1Placement.h"
#include "ifc2x3/IfcAxis2Placement.h"
#include "ifc2x3/IfcAxis2Placement2D.h"
#include "ifc2x3/IfcAxis2Placement3D.h"
#include "ifc2x3/IfcBSplineCurve.h"
#include "ifc2x3/IfcBeam.h"
#include "ifc2x3/IfcBeamType.h"
#include "ifc2x3/IfcBezierCurve.h"
#include "ifc2x3/IfcBlobTexture.h"
#include "ifc2x3/IfcBlock.h"
#include "ifc2x3/IfcBoilerType.h"
#include "ifc2x3/IfcBooleanClippingResult.h"
#include "ifc2x3/IfcBooleanOperand.h"
#include "ifc2x3/IfcBooleanResult.h"
#include "ifc2x3/IfcBoundaryCondition.h"
#include "ifc2x3/IfcBoundaryEdgeCondition.h"
#include "ifc2x3/IfcBoundaryFaceCondition.h"
#include "ifc2x3/IfcBoundaryNodeCondition.h"
#include "ifc2x3/IfcBoundaryNodeConditionWarping.h"
#include "ifc2x3/IfcBoundedCurve.h"
#include "ifc2x3/IfcBoundedSurface.h"
#include "ifc2x3/IfcBoundingBox.h"
#include "ifc2x3/IfcBoxedHalfSpace.h"
#include "ifc2x3/IfcBuilding.h"
#include "ifc2x3/IfcBuildingElement.h"
#include "ifc2x3/IfcBuildingElementComponent.h"
#include "ifc2x3/IfcBuildingElementPart.h"
#include "ifc2x3/IfcBuildingElementProxy.h"
#include "ifc2x3/IfcBuildingElementProxyType.h"
#include "ifc2x3/IfcBuildingElementType.h"
#include "ifc2x3/IfcBuildingStorey.h"
#include "ifc2x3/IfcCShapeProfileDef.h"
#include "ifc2x3/IfcCableCarrierFittingType.h"
#include "ifc2x3/IfcCableCarrierSegmentType.h"
#include "ifc2x3/IfcCableSegmentType.h"
#include "ifc2x3/IfcCalendarDate.h"
#include "ifc2x3/IfcCartesianPoint.h"
#include "ifc2x3/IfcCartesianTransformationOperator.h"
#include "ifc2x3/IfcCartesianTransformationOperator2D.h"
#include "ifc2x3/IfcCartesianTransformationOperator2DnonUniform.h"
#include "ifc2x3/IfcCartesianTransformationOperator3D.h"
#include "ifc2x3/IfcCartesianTransformationOperator3DnonUniform.h"
#include "ifc2x3/IfcCenterLineProfileDef.h"
#include "ifc2x3/IfcChamferEdgeFeature.h"
#include "ifc2x3/IfcCharacterStyleSelect.h"
#include "ifc2x3/IfcChillerType.h"
#include "ifc2x3/IfcCircle.h"
#include "ifc2x3/IfcCircleHollowProfileDef.h"
#include "ifc2x3/IfcCircleProfileDef.h"
#include "ifc2x3/IfcClassification.h"
#include "ifc2x3/IfcClassificationItem.h"
#include "ifc2x3/IfcClassificationItemRelationship.h"
#include "ifc2x3/IfcClassificationNotation.h"
#include "ifc2x3/IfcClassificationNotationFacet.h"
#include "ifc2x3/IfcClassificationNotationSelect.h"
#include "ifc2x3/IfcClassificationReference.h"
#include "ifc2x3/IfcClosedShell.h"
#include "ifc2x3/IfcCoilType.h"
#include "ifc2x3/IfcColour.h"
#include "ifc2x3/IfcColourOrFactor.h"
#include "ifc2x3/IfcColourRgb.h"
#include "ifc2x3/IfcColourSpecification.h"
#include "ifc2x3/IfcColumn.h"
#include "ifc2x3/IfcColumnType.h"
#include "ifc2x3/IfcComplexProperty.h"
#include "ifc2x3/IfcCompositeCurve.h"
#include "ifc2x3/IfcCompositeCurveSegment.h"
#include "ifc2x3/IfcCompositeProfileDef.h"
#include "ifc2x3/IfcCompressorType.h"
#include "ifc2x3/IfcCondenserType.h"
#include "ifc2x3/IfcCondition.h"
#include "ifc2x3/IfcConditionCriterion.h"
#include "ifc2x3/IfcConditionCriterionSelect.h"
#include "ifc2x3/IfcConic.h"
#include "ifc2x3/IfcConnectedFaceSet.h"
#include "ifc2x3/IfcConnectionCurveGeometry.h"
#include "ifc2x3/IfcConnectionGeometry.h"
#include "ifc2x3/IfcConnectionPointEccentricity.h"
#include "ifc2x3/IfcConnectionPointGeometry.h"
#include "ifc2x3/IfcConnectionPortGeometry.h"
#include "ifc2x3/IfcConnectionSurfaceGeometry.h"
#include "ifc2x3/IfcConstraint.h"
#include "ifc2x3/IfcConstraintAggregationRelationship.h"
#include "ifc2x3/IfcConstraintClassificationRelationship.h"
#include "ifc2x3/IfcConstraintRelationship.h"
#include "ifc2x3/IfcConstructionEquipmentResource.h"
#include "ifc2x3/IfcConstructionMaterialResource.h"
#include "ifc2x3/IfcConstructionProductResource.h"
#include "ifc2x3/IfcConstructionResource.h"
#include "ifc2x3/IfcContextDependentUnit.h"
#include "ifc2x3/IfcControl.h"
#include "ifc2x3/IfcControllerType.h"
#include "ifc2x3/IfcConversionBasedUnit.h"
#include "ifc2x3/IfcCooledBeamType.h"
#include "ifc2x3/IfcCoolingTowerType.h"
#include "ifc2x3/IfcCoordinatedUniversalTimeOffset.h"
#include "ifc2x3/IfcCostItem.h"
#include "ifc2x3/IfcCostSchedule.h"
#include "ifc2x3/IfcCostValue.h"
#include "ifc2x3/IfcCovering.h"
#include "ifc2x3/IfcCoveringType.h"
#include "ifc2x3/IfcCraneRailAShapeProfileDef.h"
#include "ifc2x3/IfcCraneRailFShapeProfileDef.h"
#include "ifc2x3/IfcCrewResource.h"
#include "ifc2x3/IfcCsgPrimitive3D.h"
#include "ifc2x3/IfcCsgSelect.h"
#include "ifc2x3/IfcCsgSolid.h"
#include "ifc2x3/IfcCurrencyRelationship.h"
#include "ifc2x3/IfcCurtainWall.h"
#include "ifc2x3/IfcCurtainWallType.h"
#include "ifc2x3/IfcCurve.h"
#include "ifc2x3/IfcCurveBoundedPlane.h"
#include "ifc2x3/IfcCurveFontOrScaledCurveFontSelect.h"
#include "ifc2x3/IfcCurveOrEdgeCurve.h"
#include "ifc2x3/IfcCurveStyle.h"
#include "ifc2x3/IfcCurveStyleFont.h"
#include "ifc2x3/IfcCurveStyleFontAndScaling.h"
#include "ifc2x3/IfcCurveStyleFontPattern.h"
#include "ifc2x3/IfcCurveStyleFontSelect.h"
#include "ifc2x3/IfcDamperType.h"
#include "ifc2x3/IfcDateAndTime.h"
#include "ifc2x3/IfcDateTimeSelect.h"
#include "ifc2x3/IfcDefinedSymbol.h"
#include "ifc2x3/IfcDefinedSymbolSelect.h"
#include "ifc2x3/IfcDerivedMeasureValue.h"
#include "ifc2x3/IfcDerivedProfileDef.h"
#include "ifc2x3/IfcDerivedUnit.h"
#include "ifc2x3/IfcDerivedUnitElement.h"
#include "ifc2x3/IfcDiameterDimension.h"
#include "ifc2x3/IfcDimensionCalloutRelationship.h"
#include "ifc2x3/IfcDimensionCurve.h"
#include "ifc2x3/IfcDimensionCurveDirectedCallout.h"
#include "ifc2x3/IfcDimensionCurveTerminator.h"
#include "ifc2x3/IfcDimensionPair.h"
#include "ifc2x3/IfcDimensionalExponents.h"
#include "ifc2x3/IfcDirection.h"
#include "ifc2x3/IfcDiscreteAccessory.h"
#include "ifc2x3/IfcDiscreteAccessoryType.h"
#include "ifc2x3/IfcDistributionChamberElement.h"
#include "ifc2x3/IfcDistributionChamberElementType.h"
#include "ifc2x3/IfcDistributionControlElement.h"
#include "ifc2x3/IfcDistributionControlElementType.h"
#include "ifc2x3/IfcDistributionElement.h"
#include "ifc2x3/IfcDistributionElementType.h"
#include "ifc2x3/IfcDistributionFlowElement.h"
#include "ifc2x3/IfcDistributionFlowElementType.h"
#include "ifc2x3/IfcDistributionPort.h"
#include "ifc2x3/IfcDocumentElectronicFormat.h"
#include "ifc2x3/IfcDocumentInformation.h"
#include "ifc2x3/IfcDocumentInformationRelationship.h"
#include "ifc2x3/IfcDocumentReference.h"
#include "ifc2x3/IfcDocumentSelect.h"
#include "ifc2x3/IfcDoor.h"
#include "ifc2x3/IfcDoorLiningProperties.h"
#include "ifc2x3/IfcDoorPanelProperties.h"
#include "ifc2x3/IfcDoorStyle.h"
#include "ifc2x3/IfcDraughtingCallout.h"
#include "ifc2x3/IfcDraughtingCalloutElement.h"
#include "ifc2x3/IfcDraughtingCalloutRelationship.h"
#include "ifc2x3/IfcDraughtingPreDefinedColour.h"
#include "ifc2x3/IfcDraughtingPreDefinedCurveFont.h"
#include "ifc2x3/IfcDraughtingPreDefinedTextFont.h"
#include "ifc2x3/IfcDuctFittingType.h"
#include "ifc2x3/IfcDuctSegmentType.h"
#include "ifc2x3/IfcDuctSilencerType.h"
#include "ifc2x3/IfcEdge.h"
#include "ifc2x3/IfcEdgeCurve.h"
#include "ifc2x3/IfcEdgeFeature.h"
#include "ifc2x3/IfcEdgeLoop.h"
#include "ifc2x3/IfcElectricApplianceType.h"
#include "ifc2x3/IfcElectricDistributionPoint.h"
#include "ifc2x3/IfcElectricFlowStorageDeviceType.h"
#include "ifc2x3/IfcElectricGeneratorType.h"
#include "ifc2x3/IfcElectricHeaterType.h"
#include "ifc2x3/IfcElectricMotorType.h"
#include "ifc2x3/IfcElectricTimeControlType.h"
#include "ifc2x3/IfcElectricalBaseProperties.h"
#include "ifc2x3/IfcElectricalCircuit.h"
#include "ifc2x3/IfcElectricalElement.h"
#include "ifc2x3/IfcElement.h"
#include "ifc2x3/IfcElementAssembly.h"
#include "ifc2x3/IfcElementComponent.h"
#include "ifc2x3/IfcElementComponentType.h"
#include "ifc2x3/IfcElementQuantity.h"
#include "ifc2x3/IfcElementType.h"
#include "ifc2x3/IfcElementarySurface.h"
#include "ifc2x3/IfcEllipse.h"
#include "ifc2x3/IfcEllipseProfileDef.h"
#include "ifc2x3/IfcEnergyConversionDevice.h"
#include "ifc2x3/IfcEnergyConversionDeviceType.h"
#include "ifc2x3/IfcEnergyProperties.h"
#include "ifc2x3/IfcEnvironmentalImpactValue.h"
#include "ifc2x3/IfcEquipmentElement.h"
#include "ifc2x3/IfcEquipmentStandard.h"
#include "ifc2x3/IfcEvaporativeCoolerType.h"
#include "ifc2x3/IfcEvaporatorType.h"
#include "ifc2x3/IfcExtendedMaterialProperties.h"
#include "ifc2x3/IfcExternalReference.h"
#include "ifc2x3/IfcExternallyDefinedHatchStyle.h"
#include "ifc2x3/IfcExternallyDefinedSurfaceStyle.h"
#include "ifc2x3/IfcExternallyDefinedSymbol.h"
#include "ifc2x3/IfcExternallyDefinedTextFont.h"
#include "ifc2x3/IfcExtrudedAreaSolid.h"
#include "ifc2x3/IfcFace.h"
#include "ifc2x3/IfcFaceBasedSurfaceModel.h"
#include "ifc2x3/IfcFaceBound.h"
#include "ifc2x3/IfcFaceOuterBound.h"
#include "ifc2x3/IfcFaceSurface.h"
#include "ifc2x3/IfcFacetedBrep.h"
#include "ifc2x3/IfcFacetedBrepWithVoids.h"
#include "ifc2x3/IfcFailureConnectionCondition.h"
#include "ifc2x3/IfcFanType.h"
#include "ifc2x3/IfcFastener.h"
#include "ifc2x3/IfcFastenerType.h"
#include "ifc2x3/IfcFeatureElement.h"
#include "ifc2x3/IfcFeatureElementAddition.h"
#include "ifc2x3/IfcFeatureElementSubtraction.h"
#include "ifc2x3/IfcFillAreaStyle.h"
#include "ifc2x3/IfcFillAreaStyleHatching.h"
#include "ifc2x3/IfcFillAreaStyleTileShapeSelect.h"
#include "ifc2x3/IfcFillAreaStyleTileSymbolWithStyle.h"
#include "ifc2x3/IfcFillAreaStyleTiles.h"
#include "ifc2x3/IfcFillStyleSelect.h"
#include "ifc2x3/IfcFilterType.h"
#include "ifc2x3/IfcFireSuppressionTerminalType.h"
#include "ifc2x3/IfcFlowController.h"
#include "ifc2x3/IfcFlowControllerType.h"
#include "ifc2x3/IfcFlowFitting.h"
#include "ifc2x3/IfcFlowFittingType.h"
#include "ifc2x3/IfcFlowInstrumentType.h"
#include "ifc2x3/IfcFlowMeterType.h"
#include "ifc2x3/IfcFlowMovingDevice.h"
#include "ifc2x3/IfcFlowMovingDeviceType.h"
#include "ifc2x3/IfcFlowSegment.h"
#include "ifc2x3/IfcFlowSegmentType.h"
#include "ifc2x3/IfcFlowStorageDevice.h"
#include "ifc2x3/IfcFlowStorageDeviceType.h"
#include "ifc2x3/IfcFlowTerminal.h"
#include "ifc2x3/IfcFlowTerminalType.h"
#include "ifc2x3/IfcFlowTreatmentDevice.h"
#include "ifc2x3/IfcFlowTreatmentDeviceType.h"
#include "ifc2x3/IfcFluidFlowProperties.h"
#include "ifc2x3/IfcFooting.h"
#include "ifc2x3/IfcFuelProperties.h"
#include "ifc2x3/IfcFurnishingElement.h"
#include "ifc2x3/IfcFurnishingElementType.h"
#include "ifc2x3/IfcFurnitureStandard.h"
#include "ifc2x3/IfcFurnitureType.h"
#include "ifc2x3/IfcGasTerminalType.h"
#include "ifc2x3/IfcGeneralMaterialProperties.h"
#include "ifc2x3/IfcGeneralProfileProperties.h"
#include "ifc2x3/IfcGeometricCurveSet.h"
#include "ifc2x3/IfcGeometricRepresentationContext.h"
#include "ifc2x3/IfcGeometricRepresentationItem.h"
#include "ifc2x3/IfcGeometricRepresentationSubContext.h"
#include "ifc2x3/IfcGeometricSet.h"
#include "ifc2x3/IfcGeometricSetSelect.h"
#include "ifc2x3/IfcGrid.h"
#include "ifc2x3/IfcGridAxis.h"
#include "ifc2x3/IfcGridPlacement.h"
#include "ifc2x3/IfcGroup.h"
#include "ifc2x3/IfcHalfSpaceSolid.h"
#include "ifc2x3/IfcHatchLineDistanceSelect.h"
#include "ifc2x3/IfcHeatExchangerType.h"
#include "ifc2x3/IfcHumidifierType.h"
#include "ifc2x3/IfcHygroscopicMaterialProperties.h"
#include "ifc2x3/IfcIShapeProfileDef.h"
#include "ifc2x3/IfcImageTexture.h"
#include "ifc2x3/IfcInventory.h"
#include "ifc2x3/IfcIrregularTimeSeries.h"
#include "ifc2x3/IfcIrregularTimeSeriesValue.h"
#include "ifc2x3/IfcJunctionBoxType.h"
#include "ifc2x3/IfcLShapeProfileDef.h"
#include "ifc2x3/IfcLaborResource.h"
#include "ifc2x3/IfcLampType.h"
#include "ifc2x3/IfcLayeredItem.h"
#include "ifc2x3/IfcLibraryInformation.h"
#include "ifc2x3/IfcLibraryReference.h"
#include "ifc2x3/IfcLibrarySelect.h"
#include "ifc2x3/IfcLightDistributionData.h"
#include "ifc2x3/IfcLightDistributionDataSourceSelect.h"
#include "ifc2x3/IfcLightFixtureType.h"
#include "ifc2x3/IfcLightIntensityDistribution.h"
#include "ifc2x3/IfcLightSource.h"
#include "ifc2x3/IfcLightSourceAmbient.h"
#include "ifc2x3/IfcLightSourceDirectional.h"
#include "ifc2x3/IfcLightSourceGoniometric.h"
#include "ifc2x3/IfcLightSourcePositional.h"
#include "ifc2x3/IfcLightSourceSpot.h"
#include "ifc2x3/IfcLine.h"
#include "ifc2x3/IfcLinearDimension.h"
#include "ifc2x3/IfcLocalPlacement.h"
#include "ifc2x3/IfcLocalTime.h"
#include "ifc2x3/IfcLoop.h"
#include "ifc2x3/IfcManifoldSolidBrep.h"
#include "ifc2x3/IfcMappedItem.h"
#include "ifc2x3/IfcMaterial.h"
#include "ifc2x3/IfcMaterialClassificationRelationship.h"
#include "ifc2x3/IfcMaterialDefinitionRepresentation.h"
#include "ifc2x3/IfcMaterialLayer.h"
#include "ifc2x3/IfcMaterialLayerSet.h"
#include "ifc2x3/IfcMaterialLayerSetUsage.h"
#include "ifc2x3/IfcMaterialList.h"
#include "ifc2x3/IfcMaterialProperties.h"
#include "ifc2x3/IfcMaterialSelect.h"
#include "ifc2x3/IfcMeasureValue.h"
#include "ifc2x3/IfcMeasureWithUnit.h"
#include "ifc2x3/IfcMechanicalConcreteMaterialProperties.h"
#include "ifc2x3/IfcMechanicalFastener.h"
#include "ifc2x3/IfcMechanicalFastenerType.h"
#include "ifc2x3/IfcMechanicalMaterialProperties.h"
#include "ifc2x3/IfcMechanicalSteelMaterialProperties.h"
#include "ifc2x3/IfcMember.h"
#include "ifc2x3/IfcMemberType.h"
#include "ifc2x3/IfcMetric.h"
#include "ifc2x3/IfcMetricValueSelect.h"
#include "ifc2x3/IfcMonetaryUnit.h"
#include "ifc2x3/IfcMotorConnectionType.h"
#include "ifc2x3/IfcMove.h"
#include "ifc2x3/IfcNamedUnit.h"
#include "ifc2x3/IfcObject.h"
#include "ifc2x3/IfcObjectDefinition.h"
#include "ifc2x3/IfcObjectPlacement.h"
#include "ifc2x3/IfcObjectReferenceSelect.h"
#include "ifc2x3/IfcObjective.h"
#include "ifc2x3/IfcOccupant.h"
#include "ifc2x3/IfcOffsetCurve2D.h"
#include "ifc2x3/IfcOffsetCurve3D.h"
#include "ifc2x3/IfcOneDirectionRepeatFactor.h"
#include "ifc2x3/IfcOpenShell.h"
#include "ifc2x3/IfcOpeningElement.h"
#include "ifc2x3/IfcOpticalMaterialProperties.h"
#include "ifc2x3/IfcOrderAction.h"
#include "ifc2x3/IfcOrganization.h"
#include "ifc2x3/IfcOrganizationRelationship.h"
#include "ifc2x3/IfcOrientationSelect.h"
#include "ifc2x3/IfcOrientedEdge.h"
#include "ifc2x3/IfcOutletType.h"
#include "ifc2x3/IfcOwnerHistory.h"
#include "ifc2x3/IfcParameterizedProfileDef.h"
#include "ifc2x3/IfcPath.h"
#include "ifc2x3/IfcPerformanceHistory.h"
#include "ifc2x3/IfcPermeableCoveringProperties.h"
#include "ifc2x3/IfcPermit.h"
#include "ifc2x3/IfcPerson.h"
#include "ifc2x3/IfcPersonAndOrganization.h"
#include "ifc2x3/IfcPhysicalComplexQuantity.h"
#include "ifc2x3/IfcPhysicalQuantity.h"
#include "ifc2x3/IfcPhysicalSimpleQuantity.h"
#include "ifc2x3/IfcPile.h"
#include "ifc2x3/IfcPipeFittingType.h"
#include "ifc2x3/IfcPipeSegmentType.h"
#include "ifc2x3/IfcPixelTexture.h"
#include "ifc2x3/IfcPlacement.h"
#include "ifc2x3/IfcPlanarBox.h"
#include "ifc2x3/IfcPlanarExtent.h"
#include "ifc2x3/IfcPlane.h"
#include "ifc2x3/IfcPlate.h"
#include "ifc2x3/IfcPlateType.h"
#include "ifc2x3/IfcPoint.h"
#include "ifc2x3/IfcPointOnCurve.h"
#include "ifc2x3/IfcPointOnSurface.h"
#include "ifc2x3/IfcPointOrVertexPoint.h"
#include "ifc2x3/IfcPolyLoop.h"
#include "ifc2x3/IfcPolygonalBoundedHalfSpace.h"
#include "ifc2x3/IfcPolyline.h"
#include "ifc2x3/IfcPort.h"
#include "ifc2x3/IfcPostalAddress.h"
#include "ifc2x3/IfcPreDefinedColour.h"
#include "ifc2x3/IfcPreDefinedCurveFont.h"
#include "ifc2x3/IfcPreDefinedDimensionSymbol.h"
#include "ifc2x3/IfcPreDefinedItem.h"
#include "ifc2x3/IfcPreDefinedPointMarkerSymbol.h"
#include "ifc2x3/IfcPreDefinedSymbol.h"
#include "ifc2x3/IfcPreDefinedTerminatorSymbol.h"
#include "ifc2x3/IfcPreDefinedTextFont.h"
#include "ifc2x3/IfcPresentationLayerAssignment.h"
#include "ifc2x3/IfcPresentationLayerWithStyle.h"
#include "ifc2x3/IfcPresentationStyle.h"
#include "ifc2x3/IfcPresentationStyleAssignment.h"
#include "ifc2x3/IfcPresentationStyleSelect.h"
#include "ifc2x3/IfcProcedure.h"
#include "ifc2x3/IfcProcess.h"
#include "ifc2x3/IfcProduct.h"
#include "ifc2x3/IfcProductDefinitionShape.h"
#include "ifc2x3/IfcProductRepresentation.h"
#include "ifc2x3/IfcProductsOfCombustionProperties.h"
#include "ifc2x3/IfcProfileDef.h"
#include "ifc2x3/IfcProfileProperties.h"
#include "ifc2x3/IfcProject.h"
#include "ifc2x3/IfcProjectOrder.h"
#include "ifc2x3/IfcProjectOrderRecord.h"
#include "ifc2x3/IfcProjectionCurve.h"
#include "ifc2x3/IfcProjectionElement.h"
#include "ifc2x3/IfcProperty.h"
#include "ifc2x3/IfcPropertyBoundedValue.h"
#include "ifc2x3/IfcPropertyConstraintRelationship.h"
#include "ifc2x3/IfcPropertyDefinition.h"
#include "ifc2x3/IfcPropertyDependencyRelationship.h"
#include "ifc2x3/IfcPropertyEnumeratedValue.h"
#include "ifc2x3/IfcPropertyEnumeration.h"
#include "ifc2x3/IfcPropertyListValue.h"
#include "ifc2x3/IfcPropertyReferenceValue.h"
#include "ifc2x3/IfcPropertySet.h"
#include "ifc2x3/IfcPropertySetDefinition.h"
#include "ifc2x3/IfcPropertySingleValue.h"
#include "ifc2x3/IfcPropertyTableValue.h"
#include "ifc2x3/IfcProtectiveDeviceType.h"
#include "ifc2x3/IfcProxy.h"
#include "ifc2x3/IfcPumpType.h"
#include "ifc2x3/IfcQuantityArea.h"
#include "ifc2x3/IfcQuantityCount.h"
#include "ifc2x3/IfcQuantityLength.h"
#include "ifc2x3/IfcQuantityTime.h"
#include "ifc2x3/IfcQuantityVolume.h"
#include "ifc2x3/IfcQuantityWeight.h"
#include "ifc2x3/IfcRadiusDimension.h"
#include "ifc2x3/IfcRailing.h"
#include "ifc2x3/IfcRailingType.h"
#include "ifc2x3/IfcRamp.h"
#include "ifc2x3/IfcRampFlight.h"
#include "ifc2x3/IfcRampFlightType.h"
#include "ifc2x3/IfcRationalBezierCurve.h"
#include "ifc2x3/IfcRectangleHollowProfileDef.h"
#include "ifc2x3/IfcRectangleProfileDef.h"
#include "ifc2x3/IfcRectangularPyramid.h"
#include "ifc2x3/IfcRectangularTrimmedSurface.h"
#include "ifc2x3/IfcReferencesValueDocument.h"
#include "ifc2x3/IfcRegularTimeSeries.h"
#include "ifc2x3/IfcReinforcementBarProperties.h"
#include "ifc2x3/IfcReinforcementDefinitionProperties.h"
#include "ifc2x3/IfcReinforcingBar.h"
#include "ifc2x3/IfcReinforcingElement.h"
#include "ifc2x3/IfcReinforcingMesh.h"
#include "ifc2x3/IfcRelAggregates.h"
#include "ifc2x3/IfcRelAssigns.h"
#include "ifc2x3/IfcRelAssignsTasks.h"
#include "ifc2x3/IfcRelAssignsToActor.h"
#include "ifc2x3/IfcRelAssignsToControl.h"
#include "ifc2x3/IfcRelAssignsToGroup.h"
#include "ifc2x3/IfcRelAssignsToProcess.h"
#include "ifc2x3/IfcRelAssignsToProduct.h"
#include "ifc2x3/IfcRelAssignsToProjectOrder.h"
#include "ifc2x3/IfcRelAssignsToResource.h"
#include "ifc2x3/IfcRelAssociates.h"
#include "ifc2x3/IfcRelAssociatesAppliedValue.h"
#include "ifc2x3/IfcRelAssociatesApproval.h"
#include "ifc2x3/IfcRelAssociatesClassification.h"
#include "ifc2x3/IfcRelAssociatesConstraint.h"
#include "ifc2x3/IfcRelAssociatesDocument.h"
#include "ifc2x3/IfcRelAssociatesLibrary.h"
#include "ifc2x3/IfcRelAssociatesMaterial.h"
#include "ifc2x3/IfcRelAssociatesProfileProperties.h"
#include "ifc2x3/IfcRelConnects.h"
#include "ifc2x3/IfcRelConnectsElements.h"
#include "ifc2x3/IfcRelConnectsPathElements.h"
#include "ifc2x3/IfcRelConnectsPortToElement.h"
#include "ifc2x3/IfcRelConnectsPorts.h"
#include "ifc2x3/IfcRelConnectsStructuralActivity.h"
#include "ifc2x3/IfcRelConnectsStructuralElement.h"
#include "ifc2x3/IfcRelConnectsStructuralMember.h"
#include "ifc2x3/IfcRelConnectsWithEccentricity.h"
#include "ifc2x3/IfcRelConnectsWithRealizingElements.h"
#include "ifc2x3/IfcRelContainedInSpatialStructure.h"
#include "ifc2x3/IfcRelCoversBldgElements.h"
#include "ifc2x3/IfcRelCoversSpaces.h"
#include "ifc2x3/IfcRelDecomposes.h"
#include "ifc2x3/IfcRelDefines.h"
#include "ifc2x3/IfcRelDefinesByProperties.h"
#include "ifc2x3/IfcRelDefinesByType.h"
#include "ifc2x3/IfcRelFillsElement.h"
#include "ifc2x3/IfcRelFlowControlElements.h"
#include "ifc2x3/IfcRelInteractionRequirements.h"
#include "ifc2x3/IfcRelNests.h"
#include "ifc2x3/IfcRelOccupiesSpaces.h"
#include "ifc2x3/IfcRelOverridesProperties.h"
#include "ifc2x3/IfcRelProjectsElement.h"
#include "ifc2x3/IfcRelReferencedInSpatialStructure.h"
#include "ifc2x3/IfcRelSchedulesCostItems.h"
#include "ifc2x3/IfcRelSequence.h"
#include "ifc2x3/IfcRelServicesBuildings.h"
#include "ifc2x3/IfcRelSpaceBoundary.h"
#include "ifc2x3/IfcRelVoidsElement.h"
#include "ifc2x3/IfcRelationship.h"
#include "ifc2x3/IfcRelaxation.h"
#include "ifc2x3/IfcRepresentation.h"
#include "ifc2x3/IfcRepresentationContext.h"
#include "ifc2x3/IfcRepresentationItem.h"
#include "ifc2x3/IfcRepresentationMap.h"
#include "ifc2x3/IfcResource.h"
#include "ifc2x3/IfcRevolvedAreaSolid.h"
#include "ifc2x3/IfcRibPlateProfileProperties.h"
#include "ifc2x3/IfcRightCircularCone.h"
#include "ifc2x3/IfcRightCircularCylinder.h"
#include "ifc2x3/IfcRoof.h"
#include "ifc2x3/IfcRoot.h"
#include "ifc2x3/IfcRoundedEdgeFeature.h"
#include "ifc2x3/IfcRoundedRectangleProfileDef.h"
#include "ifc2x3/IfcSIUnit.h"
#include "ifc2x3/IfcSanitaryTerminalType.h"
#include "ifc2x3/IfcScheduleTimeControl.h"
#include "ifc2x3/IfcSectionProperties.h"
#include "ifc2x3/IfcSectionReinforcementProperties.h"
#include "ifc2x3/IfcSectionedSpine.h"
#include "ifc2x3/IfcSensorType.h"
#include "ifc2x3/IfcServiceLife.h"
#include "ifc2x3/IfcServiceLifeFactor.h"
#include "ifc2x3/IfcShapeAspect.h"
#include "ifc2x3/IfcShapeModel.h"
#include "ifc2x3/IfcShapeRepresentation.h"
#include "ifc2x3/IfcShell.h"
#include "ifc2x3/IfcShellBasedSurfaceModel.h"
#include "ifc2x3/IfcSimpleProperty.h"
#include "ifc2x3/IfcSimpleValue.h"
#include "ifc2x3/IfcSite.h"
#include "ifc2x3/IfcSizeSelect.h"
#include "ifc2x3/IfcSlab.h"
#include "ifc2x3/IfcSlabType.h"
#include "ifc2x3/IfcSlippageConnectionCondition.h"
#include "ifc2x3/IfcSolidModel.h"
#include "ifc2x3/IfcSoundProperties.h"
#include "ifc2x3/IfcSoundValue.h"
#include "ifc2x3/IfcSpace.h"
#include "ifc2x3/IfcSpaceHeaterType.h"
#include "ifc2x3/IfcSpaceProgram.h"
#include "ifc2x3/IfcSpaceThermalLoadProperties.h"
#include "ifc2x3/IfcSpaceType.h"
#include "ifc2x3/IfcSpatialStructureElement.h"
#include "ifc2x3/IfcSpatialStructureElementType.h"
#include "ifc2x3/IfcSpecularHighlightSelect.h"
#include "ifc2x3/IfcSphere.h"
#include "ifc2x3/IfcStackTerminalType.h"
#include "ifc2x3/IfcStair.h"
#include "ifc2x3/IfcStairFlight.h"
#include "ifc2x3/IfcStairFlightType.h"
#include "ifc2x3/IfcStructuralAction.h"
#include "ifc2x3/IfcStructuralActivity.h"
#include "ifc2x3/IfcStructuralActivityAssignmentSelect.h"
#include "ifc2x3/IfcStructuralAnalysisModel.h"
#include "ifc2x3/IfcStructuralConnection.h"
#include "ifc2x3/IfcStructuralConnectionCondition.h"
#include "ifc2x3/IfcStructuralCurveConnection.h"
#include "ifc2x3/IfcStructuralCurveMember.h"
#include "ifc2x3/IfcStructuralCurveMemberVarying.h"
#include "ifc2x3/IfcStructuralItem.h"
#include "ifc2x3/IfcStructuralLinearAction.h"
#include "ifc2x3/IfcStructuralLinearActionVarying.h"
#include "ifc2x3/IfcStructuralLoad.h"
#include "ifc2x3/IfcStructuralLoadGroup.h"
#include "ifc2x3/IfcStructuralLoadLinearForce.h"
#include "ifc2x3/IfcStructuralLoadPlanarForce.h"
#include "ifc2x3/IfcStructuralLoadSingleDisplacement.h"
#include "ifc2x3/IfcStructuralLoadSingleDisplacementDistortion.h"
#include "ifc2x3/IfcStructuralLoadSingleForce.h"
#include "ifc2x3/IfcStructuralLoadSingleForceWarping.h"
#include "ifc2x3/IfcStructuralLoadStatic.h"
#include "ifc2x3/IfcStructuralLoadTemperature.h"
#include "ifc2x3/IfcStructuralMember.h"
#include "ifc2x3/IfcStructuralPlanarAction.h"
#include "ifc2x3/IfcStructuralPlanarActionVarying.h"
#include "ifc2x3/IfcStructuralPointAction.h"
#include "ifc2x3/IfcStructuralPointConnection.h"
#include "ifc2x3/IfcStructuralPointReaction.h"
#include "ifc2x3/IfcStructuralProfileProperties.h"
#include "ifc2x3/IfcStructuralReaction.h"
#include "ifc2x3/IfcStructuralResultGroup.h"
#include "ifc2x3/IfcStructuralSteelProfileProperties.h"
#include "ifc2x3/IfcStructuralSurfaceConnection.h"
#include "ifc2x3/IfcStructuralSurfaceMember.h"
#include "ifc2x3/IfcStructuralSurfaceMemberVarying.h"
#include "ifc2x3/IfcStructuredDimensionCallout.h"
#include "ifc2x3/IfcStyleModel.h"
#include "ifc2x3/IfcStyledItem.h"
#include "ifc2x3/IfcStyledRepresentation.h"
#include "ifc2x3/IfcSubContractResource.h"
#include "ifc2x3/IfcSubedge.h"
#include "ifc2x3/IfcSurface.h"
#include "ifc2x3/IfcSurfaceCurveSweptAreaSolid.h"
#include "ifc2x3/IfcSurfaceOfLinearExtrusion.h"
#include "ifc2x3/IfcSurfaceOfRevolution.h"
#include "ifc2x3/IfcSurfaceOrFaceSurface.h"
#include "ifc2x3/IfcSurfaceStyle.h"
#include "ifc2x3/IfcSurfaceStyleElementSelect.h"
#include "ifc2x3/IfcSurfaceStyleLighting.h"
#include "ifc2x3/IfcSurfaceStyleRefraction.h"
#include "ifc2x3/IfcSurfaceStyleRendering.h"
#include "ifc2x3/IfcSurfaceStyleShading.h"
#include "ifc2x3/IfcSurfaceStyleWithTextures.h"
#include "ifc2x3/IfcSurfaceTexture.h"
#include "ifc2x3/IfcSweptAreaSolid.h"
#include "ifc2x3/IfcSweptDiskSolid.h"
#include "ifc2x3/IfcSweptSurface.h"
#include "ifc2x3/IfcSwitchingDeviceType.h"
#include "ifc2x3/IfcSymbolStyle.h"
#include "ifc2x3/IfcSymbolStyleSelect.h"
#include "ifc2x3/IfcSystem.h"
#include "ifc2x3/IfcSystemFurnitureElementType.h"
#include "ifc2x3/IfcTShapeProfileDef.h"
#include "ifc2x3/IfcTable.h"
#include "ifc2x3/IfcTableRow.h"
#include "ifc2x3/IfcTankType.h"
#include "ifc2x3/IfcTask.h"
#include "ifc2x3/IfcTelecomAddress.h"
#include "ifc2x3/IfcTendon.h"
#include "ifc2x3/IfcTendonAnchor.h"
#include "ifc2x3/IfcTerminatorSymbol.h"
#include "ifc2x3/IfcTextFontSelect.h"
#include "ifc2x3/IfcTextLiteral.h"
#include "ifc2x3/IfcTextLiteralWithExtent.h"
#include "ifc2x3/IfcTextStyle.h"
#include "ifc2x3/IfcTextStyleFontModel.h"
#include "ifc2x3/IfcTextStyleForDefinedFont.h"
#include "ifc2x3/IfcTextStyleSelect.h"
#include "ifc2x3/IfcTextStyleTextModel.h"
#include "ifc2x3/IfcTextStyleWithBoxCharacteristics.h"
#include "ifc2x3/IfcTextureCoordinate.h"
#include "ifc2x3/IfcTextureCoordinateGenerator.h"
#include "ifc2x3/IfcTextureMap.h"
#include "ifc2x3/IfcTextureVertex.h"
#include "ifc2x3/IfcThermalMaterialProperties.h"
#include "ifc2x3/IfcTimeSeries.h"
#include "ifc2x3/IfcTimeSeriesReferenceRelationship.h"
#include "ifc2x3/IfcTimeSeriesSchedule.h"
#include "ifc2x3/IfcTimeSeriesValue.h"
#include "ifc2x3/IfcTopologicalRepresentationItem.h"
#include "ifc2x3/IfcTopologyRepresentation.h"
#include "ifc2x3/IfcTransformerType.h"
#include "ifc2x3/IfcTransportElement.h"
#include "ifc2x3/IfcTransportElementType.h"
#include "ifc2x3/IfcTrapeziumProfileDef.h"
#include "ifc2x3/IfcTrimmedCurve.h"
#include "ifc2x3/IfcTrimmingSelect.h"
#include "ifc2x3/IfcTubeBundleType.h"
#include "ifc2x3/IfcTwoDirectionRepeatFactor.h"
#include "ifc2x3/IfcTypeObject.h"
#include "ifc2x3/IfcTypeProduct.h"
#include "ifc2x3/IfcUShapeProfileDef.h"
#include "ifc2x3/IfcUnit.h"
#include "ifc2x3/IfcUnitAssignment.h"
#include "ifc2x3/IfcUnitaryEquipmentType.h"
#include "ifc2x3/IfcValue.h"
#include "ifc2x3/IfcValveType.h"
#include "ifc2x3/IfcVector.h"
#include "ifc2x3/IfcVertex.h"
#include "ifc2x3/IfcVertexBasedTextureMap.h"
#include "ifc2x3/IfcVertexLoop.h"
#include "ifc2x3/IfcVertexPoint.h"
#include "ifc2x3/IfcVibrationIsolatorType.h"
#include "ifc2x3/IfcVirtualElement.h"
#include "ifc2x3/IfcVirtualGridIntersection.h"
#include "ifc2x3/IfcWall.h"
#include "ifc2x3/IfcWallStandardCase.h"
#include "ifc2x3/IfcWallType.h"
#include "ifc2x3/IfcWasteTerminalType.h"
#include "ifc2x3/IfcWaterProperties.h"
#include "ifc2x3/IfcWindow.h"
#include "ifc2x3/IfcWindowLiningProperties.h"
#include "ifc2x3/IfcWindowPanelProperties.h"
#include "ifc2x3/IfcWindowStyle.h"
#include "ifc2x3/IfcWorkControl.h"
#include "ifc2x3/IfcWorkPlan.h"
#include "ifc2x3/IfcWorkSchedule.h"
#include "ifc2x3/IfcZShapeProfileDef.h"
#include "ifc2x3/IfcZone.h"
#include <Step/Aggregation.h>
#include <Step/BaseEntity.h>
#include <Step/String.h>
#include <vector>

using namespace ifc2x3;

SPFWriter::SPFWriter(ExpressDataSet *expressDataSet) : Step::BaseSPFWriter(expressDataSet) {
}

SPFWriter::~SPFWriter() {
}

bool SPFWriter::writeSPF(const std::string &filepath) {
    Step::MapOfEntities &mapOfEntities = m_expressDataSet->getAll();
    Step::MapOfEntities::iterator it_map = mapOfEntities.begin();
    std::vector< Step::BaseEntity * > vectorOfEntities(mapOfEntities.size());
    std::vector< Step::BaseEntity * >::iterator it_vector = vectorOfEntities.begin();
    if (!init(filepath)) {
        return false;
    }
    writeHeader();
    m_expressDataSet->instantiateAll();
    while (it_map != mapOfEntities.end()) {
        (*it_vector) = (*it_map).second.get();
        ++it_map;
        ++it_vector;
    }
    std::sort(vectorOfEntities.begin(), vectorOfEntities.end(), Step::keySort);
    it_vector = vectorOfEntities.begin();
    while (it_vector != vectorOfEntities.end()) {
        (*it_vector)->acceptVisitor(this);
        ++it_vector;
    }
    writeEnder();
    return true;
}

bool SPFWriter::visitIfc2DCompositeCurve(Ifc2DCompositeCurve *value) {
    m_out << "#" << value->getKey() << "=IFC2DCOMPOSITECURVE(";
    if (Step::isUnset(value->getSegments())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCompositeCurveSegment_1_n::iterator step_it0 = (value->getSegments()).begin();
            if ((value->getSegments()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSegments()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcActionRequest(IfcActionRequest *value) {
    m_out << "#" << value->getKey() << "=IFCACTIONREQUEST(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRequestID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRequestID());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcActorSelect(IfcActorSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcActorSelect::IFCORGANIZATION:
        writeAttribute(selectData->getIfcOrganization());
        break;
    case IfcActorSelect::IFCPERSON:
        writeAttribute(selectData->getIfcPerson());
        break;
    case IfcActorSelect::IFCPERSONANDORGANIZATION:
        writeAttribute(selectData->getIfcPersonAndOrganization());
        break;
        }
}

bool SPFWriter::visitIfcActor(IfcActor *value) {
    m_out << "#" << value->getKey() << "=IFCACTOR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTheActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getTheActor());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRoleEnum(IfcRoleEnum enumData) {
    switch(enumData) {
    case IfcRoleEnum_SUPPLIER:
        m_out << ".SUPPLIER.";
        break;
    case IfcRoleEnum_MANUFACTURER:
        m_out << ".MANUFACTURER.";
        break;
    case IfcRoleEnum_CONTRACTOR:
        m_out << ".CONTRACTOR.";
        break;
    case IfcRoleEnum_SUBCONTRACTOR:
        m_out << ".SUBCONTRACTOR.";
        break;
    case IfcRoleEnum_ARCHITECT:
        m_out << ".ARCHITECT.";
        break;
    case IfcRoleEnum_STRUCTURALENGINEER:
        m_out << ".STRUCTURALENGINEER.";
        break;
    case IfcRoleEnum_COSTENGINEER:
        m_out << ".COSTENGINEER.";
        break;
    case IfcRoleEnum_CLIENT:
        m_out << ".CLIENT.";
        break;
    case IfcRoleEnum_BUILDINGOWNER:
        m_out << ".BUILDINGOWNER.";
        break;
    case IfcRoleEnum_BUILDINGOPERATOR:
        m_out << ".BUILDINGOPERATOR.";
        break;
    case IfcRoleEnum_MECHANICALENGINEER:
        m_out << ".MECHANICALENGINEER.";
        break;
    case IfcRoleEnum_ELECTRICALENGINEER:
        m_out << ".ELECTRICALENGINEER.";
        break;
    case IfcRoleEnum_PROJECTMANAGER:
        m_out << ".PROJECTMANAGER.";
        break;
    case IfcRoleEnum_FACILITIESMANAGER:
        m_out << ".FACILITIESMANAGER.";
        break;
    case IfcRoleEnum_CIVILENGINEER:
        m_out << ".CIVILENGINEER.";
        break;
    case IfcRoleEnum_COMISSIONINGENGINEER:
        m_out << ".COMISSIONINGENGINEER.";
        break;
    case IfcRoleEnum_ENGINEER:
        m_out << ".ENGINEER.";
        break;
    case IfcRoleEnum_OWNER:
        m_out << ".OWNER.";
        break;
    case IfcRoleEnum_CONSULTANT:
        m_out << ".CONSULTANT.";
        break;
    case IfcRoleEnum_CONSTRUCTIONMANAGER:
        m_out << ".CONSTRUCTIONMANAGER.";
        break;
    case IfcRoleEnum_FIELDCONSTRUCTIONMANAGER:
        m_out << ".FIELDCONSTRUCTIONMANAGER.";
        break;
    case IfcRoleEnum_RESELLER:
        m_out << ".RESELLER.";
        break;
    case IfcRoleEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcActorRole(IfcActorRole *value) {
    m_out << "#" << value->getKey() << "=IFCACTORROLE(";
    if (Step::isUnsetEnum(value->getRole())) {
        m_out << "$";
    }
    else {
        writeIfcRoleEnum(value->getRole());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedRole())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedRole());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcActuatorTypeEnum(IfcActuatorTypeEnum enumData) {
    switch(enumData) {
    case IfcActuatorTypeEnum_ELECTRICACTUATOR:
        m_out << ".ELECTRICACTUATOR.";
        break;
    case IfcActuatorTypeEnum_HANDOPERATEDACTUATOR:
        m_out << ".HANDOPERATEDACTUATOR.";
        break;
    case IfcActuatorTypeEnum_HYDRAULICACTUATOR:
        m_out << ".HYDRAULICACTUATOR.";
        break;
    case IfcActuatorTypeEnum_PNEUMATICACTUATOR:
        m_out << ".PNEUMATICACTUATOR.";
        break;
    case IfcActuatorTypeEnum_THERMOSTATICACTUATOR:
        m_out << ".THERMOSTATICACTUATOR.";
        break;
    case IfcActuatorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcActuatorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcActuatorType(IfcActuatorType *value) {
    m_out << "#" << value->getKey() << "=IFCACTUATORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcActuatorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAddressTypeEnum(IfcAddressTypeEnum enumData) {
    switch(enumData) {
    case IfcAddressTypeEnum_OFFICE:
        m_out << ".OFFICE.";
        break;
    case IfcAddressTypeEnum_SITE:
        m_out << ".SITE.";
        break;
    case IfcAddressTypeEnum_HOME:
        m_out << ".HOME.";
        break;
    case IfcAddressTypeEnum_DISTRIBUTIONPOINT:
        m_out << ".DISTRIBUTIONPOINT.";
        break;
    case IfcAddressTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcAddress(IfcAddress *value) {
    m_out << "#" << value->getKey() << "=IFCADDRESS(";
    if (Step::isUnsetEnum(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeIfcAddressTypeEnum(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedPurpose());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAirTerminalBoxTypeEnum(IfcAirTerminalBoxTypeEnum enumData) {
    switch(enumData) {
    case IfcAirTerminalBoxTypeEnum_CONSTANTFLOW:
        m_out << ".CONSTANTFLOW.";
        break;
    case IfcAirTerminalBoxTypeEnum_VARIABLEFLOWPRESSUREDEPENDANT:
        m_out << ".VARIABLEFLOWPRESSUREDEPENDANT.";
        break;
    case IfcAirTerminalBoxTypeEnum_VARIABLEFLOWPRESSUREINDEPENDANT:
        m_out << ".VARIABLEFLOWPRESSUREINDEPENDANT.";
        break;
    case IfcAirTerminalBoxTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAirTerminalBoxTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcAirTerminalBoxType(IfcAirTerminalBoxType *value) {
    m_out << "#" << value->getKey() << "=IFCAIRTERMINALBOXTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcAirTerminalBoxTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAirTerminalTypeEnum(IfcAirTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcAirTerminalTypeEnum_GRILLE:
        m_out << ".GRILLE.";
        break;
    case IfcAirTerminalTypeEnum_REGISTER:
        m_out << ".REGISTER.";
        break;
    case IfcAirTerminalTypeEnum_DIFFUSER:
        m_out << ".DIFFUSER.";
        break;
    case IfcAirTerminalTypeEnum_EYEBALL:
        m_out << ".EYEBALL.";
        break;
    case IfcAirTerminalTypeEnum_IRIS:
        m_out << ".IRIS.";
        break;
    case IfcAirTerminalTypeEnum_LINEARGRILLE:
        m_out << ".LINEARGRILLE.";
        break;
    case IfcAirTerminalTypeEnum_LINEARDIFFUSER:
        m_out << ".LINEARDIFFUSER.";
        break;
    case IfcAirTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAirTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcAirTerminalType(IfcAirTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCAIRTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcAirTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAirToAirHeatRecoveryTypeEnum(IfcAirToAirHeatRecoveryTypeEnum enumData) {
    switch(enumData) {
    case IfcAirToAirHeatRecoveryTypeEnum_FIXEDPLATECOUNTERFLOWEXCHANGER:
        m_out << ".FIXEDPLATECOUNTERFLOWEXCHANGER.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_FIXEDPLATECROSSFLOWEXCHANGER:
        m_out << ".FIXEDPLATECROSSFLOWEXCHANGER.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_FIXEDPLATEPARALLELFLOWEXCHANGER:
        m_out << ".FIXEDPLATEPARALLELFLOWEXCHANGER.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_ROTARYWHEEL:
        m_out << ".ROTARYWHEEL.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_RUNAROUNDCOILLOOP:
        m_out << ".RUNAROUNDCOILLOOP.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_HEATPIPE:
        m_out << ".HEATPIPE.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_TWINTOWERENTHALPYRECOVERYLOOPS:
        m_out << ".TWINTOWERENTHALPYRECOVERYLOOPS.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS:
        m_out << ".THERMOSIPHONSEALEDTUBEHEATEXCHANGERS.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_THERMOSIPHONCOILTYPEHEATEXCHANGERS:
        m_out << ".THERMOSIPHONCOILTYPEHEATEXCHANGERS.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAirToAirHeatRecoveryTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcAirToAirHeatRecoveryType(IfcAirToAirHeatRecoveryType *value) {
    m_out << "#" << value->getKey() << "=IFCAIRTOAIRHEATRECOVERYTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcAirToAirHeatRecoveryTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAlarmTypeEnum(IfcAlarmTypeEnum enumData) {
    switch(enumData) {
    case IfcAlarmTypeEnum_BELL:
        m_out << ".BELL.";
        break;
    case IfcAlarmTypeEnum_BREAKGLASSBUTTON:
        m_out << ".BREAKGLASSBUTTON.";
        break;
    case IfcAlarmTypeEnum_LIGHT:
        m_out << ".LIGHT.";
        break;
    case IfcAlarmTypeEnum_MANUALPULLBOX:
        m_out << ".MANUALPULLBOX.";
        break;
    case IfcAlarmTypeEnum_SIREN:
        m_out << ".SIREN.";
        break;
    case IfcAlarmTypeEnum_WHISTLE:
        m_out << ".WHISTLE.";
        break;
    case IfcAlarmTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAlarmTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcAlarmType(IfcAlarmType *value) {
    m_out << "#" << value->getKey() << "=IFCALARMTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcAlarmTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDraughtingCalloutElement(IfcDraughtingCalloutElement *selectData) {
    switch(selectData->currentType()) {
    case IfcDraughtingCalloutElement::IFCANNOTATIONCURVEOCCURRENCE:
        writeAttribute(selectData->getIfcAnnotationCurveOccurrence());
        break;
    case IfcDraughtingCalloutElement::IFCANNOTATIONTEXTOCCURRENCE:
        writeAttribute(selectData->getIfcAnnotationTextOccurrence());
        break;
    case IfcDraughtingCalloutElement::IFCANNOTATIONSYMBOLOCCURRENCE:
        writeAttribute(selectData->getIfcAnnotationSymbolOccurrence());
        break;
        }
}

bool SPFWriter::visitIfcAngularDimension(IfcAngularDimension *value) {
    m_out << "#" << value->getKey() << "=IFCANGULARDIMENSION(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotation(IfcAnnotation *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationCurveOccurrence(IfcAnnotationCurveOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONCURVEOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationFillArea(IfcAnnotationFillArea *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONFILLAREA(";
    if (Step::isUnset(value->getOuterBoundary())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuterBoundary());
    }
    m_out << ",";
    if (Step::isUnset(value->getInnerBoundaries())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcCurve_1_n::iterator step_it0 = (value->getInnerBoundaries()).begin();
            if ((value->getInnerBoundaries()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getInnerBoundaries()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcGlobalOrLocalEnum(IfcGlobalOrLocalEnum enumData) {
    switch(enumData) {
    case IfcGlobalOrLocalEnum_GLOBAL_COORDS:
        m_out << ".GLOBAL_COORDS.";
        break;
    case IfcGlobalOrLocalEnum_LOCAL_COORDS:
        m_out << ".LOCAL_COORDS.";
        break;
        }
}

bool SPFWriter::visitIfcAnnotationFillAreaOccurrence(IfcAnnotationFillAreaOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONFILLAREAOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getFillStyleTarget())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFillStyleTarget());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationOccurrence(IfcAnnotationOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationSurface(IfcAnnotationSurface *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONSURFACE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextureCoordinates())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextureCoordinates());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationSurfaceOccurrence(IfcAnnotationSurfaceOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONSURFACEOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationSymbolOccurrence(IfcAnnotationSymbolOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONSYMBOLOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAnnotationTextOccurrence(IfcAnnotationTextOccurrence *value) {
    m_out << "#" << value->getKey() << "=IFCANNOTATIONTEXTOCCURRENCE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcApplication(IfcApplication *value) {
    m_out << "#" << value->getKey() << "=IFCAPPLICATION(";
    if (Step::isUnset(value->getApplicationDeveloper())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicationDeveloper());
    }
    m_out << ",";
    if (Step::isUnset(value->getVersion())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVersion());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicationFullName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicationFullName());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicationIdentifier());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAppliedValueSelect(IfcAppliedValueSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcAppliedValueSelect::IFCRATIOMEASURE:
        m_out << "IFCRATIOMEASURE(";
        writeAttribute(selectData->getIfcRatioMeasure());
        m_out << ")";
        break;
    case IfcAppliedValueSelect::IFCMEASUREWITHUNIT:
        writeAttribute(selectData->getIfcMeasureWithUnit());
        break;
    case IfcAppliedValueSelect::IFCMONETARYMEASURE:
        m_out << "IFCMONETARYMEASURE(";
        writeAttribute(selectData->getIfcMonetaryMeasure());
        m_out << ")";
        break;
        }
}

void SPFWriter::writeIfcDateTimeSelect(IfcDateTimeSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcDateTimeSelect::IFCCALENDARDATE:
        writeAttribute(selectData->getIfcCalendarDate());
        break;
    case IfcDateTimeSelect::IFCLOCALTIME:
        writeAttribute(selectData->getIfcLocalTime());
        break;
    case IfcDateTimeSelect::IFCDATEANDTIME:
        writeAttribute(selectData->getIfcDateAndTime());
        break;
        }
}

bool SPFWriter::visitIfcAppliedValue(IfcAppliedValue *value) {
    m_out << "#" << value->getKey() << "=IFCAPPLIEDVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedValue())) {
        m_out << "$";
    }
    else {
        writeIfcAppliedValueSelect(value->getAppliedValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnitBasis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnitBasis());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getApplicableDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getFixedUntilDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFixedUntilDate());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcArithmeticOperatorEnum(IfcArithmeticOperatorEnum enumData) {
    switch(enumData) {
    case IfcArithmeticOperatorEnum_ADD:
        m_out << ".ADD.";
        break;
    case IfcArithmeticOperatorEnum_DIVIDE:
        m_out << ".DIVIDE.";
        break;
    case IfcArithmeticOperatorEnum_MULTIPLY:
        m_out << ".MULTIPLY.";
        break;
    case IfcArithmeticOperatorEnum_SUBTRACT:
        m_out << ".SUBTRACT.";
        break;
        }
}

bool SPFWriter::visitIfcAppliedValueRelationship(IfcAppliedValueRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCAPPLIEDVALUERELATIONSHIP(";
    if (Step::isUnset(value->getComponentOfTotal())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getComponentOfTotal());
    }
    m_out << ",";
    if (Step::isUnset(value->getComponents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcAppliedValue_1_n::iterator step_it0 = (value->getComponents()).begin();
            if ((value->getComponents()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getComponents()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getArithmeticOperator())) {
        m_out << "$";
    }
    else {
        writeIfcArithmeticOperatorEnum(value->getArithmeticOperator());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcApproval(IfcApproval *value) {
    m_out << "#" << value->getKey() << "=IFCAPPROVAL(";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApprovalDateTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getApprovalDateTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getApprovalStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApprovalStatus());
    }
    m_out << ",";
    if (Step::isUnset(value->getApprovalLevel())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApprovalLevel());
    }
    m_out << ",";
    if (Step::isUnset(value->getApprovalQualifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApprovalQualifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcApprovalActorRelationship(IfcApprovalActorRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCAPPROVALACTORRELATIONSHIP(";
    if (Step::isUnset(value->getActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getApproval())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApproval());
    }
    m_out << ",";
    if (Step::isUnset(value->getRole())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRole());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcApprovalPropertyRelationship(IfcApprovalPropertyRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCAPPROVALPROPERTYRELATIONSHIP(";
    if (Step::isUnset(value->getApprovedProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getApprovedProperties()).begin();
            if ((value->getApprovedProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getApprovedProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getApproval())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApproval());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcApprovalRelationship(IfcApprovalRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCAPPROVALRELATIONSHIP(";
    if (Step::isUnset(value->getRelatedApproval())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedApproval());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingApproval())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingApproval());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProfileTypeEnum(IfcProfileTypeEnum enumData) {
    switch(enumData) {
    case IfcProfileTypeEnum_CURVE:
        m_out << ".CURVE.";
        break;
    case IfcProfileTypeEnum_AREA:
        m_out << ".AREA.";
        break;
        }
}

bool SPFWriter::visitIfcArbitraryClosedProfileDef(IfcArbitraryClosedProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCARBITRARYCLOSEDPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getOuterCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuterCurve());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcArbitraryOpenProfileDef(IfcArbitraryOpenProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCARBITRARYOPENPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCurve());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcArbitraryProfileDefWithVoids(IfcArbitraryProfileDefWithVoids *value) {
    m_out << "#" << value->getKey() << "=IFCARBITRARYPROFILEDEFWITHVOIDS(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getOuterCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuterCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getInnerCurves())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcCurve_1_n::iterator step_it0 = (value->getInnerCurves()).begin();
            if ((value->getInnerCurves()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getInnerCurves()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAsset(IfcAsset *value) {
    m_out << "#" << value->getKey() << "=IFCASSET(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getAssetID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAssetID());
    }
    m_out << ",";
    if (Step::isUnset(value->getOriginalValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOriginalValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurrentValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCurrentValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getTotalReplacementCost())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalReplacementCost());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwner())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getOwner());
    }
    m_out << ",";
    if (Step::isUnset(value->getUser())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getUser());
    }
    m_out << ",";
    if (Step::isUnset(value->getResponsiblePerson())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResponsiblePerson());
    }
    m_out << ",";
    if (Step::isUnset(value->getIncorporationDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIncorporationDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepreciatedValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepreciatedValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAsymmetricIShapeProfileDef(IfcAsymmetricIShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCASYMMETRICISHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getTopFlangeWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTopFlangeWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getTopFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTopFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getTopFlangeFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTopFlangeFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAxis1Placement(IfcAxis1Placement *value) {
    m_out << "#" << value->getKey() << "=IFCAXIS1PLACEMENT(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAxis2Placement2D(IfcAxis2Placement2D *value) {
    m_out << "#" << value->getKey() << "=IFCAXIS2PLACEMENT2D(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getRefDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRefDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcAxis2Placement3D(IfcAxis2Placement3D *value) {
    m_out << "#" << value->getKey() << "=IFCAXIS2PLACEMENT3D(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis());
    }
    m_out << ",";
    if (Step::isUnset(value->getRefDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRefDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBSplineCurveForm(IfcBSplineCurveForm enumData) {
    switch(enumData) {
    case IfcBSplineCurveForm_POLYLINE_FORM:
        m_out << ".POLYLINE_FORM.";
        break;
    case IfcBSplineCurveForm_CIRCULAR_ARC:
        m_out << ".CIRCULAR_ARC.";
        break;
    case IfcBSplineCurveForm_ELLIPTIC_ARC:
        m_out << ".ELLIPTIC_ARC.";
        break;
    case IfcBSplineCurveForm_PARABOLIC_ARC:
        m_out << ".PARABOLIC_ARC.";
        break;
    case IfcBSplineCurveForm_HYPERBOLIC_ARC:
        m_out << ".HYPERBOLIC_ARC.";
        break;
    case IfcBSplineCurveForm_UNSPECIFIED:
        m_out << ".UNSPECIFIED.";
        break;
        }
}

bool SPFWriter::visitIfcBSplineCurve(IfcBSplineCurve *value) {
    m_out << "#" << value->getKey() << "=IFCBSPLINECURVE(";
    if (Step::isUnset(value->getDegree())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDegree());
    }
    m_out << ",";
    if (Step::isUnset(value->getControlPointsList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_2_n::iterator step_it0 = (value->getControlPointsList()).begin();
            if ((value->getControlPointsList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getControlPointsList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCurveForm())) {
        m_out << "$";
    }
    else {
        writeIfcBSplineCurveForm(value->getCurveForm());
    }
    m_out << ",";
    if (Step::isUnset(value->getClosedCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getClosedCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBeam(IfcBeam *value) {
    m_out << "#" << value->getKey() << "=IFCBEAM(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBeamTypeEnum(IfcBeamTypeEnum enumData) {
    switch(enumData) {
    case IfcBeamTypeEnum_BEAM:
        m_out << ".BEAM.";
        break;
    case IfcBeamTypeEnum_JOIST:
        m_out << ".JOIST.";
        break;
    case IfcBeamTypeEnum_LINTEL:
        m_out << ".LINTEL.";
        break;
    case IfcBeamTypeEnum_T_BEAM:
        m_out << ".T_BEAM.";
        break;
    case IfcBeamTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcBeamTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcBeamType(IfcBeamType *value) {
    m_out << "#" << value->getKey() << "=IFCBEAMTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcBeamTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBezierCurve(IfcBezierCurve *value) {
    m_out << "#" << value->getKey() << "=IFCBEZIERCURVE(";
    if (Step::isUnset(value->getDegree())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDegree());
    }
    m_out << ",";
    if (Step::isUnset(value->getControlPointsList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_2_n::iterator step_it0 = (value->getControlPointsList()).begin();
            if ((value->getControlPointsList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getControlPointsList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCurveForm())) {
        m_out << "$";
    }
    else {
        writeIfcBSplineCurveForm(value->getCurveForm());
    }
    m_out << ",";
    if (Step::isUnset(value->getClosedCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getClosedCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSurfaceTextureEnum(IfcSurfaceTextureEnum enumData) {
    switch(enumData) {
    case IfcSurfaceTextureEnum_BUMP:
        m_out << ".BUMP.";
        break;
    case IfcSurfaceTextureEnum_OPACITY:
        m_out << ".OPACITY.";
        break;
    case IfcSurfaceTextureEnum_REFLECTION:
        m_out << ".REFLECTION.";
        break;
    case IfcSurfaceTextureEnum_SELFILLUMINATION:
        m_out << ".SELFILLUMINATION.";
        break;
    case IfcSurfaceTextureEnum_SHININESS:
        m_out << ".SHININESS.";
        break;
    case IfcSurfaceTextureEnum_SPECULAR:
        m_out << ".SPECULAR.";
        break;
    case IfcSurfaceTextureEnum_TEXTURE:
        m_out << ".TEXTURE.";
        break;
    case IfcSurfaceTextureEnum_TRANSPARENCYMAP:
        m_out << ".TRANSPARENCYMAP.";
        break;
    case IfcSurfaceTextureEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcBlobTexture(IfcBlobTexture *value) {
    m_out << "#" << value->getKey() << "=IFCBLOBTEXTURE(";
    if (Step::isUnset(value->getRepeatS())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatS());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepeatT())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatT());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTextureType())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceTextureEnum(value->getTextureType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextureTransform())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextureTransform());
    }
    m_out << ",";
    if (Step::isUnset(value->getRasterFormat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRasterFormat());
    }
    m_out << ",";
    if (Step::isUnset(value->getRasterCode())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRasterCode());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBlock(IfcBlock *value) {
    m_out << "#" << value->getKey() << "=IFCBLOCK(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getXLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getYLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getZLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getZLength());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBoilerTypeEnum(IfcBoilerTypeEnum enumData) {
    switch(enumData) {
    case IfcBoilerTypeEnum_WATER:
        m_out << ".WATER.";
        break;
    case IfcBoilerTypeEnum_STEAM:
        m_out << ".STEAM.";
        break;
    case IfcBoilerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcBoilerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcBoilerType(IfcBoilerType *value) {
    m_out << "#" << value->getKey() << "=IFCBOILERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcBoilerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBooleanOperator(IfcBooleanOperator enumData) {
    switch(enumData) {
    case IfcBooleanOperator_UNION:
        m_out << ".UNION.";
        break;
    case IfcBooleanOperator_INTERSECTION:
        m_out << ".INTERSECTION.";
        break;
    case IfcBooleanOperator_DIFFERENCE:
        m_out << ".DIFFERENCE.";
        break;
        }
}

void SPFWriter::writeIfcBooleanOperand(IfcBooleanOperand *selectData) {
    switch(selectData->currentType()) {
    case IfcBooleanOperand::IFCSOLIDMODEL:
        writeAttribute(selectData->getIfcSolidModel());
        break;
    case IfcBooleanOperand::IFCHALFSPACESOLID:
        writeAttribute(selectData->getIfcHalfSpaceSolid());
        break;
    case IfcBooleanOperand::IFCBOOLEANRESULT:
        writeAttribute(selectData->getIfcBooleanResult());
        break;
    case IfcBooleanOperand::IFCCSGPRIMITIVE3D:
        writeAttribute(selectData->getIfcCsgPrimitive3D());
        break;
        }
}

bool SPFWriter::visitIfcBooleanClippingResult(IfcBooleanClippingResult *value) {
    m_out << "#" << value->getKey() << "=IFCBOOLEANCLIPPINGRESULT(";
    if (Step::isUnsetEnum(value->getOperator())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperator(value->getOperator());
    }
    m_out << ",";
    if (Step::isUnset(value->getFirstOperand())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperand(value->getFirstOperand());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondOperand())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperand(value->getSecondOperand());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBooleanResult(IfcBooleanResult *value) {
    m_out << "#" << value->getKey() << "=IFCBOOLEANRESULT(";
    if (Step::isUnsetEnum(value->getOperator())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperator(value->getOperator());
    }
    m_out << ",";
    if (Step::isUnset(value->getFirstOperand())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperand(value->getFirstOperand());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondOperand())) {
        m_out << "$";
    }
    else {
        writeIfcBooleanOperand(value->getSecondOperand());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundaryCondition(IfcBoundaryCondition *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDARYCONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundaryEdgeCondition(IfcBoundaryEdgeCondition *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDARYEDGECONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByLengthX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByLengthX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByLengthY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByLengthY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByLengthZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByLengthZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessByLengthX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessByLengthX());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessByLengthY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessByLengthY());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessByLengthZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessByLengthZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundaryFaceCondition(IfcBoundaryFaceCondition *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDARYFACECONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByAreaX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByAreaX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByAreaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByAreaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessByAreaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessByAreaZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundaryNodeCondition(IfcBoundaryNodeCondition *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDARYNODECONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessX());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessY());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundaryNodeConditionWarping(IfcBoundaryNodeConditionWarping *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDARYNODECONDITIONWARPING(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearStiffnessZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearStiffnessZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessX());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessY());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalStiffnessZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalStiffnessZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getWarpingStiffness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWarpingStiffness());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundedCurve(IfcBoundedCurve *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDEDCURVE(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundedSurface(IfcBoundedSurface *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDEDSURFACE(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoundingBox(IfcBoundingBox *value) {
    m_out << "#" << value->getKey() << "=IFCBOUNDINGBOX(";
    if (Step::isUnset(value->getCorner())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCorner());
    }
    m_out << ",";
    if (Step::isUnset(value->getXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getYDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getZDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getZDim());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBoxedHalfSpace(IfcBoxedHalfSpace *value) {
    m_out << "#" << value->getKey() << "=IFCBOXEDHALFSPACE(";
    if (Step::isUnset(value->getBaseSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getAgreementFlag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAgreementFlag());
    }
    m_out << ",";
    if (Step::isUnset(value->getEnclosure())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEnclosure());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElementCompositionEnum(IfcElementCompositionEnum enumData) {
    switch(enumData) {
    case IfcElementCompositionEnum_COMPLEX:
        m_out << ".COMPLEX.";
        break;
    case IfcElementCompositionEnum_ELEMENT:
        m_out << ".ELEMENT.";
        break;
    case IfcElementCompositionEnum_PARTIAL:
        m_out << ".PARTIAL.";
        break;
        }
}

bool SPFWriter::visitIfcBuilding(IfcBuilding *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getElevationOfRefHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElevationOfRefHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getElevationOfTerrain())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElevationOfTerrain());
    }
    m_out << ",";
    if (Step::isUnset(value->getBuildingAddress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBuildingAddress());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingElement(IfcBuildingElement *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingElementComponent(IfcBuildingElementComponent *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENTCOMPONENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingElementPart(IfcBuildingElementPart *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENTPART(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingElementProxy(IfcBuildingElementProxy *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENTPROXY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBuildingElementProxyTypeEnum(IfcBuildingElementProxyTypeEnum enumData) {
    switch(enumData) {
    case IfcBuildingElementProxyTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcBuildingElementProxyTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcBuildingElementProxyType(IfcBuildingElementProxyType *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENTPROXYTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcBuildingElementProxyTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingElementType(IfcBuildingElementType *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcBuildingStorey(IfcBuildingStorey *value) {
    m_out << "#" << value->getKey() << "=IFCBUILDINGSTOREY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getElevation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElevation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCShapeProfileDef(IfcCShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWallThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWallThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getGirth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGirth());
    }
    m_out << ",";
    if (Step::isUnset(value->getInternalFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInternalFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInX());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCableCarrierFittingTypeEnum(IfcCableCarrierFittingTypeEnum enumData) {
    switch(enumData) {
    case IfcCableCarrierFittingTypeEnum_BEND:
        m_out << ".BEND.";
        break;
    case IfcCableCarrierFittingTypeEnum_CROSS:
        m_out << ".CROSS.";
        break;
    case IfcCableCarrierFittingTypeEnum_REDUCER:
        m_out << ".REDUCER.";
        break;
    case IfcCableCarrierFittingTypeEnum_TEE:
        m_out << ".TEE.";
        break;
    case IfcCableCarrierFittingTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCableCarrierFittingTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCableCarrierFittingType(IfcCableCarrierFittingType *value) {
    m_out << "#" << value->getKey() << "=IFCCABLECARRIERFITTINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCableCarrierFittingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCableCarrierSegmentTypeEnum(IfcCableCarrierSegmentTypeEnum enumData) {
    switch(enumData) {
    case IfcCableCarrierSegmentTypeEnum_CABLELADDERSEGMENT:
        m_out << ".CABLELADDERSEGMENT.";
        break;
    case IfcCableCarrierSegmentTypeEnum_CABLETRAYSEGMENT:
        m_out << ".CABLETRAYSEGMENT.";
        break;
    case IfcCableCarrierSegmentTypeEnum_CABLETRUNKINGSEGMENT:
        m_out << ".CABLETRUNKINGSEGMENT.";
        break;
    case IfcCableCarrierSegmentTypeEnum_CONDUITSEGMENT:
        m_out << ".CONDUITSEGMENT.";
        break;
    case IfcCableCarrierSegmentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCableCarrierSegmentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCableCarrierSegmentType(IfcCableCarrierSegmentType *value) {
    m_out << "#" << value->getKey() << "=IFCCABLECARRIERSEGMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCableCarrierSegmentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCableSegmentTypeEnum(IfcCableSegmentTypeEnum enumData) {
    switch(enumData) {
    case IfcCableSegmentTypeEnum_CABLESEGMENT:
        m_out << ".CABLESEGMENT.";
        break;
    case IfcCableSegmentTypeEnum_CONDUCTORSEGMENT:
        m_out << ".CONDUCTORSEGMENT.";
        break;
    case IfcCableSegmentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCableSegmentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCableSegmentType(IfcCableSegmentType *value) {
    m_out << "#" << value->getKey() << "=IFCCABLESEGMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCableSegmentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCalendarDate(IfcCalendarDate *value) {
    m_out << "#" << value->getKey() << "=IFCCALENDARDATE(";
    if (Step::isUnset(value->getDayComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDayComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getMonthComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMonthComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getYearComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYearComponent());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianPoint(IfcCartesianPoint *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANPOINT(";
    if (Step::isUnset(value->getCoordinates())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLengthMeasure_1_3::iterator step_it0 = (value->getCoordinates()).begin();
            if ((value->getCoordinates()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getCoordinates()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianTransformationOperator(IfcCartesianTransformationOperator *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANTRANSFORMATIONOPERATOR(";
    if (Step::isUnset(value->getAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis2());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocalOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocalOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianTransformationOperator2D(IfcCartesianTransformationOperator2D *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANTRANSFORMATIONOPERATOR2D(";
    if (Step::isUnset(value->getAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis2());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocalOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocalOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianTransformationOperator2DnonUniform(IfcCartesianTransformationOperator2DnonUniform *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM(";
    if (Step::isUnset(value->getAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis2());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocalOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocalOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale2());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianTransformationOperator3D(IfcCartesianTransformationOperator3D *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANTRANSFORMATIONOPERATOR3D(";
    if (Step::isUnset(value->getAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis2());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocalOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocalOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis3());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCartesianTransformationOperator3DnonUniform(IfcCartesianTransformationOperator3DnonUniform *value) {
    m_out << "#" << value->getKey() << "=IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM(";
    if (Step::isUnset(value->getAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis2());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocalOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocalOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis3());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale2());
    }
    m_out << ",";
    if (Step::isUnset(value->getScale3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScale3());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCenterLineProfileDef(IfcCenterLineProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCENTERLINEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThickness());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcChamferEdgeFeature(IfcChamferEdgeFeature *value) {
    m_out << "#" << value->getKey() << "=IFCCHAMFEREDGEFEATURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getFeatureLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFeatureLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeight());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcChillerTypeEnum(IfcChillerTypeEnum enumData) {
    switch(enumData) {
    case IfcChillerTypeEnum_AIRCOOLED:
        m_out << ".AIRCOOLED.";
        break;
    case IfcChillerTypeEnum_WATERCOOLED:
        m_out << ".WATERCOOLED.";
        break;
    case IfcChillerTypeEnum_HEATRECOVERY:
        m_out << ".HEATRECOVERY.";
        break;
    case IfcChillerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcChillerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcChillerType(IfcChillerType *value) {
    m_out << "#" << value->getKey() << "=IFCCHILLERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcChillerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAxis2Placement(IfcAxis2Placement *selectData) {
    switch(selectData->currentType()) {
    case IfcAxis2Placement::IFCAXIS2PLACEMENT2D:
        writeAttribute(selectData->getIfcAxis2Placement2D());
        break;
    case IfcAxis2Placement::IFCAXIS2PLACEMENT3D:
        writeAttribute(selectData->getIfcAxis2Placement3D());
        break;
        }
}

bool SPFWriter::visitIfcCircle(IfcCircle *value) {
    m_out << "#" << value->getKey() << "=IFCCIRCLE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCircleHollowProfileDef(IfcCircleHollowProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCIRCLEHOLLOWPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getWallThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWallThickness());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCircleProfileDef(IfcCircleProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCIRCLEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassification(IfcClassification *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATION(";
    if (Step::isUnset(value->getSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdition());
    }
    m_out << ",";
    if (Step::isUnset(value->getEditionDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEditionDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassificationItem(IfcClassificationItem *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATIONITEM(";
    if (Step::isUnset(value->getNotation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNotation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemOf())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemOf());
    }
    m_out << ",";
    if (Step::isUnset(value->getTitle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTitle());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassificationItemRelationship(IfcClassificationItemRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATIONITEMRELATIONSHIP(";
    if (Step::isUnset(value->getRelatingItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcClassificationItem_1_n::iterator step_it0 = (value->getRelatedItems()).begin();
            if ((value->getRelatedItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassificationNotation(IfcClassificationNotation *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATIONNOTATION(";
    if (Step::isUnset(value->getNotationFacets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcClassificationNotationFacet_1_n::iterator step_it0 = (value->getNotationFacets()).begin();
            if ((value->getNotationFacets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getNotationFacets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassificationNotationFacet(IfcClassificationNotationFacet *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATIONNOTATIONFACET(";
    if (Step::isUnset(value->getNotationValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNotationValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClassificationReference(IfcClassificationReference *value) {
    m_out << "#" << value->getKey() << "=IFCCLASSIFICATIONREFERENCE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getReferencedSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getReferencedSource());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcClosedShell(IfcClosedShell *value) {
    m_out << "#" << value->getKey() << "=IFCCLOSEDSHELL(";
    if (Step::isUnset(value->getCfsFaces())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFace_1_n::iterator step_it0 = (value->getCfsFaces()).begin();
            if ((value->getCfsFaces()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCfsFaces()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCoilTypeEnum(IfcCoilTypeEnum enumData) {
    switch(enumData) {
    case IfcCoilTypeEnum_DXCOOLINGCOIL:
        m_out << ".DXCOOLINGCOIL.";
        break;
    case IfcCoilTypeEnum_WATERCOOLINGCOIL:
        m_out << ".WATERCOOLINGCOIL.";
        break;
    case IfcCoilTypeEnum_STEAMHEATINGCOIL:
        m_out << ".STEAMHEATINGCOIL.";
        break;
    case IfcCoilTypeEnum_WATERHEATINGCOIL:
        m_out << ".WATERHEATINGCOIL.";
        break;
    case IfcCoilTypeEnum_ELECTRICHEATINGCOIL:
        m_out << ".ELECTRICHEATINGCOIL.";
        break;
    case IfcCoilTypeEnum_GASHEATINGCOIL:
        m_out << ".GASHEATINGCOIL.";
        break;
    case IfcCoilTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCoilTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCoilType(IfcCoilType *value) {
    m_out << "#" << value->getKey() << "=IFCCOILTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCoilTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcColourRgb(IfcColourRgb *value) {
    m_out << "#" << value->getKey() << "=IFCCOLOURRGB(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getRed())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRed());
    }
    m_out << ",";
    if (Step::isUnset(value->getGreen())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGreen());
    }
    m_out << ",";
    if (Step::isUnset(value->getBlue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBlue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcColourSpecification(IfcColourSpecification *value) {
    m_out << "#" << value->getKey() << "=IFCCOLOURSPECIFICATION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcColumn(IfcColumn *value) {
    m_out << "#" << value->getKey() << "=IFCCOLUMN(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcColumnTypeEnum(IfcColumnTypeEnum enumData) {
    switch(enumData) {
    case IfcColumnTypeEnum_COLUMN:
        m_out << ".COLUMN.";
        break;
    case IfcColumnTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcColumnTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcColumnType(IfcColumnType *value) {
    m_out << "#" << value->getKey() << "=IFCCOLUMNTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcColumnTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcComplexProperty(IfcComplexProperty *value) {
    m_out << "#" << value->getKey() << "=IFCCOMPLEXPROPERTY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUsageName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUsageName());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getHasProperties()).begin();
            if ((value->getHasProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCompositeCurve(IfcCompositeCurve *value) {
    m_out << "#" << value->getKey() << "=IFCCOMPOSITECURVE(";
    if (Step::isUnset(value->getSegments())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCompositeCurveSegment_1_n::iterator step_it0 = (value->getSegments()).begin();
            if ((value->getSegments()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSegments()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTransitionCode(IfcTransitionCode enumData) {
    switch(enumData) {
    case IfcTransitionCode_DISCONTINUOUS:
        m_out << ".DISCONTINUOUS.";
        break;
    case IfcTransitionCode_CONTINUOUS:
        m_out << ".CONTINUOUS.";
        break;
    case IfcTransitionCode_CONTSAMEGRADIENT:
        m_out << ".CONTSAMEGRADIENT.";
        break;
    case IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE:
        m_out << ".CONTSAMEGRADIENTSAMECURVATURE.";
        break;
        }
}

bool SPFWriter::visitIfcCompositeCurveSegment(IfcCompositeCurveSegment *value) {
    m_out << "#" << value->getKey() << "=IFCCOMPOSITECURVESEGMENT(";
    if (Step::isUnsetEnum(value->getTransition())) {
        m_out << "$";
    }
    else {
        writeIfcTransitionCode(value->getTransition());
    }
    m_out << ",";
    if (Step::isUnset(value->getSameSense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSameSense());
    }
    m_out << ",";
    if (Step::isUnset(value->getParentCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParentCurve());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCompositeProfileDef(IfcCompositeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCOMPOSITEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfiles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProfileDef_2_n::iterator step_it0 = (value->getProfiles()).begin();
            if ((value->getProfiles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getProfiles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getLabel())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLabel());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCompressorTypeEnum(IfcCompressorTypeEnum enumData) {
    switch(enumData) {
    case IfcCompressorTypeEnum_DYNAMIC:
        m_out << ".DYNAMIC.";
        break;
    case IfcCompressorTypeEnum_RECIPROCATING:
        m_out << ".RECIPROCATING.";
        break;
    case IfcCompressorTypeEnum_ROTARY:
        m_out << ".ROTARY.";
        break;
    case IfcCompressorTypeEnum_SCROLL:
        m_out << ".SCROLL.";
        break;
    case IfcCompressorTypeEnum_TROCHOIDAL:
        m_out << ".TROCHOIDAL.";
        break;
    case IfcCompressorTypeEnum_SINGLESTAGE:
        m_out << ".SINGLESTAGE.";
        break;
    case IfcCompressorTypeEnum_BOOSTER:
        m_out << ".BOOSTER.";
        break;
    case IfcCompressorTypeEnum_OPENTYPE:
        m_out << ".OPENTYPE.";
        break;
    case IfcCompressorTypeEnum_HERMETIC:
        m_out << ".HERMETIC.";
        break;
    case IfcCompressorTypeEnum_SEMIHERMETIC:
        m_out << ".SEMIHERMETIC.";
        break;
    case IfcCompressorTypeEnum_WELDEDSHELLHERMETIC:
        m_out << ".WELDEDSHELLHERMETIC.";
        break;
    case IfcCompressorTypeEnum_ROLLINGPISTON:
        m_out << ".ROLLINGPISTON.";
        break;
    case IfcCompressorTypeEnum_ROTARYVANE:
        m_out << ".ROTARYVANE.";
        break;
    case IfcCompressorTypeEnum_SINGLESCREW:
        m_out << ".SINGLESCREW.";
        break;
    case IfcCompressorTypeEnum_TWINSCREW:
        m_out << ".TWINSCREW.";
        break;
    case IfcCompressorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCompressorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCompressorType(IfcCompressorType *value) {
    m_out << "#" << value->getKey() << "=IFCCOMPRESSORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCompressorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCondenserTypeEnum(IfcCondenserTypeEnum enumData) {
    switch(enumData) {
    case IfcCondenserTypeEnum_WATERCOOLEDSHELLTUBE:
        m_out << ".WATERCOOLEDSHELLTUBE.";
        break;
    case IfcCondenserTypeEnum_WATERCOOLEDSHELLCOIL:
        m_out << ".WATERCOOLEDSHELLCOIL.";
        break;
    case IfcCondenserTypeEnum_WATERCOOLEDTUBEINTUBE:
        m_out << ".WATERCOOLEDTUBEINTUBE.";
        break;
    case IfcCondenserTypeEnum_WATERCOOLEDBRAZEDPLATE:
        m_out << ".WATERCOOLEDBRAZEDPLATE.";
        break;
    case IfcCondenserTypeEnum_AIRCOOLED:
        m_out << ".AIRCOOLED.";
        break;
    case IfcCondenserTypeEnum_EVAPORATIVECOOLED:
        m_out << ".EVAPORATIVECOOLED.";
        break;
    case IfcCondenserTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCondenserTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCondenserType(IfcCondenserType *value) {
    m_out << "#" << value->getKey() << "=IFCCONDENSERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCondenserTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCondition(IfcCondition *value) {
    m_out << "#" << value->getKey() << "=IFCCONDITION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcConditionCriterionSelect(IfcConditionCriterionSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcConditionCriterionSelect::IFCLABEL:
        m_out << "IFCLABEL(";
        writeAttribute(selectData->getIfcLabel());
        m_out << ")";
        break;
    case IfcConditionCriterionSelect::IFCMEASUREWITHUNIT:
        writeAttribute(selectData->getIfcMeasureWithUnit());
        break;
        }
}

bool SPFWriter::visitIfcConditionCriterion(IfcConditionCriterion *value) {
    m_out << "#" << value->getKey() << "=IFCCONDITIONCRITERION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getCriterion())) {
        m_out << "$";
    }
    else {
        writeIfcConditionCriterionSelect(value->getCriterion());
    }
    m_out << ",";
    if (Step::isUnset(value->getCriterionDateTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCriterionDateTime());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConic(IfcConic *value) {
    m_out << "#" << value->getKey() << "=IFCCONIC(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConnectedFaceSet(IfcConnectedFaceSet *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTEDFACESET(";
    if (Step::isUnset(value->getCfsFaces())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFace_1_n::iterator step_it0 = (value->getCfsFaces()).begin();
            if ((value->getCfsFaces()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCfsFaces()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCurveOrEdgeCurve(IfcCurveOrEdgeCurve *selectData) {
    switch(selectData->currentType()) {
    case IfcCurveOrEdgeCurve::IFCBOUNDEDCURVE:
        writeAttribute(selectData->getIfcBoundedCurve());
        break;
    case IfcCurveOrEdgeCurve::IFCEDGECURVE:
        writeAttribute(selectData->getIfcEdgeCurve());
        break;
        }
}

bool SPFWriter::visitIfcConnectionCurveGeometry(IfcConnectionCurveGeometry *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONCURVEGEOMETRY(";
    if (Step::isUnset(value->getCurveOnRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcCurveOrEdgeCurve(value->getCurveOnRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveOnRelatedElement())) {
        m_out << "$";
    }
    else {
        writeIfcCurveOrEdgeCurve(value->getCurveOnRelatedElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConnectionGeometry(IfcConnectionGeometry *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONGEOMETRY(";
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPointOrVertexPoint(IfcPointOrVertexPoint *selectData) {
    switch(selectData->currentType()) {
    case IfcPointOrVertexPoint::IFCPOINT:
        writeAttribute(selectData->getIfcPoint());
        break;
    case IfcPointOrVertexPoint::IFCVERTEXPOINT:
        writeAttribute(selectData->getIfcVertexPoint());
        break;
        }
}

bool SPFWriter::visitIfcConnectionPointEccentricity(IfcConnectionPointEccentricity *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONPOINTECCENTRICITY(";
    if (Step::isUnset(value->getPointOnRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcPointOrVertexPoint(value->getPointOnRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointOnRelatedElement())) {
        m_out << "$";
    }
    else {
        writeIfcPointOrVertexPoint(value->getPointOnRelatedElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getEccentricityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEccentricityInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getEccentricityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEccentricityInY());
    }
    m_out << ",";
    if (Step::isUnset(value->getEccentricityInZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEccentricityInZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConnectionPointGeometry(IfcConnectionPointGeometry *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONPOINTGEOMETRY(";
    if (Step::isUnset(value->getPointOnRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcPointOrVertexPoint(value->getPointOnRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointOnRelatedElement())) {
        m_out << "$";
    }
    else {
        writeIfcPointOrVertexPoint(value->getPointOnRelatedElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConnectionPortGeometry(IfcConnectionPortGeometry *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONPORTGEOMETRY(";
    if (Step::isUnset(value->getLocationAtRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getLocationAtRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocationAtRelatedElement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getLocationAtRelatedElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileOfPort())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileOfPort());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSurfaceOrFaceSurface(IfcSurfaceOrFaceSurface *selectData) {
    switch(selectData->currentType()) {
    case IfcSurfaceOrFaceSurface::IFCSURFACE:
        writeAttribute(selectData->getIfcSurface());
        break;
    case IfcSurfaceOrFaceSurface::IFCFACESURFACE:
        writeAttribute(selectData->getIfcFaceSurface());
        break;
    case IfcSurfaceOrFaceSurface::IFCFACEBASEDSURFACEMODEL:
        writeAttribute(selectData->getIfcFaceBasedSurfaceModel());
        break;
        }
}

bool SPFWriter::visitIfcConnectionSurfaceGeometry(IfcConnectionSurfaceGeometry *value) {
    m_out << "#" << value->getKey() << "=IFCCONNECTIONSURFACEGEOMETRY(";
    if (Step::isUnset(value->getSurfaceOnRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceOrFaceSurface(value->getSurfaceOnRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getSurfaceOnRelatedElement())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceOrFaceSurface(value->getSurfaceOnRelatedElement());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcConstraintEnum(IfcConstraintEnum enumData) {
    switch(enumData) {
    case IfcConstraintEnum_HARD:
        m_out << ".HARD.";
        break;
    case IfcConstraintEnum_SOFT:
        m_out << ".SOFT.";
        break;
    case IfcConstraintEnum_ADVISORY:
        m_out << ".ADVISORY.";
        break;
    case IfcConstraintEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcConstraintEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcConstraint(IfcConstraint *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRAINT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstraintGrade())) {
        m_out << "$";
    }
    else {
        writeIfcConstraintEnum(value->getConstraintGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getConstraintSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConstraintSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreatingActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getCreatingActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedGrade());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLogicalOperatorEnum(IfcLogicalOperatorEnum enumData) {
    switch(enumData) {
    case IfcLogicalOperatorEnum_LOGICALAND:
        m_out << ".LOGICALAND.";
        break;
    case IfcLogicalOperatorEnum_LOGICALOR:
        m_out << ".LOGICALOR.";
        break;
        }
}

bool SPFWriter::visitIfcConstraintAggregationRelationship(IfcConstraintAggregationRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRAINTAGGREGATIONRELATIONSHIP(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingConstraint());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedConstraints())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcConstraint_1_n::iterator step_it0 = (value->getRelatedConstraints()).begin();
            if ((value->getRelatedConstraints()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedConstraints()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getLogicalAggregator())) {
        m_out << "$";
    }
    else {
        writeIfcLogicalOperatorEnum(value->getLogicalAggregator());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcClassificationNotationSelect(IfcClassificationNotationSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcClassificationNotationSelect::IFCCLASSIFICATIONNOTATION:
        writeAttribute(selectData->getIfcClassificationNotation());
        break;
    case IfcClassificationNotationSelect::IFCCLASSIFICATIONREFERENCE:
        writeAttribute(selectData->getIfcClassificationReference());
        break;
        }
}

bool SPFWriter::visitIfcConstraintClassificationRelationship(IfcConstraintClassificationRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP(";
    if (Step::isUnset(value->getClassifiedConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getClassifiedConstraint());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedClassifications())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcClassificationNotationSelect_1_n::iterator step_it0 = (value->getRelatedClassifications()).begin();
            if ((value->getRelatedClassifications()).size()) {
                writeIfcClassificationNotationSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedClassifications()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcClassificationNotationSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConstraintRelationship(IfcConstraintRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRAINTRELATIONSHIP(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingConstraint());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedConstraints())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcConstraint_1_n::iterator step_it0 = (value->getRelatedConstraints()).begin();
            if ((value->getRelatedConstraints()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedConstraints()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcResourceConsumptionEnum(IfcResourceConsumptionEnum enumData) {
    switch(enumData) {
    case IfcResourceConsumptionEnum_CONSUMED:
        m_out << ".CONSUMED.";
        break;
    case IfcResourceConsumptionEnum_PARTIALLYCONSUMED:
        m_out << ".PARTIALLYCONSUMED.";
        break;
    case IfcResourceConsumptionEnum_NOTCONSUMED:
        m_out << ".NOTCONSUMED.";
        break;
    case IfcResourceConsumptionEnum_OCCUPIED:
        m_out << ".OCCUPIED.";
        break;
    case IfcResourceConsumptionEnum_PARTIALLYOCCUPIED:
        m_out << ".PARTIALLYOCCUPIED.";
        break;
    case IfcResourceConsumptionEnum_NOTOCCUPIED:
        m_out << ".NOTOCCUPIED.";
        break;
    case IfcResourceConsumptionEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcResourceConsumptionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcConstructionEquipmentResource(IfcConstructionEquipmentResource *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRUCTIONEQUIPMENTRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConstructionMaterialResource(IfcConstructionMaterialResource *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRUCTIONMATERIALRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ",";
    if (Step::isUnset(value->getSuppliers())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcActorSelect_1_n::iterator step_it0 = (value->getSuppliers()).begin();
            if ((value->getSuppliers()).size()) {
                writeIfcActorSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSuppliers()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcActorSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getUsageRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUsageRatio());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConstructionProductResource(IfcConstructionProductResource *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRUCTIONPRODUCTRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConstructionResource(IfcConstructionResource *value) {
    m_out << "#" << value->getKey() << "=IFCCONSTRUCTIONRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcUnitEnum(IfcUnitEnum enumData) {
    switch(enumData) {
    case IfcUnitEnum_ABSORBEDDOSEUNIT:
        m_out << ".ABSORBEDDOSEUNIT.";
        break;
    case IfcUnitEnum_AMOUNTOFSUBSTANCEUNIT:
        m_out << ".AMOUNTOFSUBSTANCEUNIT.";
        break;
    case IfcUnitEnum_AREAUNIT:
        m_out << ".AREAUNIT.";
        break;
    case IfcUnitEnum_DOSEEQUIVALENTUNIT:
        m_out << ".DOSEEQUIVALENTUNIT.";
        break;
    case IfcUnitEnum_ELECTRICCAPACITANCEUNIT:
        m_out << ".ELECTRICCAPACITANCEUNIT.";
        break;
    case IfcUnitEnum_ELECTRICCHARGEUNIT:
        m_out << ".ELECTRICCHARGEUNIT.";
        break;
    case IfcUnitEnum_ELECTRICCONDUCTANCEUNIT:
        m_out << ".ELECTRICCONDUCTANCEUNIT.";
        break;
    case IfcUnitEnum_ELECTRICCURRENTUNIT:
        m_out << ".ELECTRICCURRENTUNIT.";
        break;
    case IfcUnitEnum_ELECTRICRESISTANCEUNIT:
        m_out << ".ELECTRICRESISTANCEUNIT.";
        break;
    case IfcUnitEnum_ELECTRICVOLTAGEUNIT:
        m_out << ".ELECTRICVOLTAGEUNIT.";
        break;
    case IfcUnitEnum_ENERGYUNIT:
        m_out << ".ENERGYUNIT.";
        break;
    case IfcUnitEnum_FORCEUNIT:
        m_out << ".FORCEUNIT.";
        break;
    case IfcUnitEnum_FREQUENCYUNIT:
        m_out << ".FREQUENCYUNIT.";
        break;
    case IfcUnitEnum_ILLUMINANCEUNIT:
        m_out << ".ILLUMINANCEUNIT.";
        break;
    case IfcUnitEnum_INDUCTANCEUNIT:
        m_out << ".INDUCTANCEUNIT.";
        break;
    case IfcUnitEnum_LENGTHUNIT:
        m_out << ".LENGTHUNIT.";
        break;
    case IfcUnitEnum_LUMINOUSFLUXUNIT:
        m_out << ".LUMINOUSFLUXUNIT.";
        break;
    case IfcUnitEnum_LUMINOUSINTENSITYUNIT:
        m_out << ".LUMINOUSINTENSITYUNIT.";
        break;
    case IfcUnitEnum_MAGNETICFLUXDENSITYUNIT:
        m_out << ".MAGNETICFLUXDENSITYUNIT.";
        break;
    case IfcUnitEnum_MAGNETICFLUXUNIT:
        m_out << ".MAGNETICFLUXUNIT.";
        break;
    case IfcUnitEnum_MASSUNIT:
        m_out << ".MASSUNIT.";
        break;
    case IfcUnitEnum_PLANEANGLEUNIT:
        m_out << ".PLANEANGLEUNIT.";
        break;
    case IfcUnitEnum_POWERUNIT:
        m_out << ".POWERUNIT.";
        break;
    case IfcUnitEnum_PRESSUREUNIT:
        m_out << ".PRESSUREUNIT.";
        break;
    case IfcUnitEnum_RADIOACTIVITYUNIT:
        m_out << ".RADIOACTIVITYUNIT.";
        break;
    case IfcUnitEnum_SOLIDANGLEUNIT:
        m_out << ".SOLIDANGLEUNIT.";
        break;
    case IfcUnitEnum_THERMODYNAMICTEMPERATUREUNIT:
        m_out << ".THERMODYNAMICTEMPERATUREUNIT.";
        break;
    case IfcUnitEnum_TIMEUNIT:
        m_out << ".TIMEUNIT.";
        break;
    case IfcUnitEnum_VOLUMEUNIT:
        m_out << ".VOLUMEUNIT.";
        break;
    case IfcUnitEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcContextDependentUnit(IfcContextDependentUnit *value) {
    m_out << "#" << value->getKey() << "=IFCCONTEXTDEPENDENTUNIT(";
    if (Step::isUnset(value->getDimensions())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDimensions());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getUnitType())) {
        m_out << "$";
    }
    else {
        writeIfcUnitEnum(value->getUnitType());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcControl(IfcControl *value) {
    m_out << "#" << value->getKey() << "=IFCCONTROL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcControllerTypeEnum(IfcControllerTypeEnum enumData) {
    switch(enumData) {
    case IfcControllerTypeEnum_FLOATING:
        m_out << ".FLOATING.";
        break;
    case IfcControllerTypeEnum_PROPORTIONAL:
        m_out << ".PROPORTIONAL.";
        break;
    case IfcControllerTypeEnum_PROPORTIONALINTEGRAL:
        m_out << ".PROPORTIONALINTEGRAL.";
        break;
    case IfcControllerTypeEnum_PROPORTIONALINTEGRALDERIVATIVE:
        m_out << ".PROPORTIONALINTEGRALDERIVATIVE.";
        break;
    case IfcControllerTypeEnum_TIMEDTWOPOSITION:
        m_out << ".TIMEDTWOPOSITION.";
        break;
    case IfcControllerTypeEnum_TWOPOSITION:
        m_out << ".TWOPOSITION.";
        break;
    case IfcControllerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcControllerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcControllerType(IfcControllerType *value) {
    m_out << "#" << value->getKey() << "=IFCCONTROLLERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcControllerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcConversionBasedUnit(IfcConversionBasedUnit *value) {
    m_out << "#" << value->getKey() << "=IFCCONVERSIONBASEDUNIT(";
    if (Step::isUnset(value->getDimensions())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDimensions());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getUnitType())) {
        m_out << "$";
    }
    else {
        writeIfcUnitEnum(value->getUnitType());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getConversionFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConversionFactor());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCooledBeamTypeEnum(IfcCooledBeamTypeEnum enumData) {
    switch(enumData) {
    case IfcCooledBeamTypeEnum_ACTIVE:
        m_out << ".ACTIVE.";
        break;
    case IfcCooledBeamTypeEnum_PASSIVE:
        m_out << ".PASSIVE.";
        break;
    case IfcCooledBeamTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCooledBeamTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCooledBeamType(IfcCooledBeamType *value) {
    m_out << "#" << value->getKey() << "=IFCCOOLEDBEAMTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCooledBeamTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCoolingTowerTypeEnum(IfcCoolingTowerTypeEnum enumData) {
    switch(enumData) {
    case IfcCoolingTowerTypeEnum_NATURALDRAFT:
        m_out << ".NATURALDRAFT.";
        break;
    case IfcCoolingTowerTypeEnum_MECHANICALINDUCEDDRAFT:
        m_out << ".MECHANICALINDUCEDDRAFT.";
        break;
    case IfcCoolingTowerTypeEnum_MECHANICALFORCEDDRAFT:
        m_out << ".MECHANICALFORCEDDRAFT.";
        break;
    case IfcCoolingTowerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCoolingTowerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCoolingTowerType(IfcCoolingTowerType *value) {
    m_out << "#" << value->getKey() << "=IFCCOOLINGTOWERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCoolingTowerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAheadOrBehind(IfcAheadOrBehind enumData) {
    switch(enumData) {
    case IfcAheadOrBehind_AHEAD:
        m_out << ".AHEAD.";
        break;
    case IfcAheadOrBehind_BEHIND:
        m_out << ".BEHIND.";
        break;
        }
}

bool SPFWriter::visitIfcCoordinatedUniversalTimeOffset(IfcCoordinatedUniversalTimeOffset *value) {
    m_out << "#" << value->getKey() << "=IFCCOORDINATEDUNIVERSALTIMEOFFSET(";
    if (Step::isUnset(value->getHourOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHourOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinuteOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinuteOffset());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getSense())) {
        m_out << "$";
    }
    else {
        writeIfcAheadOrBehind(value->getSense());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCostItem(IfcCostItem *value) {
    m_out << "#" << value->getKey() << "=IFCCOSTITEM(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCostScheduleTypeEnum(IfcCostScheduleTypeEnum enumData) {
    switch(enumData) {
    case IfcCostScheduleTypeEnum_BUDGET:
        m_out << ".BUDGET.";
        break;
    case IfcCostScheduleTypeEnum_COSTPLAN:
        m_out << ".COSTPLAN.";
        break;
    case IfcCostScheduleTypeEnum_ESTIMATE:
        m_out << ".ESTIMATE.";
        break;
    case IfcCostScheduleTypeEnum_TENDER:
        m_out << ".TENDER.";
        break;
    case IfcCostScheduleTypeEnum_PRICEDBILLOFQUANTITIES:
        m_out << ".PRICEDBILLOFQUANTITIES.";
        break;
    case IfcCostScheduleTypeEnum_UNPRICEDBILLOFQUANTITIES:
        m_out << ".UNPRICEDBILLOFQUANTITIES.";
        break;
    case IfcCostScheduleTypeEnum_SCHEDULEOFRATES:
        m_out << ".SCHEDULEOFRATES.";
        break;
    case IfcCostScheduleTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCostScheduleTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCostSchedule(IfcCostSchedule *value) {
    m_out << "#" << value->getKey() << "=IFCCOSTSCHEDULE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubmittedBy())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getSubmittedBy());
    }
    m_out << ",";
    if (Step::isUnset(value->getPreparedBy())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getPreparedBy());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubmittedOn())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getSubmittedOn());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStatus());
    }
    m_out << ",";
    if (Step::isUnset(value->getTargetUsers())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcActorSelect_1_n::iterator step_it0 = (value->getTargetUsers()).begin();
            if ((value->getTargetUsers()).size()) {
                writeIfcActorSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTargetUsers()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcActorSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getUpdateDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getUpdateDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getID());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCostScheduleTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCostValue(IfcCostValue *value) {
    m_out << "#" << value->getKey() << "=IFCCOSTVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedValue())) {
        m_out << "$";
    }
    else {
        writeIfcAppliedValueSelect(value->getAppliedValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnitBasis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnitBasis());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getApplicableDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getFixedUntilDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFixedUntilDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getCostType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCostType());
    }
    m_out << ",";
    if (Step::isUnset(value->getCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCondition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCoveringTypeEnum(IfcCoveringTypeEnum enumData) {
    switch(enumData) {
    case IfcCoveringTypeEnum_CEILING:
        m_out << ".CEILING.";
        break;
    case IfcCoveringTypeEnum_FLOORING:
        m_out << ".FLOORING.";
        break;
    case IfcCoveringTypeEnum_CLADDING:
        m_out << ".CLADDING.";
        break;
    case IfcCoveringTypeEnum_ROOFING:
        m_out << ".ROOFING.";
        break;
    case IfcCoveringTypeEnum_INSULATION:
        m_out << ".INSULATION.";
        break;
    case IfcCoveringTypeEnum_MEMBRANE:
        m_out << ".MEMBRANE.";
        break;
    case IfcCoveringTypeEnum_SLEEVING:
        m_out << ".SLEEVING.";
        break;
    case IfcCoveringTypeEnum_WRAPPING:
        m_out << ".WRAPPING.";
        break;
    case IfcCoveringTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCoveringTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCovering(IfcCovering *value) {
    m_out << "#" << value->getKey() << "=IFCCOVERING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCoveringTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCoveringType(IfcCoveringType *value) {
    m_out << "#" << value->getKey() << "=IFCCOVERINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCoveringTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCraneRailAShapeProfileDef(IfcCraneRailAShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCRANERAILASHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseWidth2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseWidth2());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadDepth2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadDepth2());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadDepth3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadDepth3());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseWidth4())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseWidth4());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseDepth1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseDepth1());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseDepth2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseDepth2());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseDepth3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseDepth3());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCraneRailFShapeProfileDef(IfcCraneRailFShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCCRANERAILFSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadDepth2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadDepth2());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeadDepth3())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeadDepth3());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseDepth1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseDepth1());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseDepth2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseDepth2());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCrewResource(IfcCrewResource *value) {
    m_out << "#" << value->getKey() << "=IFCCREWRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCsgPrimitive3D(IfcCsgPrimitive3D *value) {
    m_out << "#" << value->getKey() << "=IFCCSGPRIMITIVE3D(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCsgSelect(IfcCsgSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcCsgSelect::IFCBOOLEANRESULT:
        writeAttribute(selectData->getIfcBooleanResult());
        break;
    case IfcCsgSelect::IFCCSGPRIMITIVE3D:
        writeAttribute(selectData->getIfcCsgPrimitive3D());
        break;
        }
}

bool SPFWriter::visitIfcCsgSolid(IfcCsgSolid *value) {
    m_out << "#" << value->getKey() << "=IFCCSGSOLID(";
    if (Step::isUnset(value->getTreeRootExpression())) {
        m_out << "$";
    }
    else {
        writeIfcCsgSelect(value->getTreeRootExpression());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurrencyRelationship(IfcCurrencyRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCCURRENCYRELATIONSHIP(";
    if (Step::isUnset(value->getRelatingMonetaryUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingMonetaryUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedMonetaryUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedMonetaryUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getExchangeRate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExchangeRate());
    }
    m_out << ",";
    if (Step::isUnset(value->getRateDateTime())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRateDateTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getRateSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRateSource());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurtainWall(IfcCurtainWall *value) {
    m_out << "#" << value->getKey() << "=IFCCURTAINWALL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCurtainWallTypeEnum(IfcCurtainWallTypeEnum enumData) {
    switch(enumData) {
    case IfcCurtainWallTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcCurtainWallTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcCurtainWallType(IfcCurtainWallType *value) {
    m_out << "#" << value->getKey() << "=IFCCURTAINWALLTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcCurtainWallTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurve(IfcCurve *value) {
    m_out << "#" << value->getKey() << "=IFCCURVE(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurveBoundedPlane(IfcCurveBoundedPlane *value) {
    m_out << "#" << value->getKey() << "=IFCCURVEBOUNDEDPLANE(";
    if (Step::isUnset(value->getBasisSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getOuterBoundary())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuterBoundary());
    }
    m_out << ",";
    if (Step::isUnset(value->getInnerBoundaries())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcCurve_0_n::iterator step_it0 = (value->getInnerBoundaries()).begin();
            if ((value->getInnerBoundaries()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getInnerBoundaries()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCurveFontOrScaledCurveFontSelect(IfcCurveFontOrScaledCurveFontSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcCurveFontOrScaledCurveFontSelect::IFCPREDEFINEDCURVEFONT:
        writeAttribute(selectData->getIfcPreDefinedCurveFont());
        break;
    case IfcCurveFontOrScaledCurveFontSelect::IFCCURVESTYLEFONT:
        writeAttribute(selectData->getIfcCurveStyleFont());
        break;
    case IfcCurveFontOrScaledCurveFontSelect::IFCCURVESTYLEFONTANDSCALING:
        writeAttribute(selectData->getIfcCurveStyleFontAndScaling());
        break;
        }
}

void SPFWriter::writeIfcSizeSelect(IfcSizeSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcSizeSelect::IFCRATIOMEASURE:
        m_out << "IFCRATIOMEASURE(";
        writeAttribute(selectData->getIfcRatioMeasure());
        m_out << ")";
        break;
    case IfcSizeSelect::IFCLENGTHMEASURE:
        m_out << "IFCLENGTHMEASURE(";
        writeAttribute(selectData->getIfcLengthMeasure());
        m_out << ")";
        break;
    case IfcSizeSelect::IFCDESCRIPTIVEMEASURE:
        m_out << "IFCDESCRIPTIVEMEASURE(";
        writeAttribute(selectData->getIfcDescriptiveMeasure());
        m_out << ")";
        break;
    case IfcSizeSelect::IFCPOSITIVELENGTHMEASURE:
        m_out << "IFCPOSITIVELENGTHMEASURE(";
        writeAttribute(selectData->getIfcPositiveLengthMeasure());
        m_out << ")";
        break;
    case IfcSizeSelect::IFCNORMALISEDRATIOMEASURE:
        m_out << "IFCNORMALISEDRATIOMEASURE(";
        writeAttribute(selectData->getIfcNormalisedRatioMeasure());
        m_out << ")";
        break;
    case IfcSizeSelect::IFCPOSITIVERATIOMEASURE:
        m_out << "IFCPOSITIVERATIOMEASURE(";
        writeAttribute(selectData->getIfcPositiveRatioMeasure());
        m_out << ")";
        break;
        }
}

void SPFWriter::writeIfcColour(IfcColour *selectData) {
    switch(selectData->currentType()) {
    case IfcColour::IFCCOLOURSPECIFICATION:
        writeAttribute(selectData->getIfcColourSpecification());
        break;
    case IfcColour::IFCPREDEFINEDCOLOUR:
        writeAttribute(selectData->getIfcPreDefinedColour());
        break;
        }
}

bool SPFWriter::visitIfcCurveStyle(IfcCurveStyle *value) {
    m_out << "#" << value->getKey() << "=IFCCURVESTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveFont())) {
        m_out << "$";
    }
    else {
        writeIfcCurveFontOrScaledCurveFontSelect(value->getCurveFont());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveWidth())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getCurveWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveColour())) {
        m_out << "$";
    }
    else {
        writeIfcColour(value->getCurveColour());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurveStyleFont(IfcCurveStyleFont *value) {
    m_out << "#" << value->getKey() << "=IFCCURVESTYLEFONT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPatternList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCurveStyleFontPattern_1_n::iterator step_it0 = (value->getPatternList()).begin();
            if ((value->getPatternList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getPatternList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCurveStyleFontSelect(IfcCurveStyleFontSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcCurveStyleFontSelect::IFCPREDEFINEDCURVEFONT:
        writeAttribute(selectData->getIfcPreDefinedCurveFont());
        break;
    case IfcCurveStyleFontSelect::IFCCURVESTYLEFONT:
        writeAttribute(selectData->getIfcCurveStyleFont());
        break;
        }
}

bool SPFWriter::visitIfcCurveStyleFontAndScaling(IfcCurveStyleFontAndScaling *value) {
    m_out << "#" << value->getKey() << "=IFCCURVESTYLEFONTANDSCALING(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveFont())) {
        m_out << "$";
    }
    else {
        writeIfcCurveStyleFontSelect(value->getCurveFont());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurveFontScaling())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCurveFontScaling());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcCurveStyleFontPattern(IfcCurveStyleFontPattern *value) {
    m_out << "#" << value->getKey() << "=IFCCURVESTYLEFONTPATTERN(";
    if (Step::isUnset(value->getVisibleSegmentLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVisibleSegmentLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getInvisibleSegmentLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInvisibleSegmentLength());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDamperTypeEnum(IfcDamperTypeEnum enumData) {
    switch(enumData) {
    case IfcDamperTypeEnum_CONTROLDAMPER:
        m_out << ".CONTROLDAMPER.";
        break;
    case IfcDamperTypeEnum_FIREDAMPER:
        m_out << ".FIREDAMPER.";
        break;
    case IfcDamperTypeEnum_SMOKEDAMPER:
        m_out << ".SMOKEDAMPER.";
        break;
    case IfcDamperTypeEnum_FIRESMOKEDAMPER:
        m_out << ".FIRESMOKEDAMPER.";
        break;
    case IfcDamperTypeEnum_BACKDRAFTDAMPER:
        m_out << ".BACKDRAFTDAMPER.";
        break;
    case IfcDamperTypeEnum_RELIEFDAMPER:
        m_out << ".RELIEFDAMPER.";
        break;
    case IfcDamperTypeEnum_BLASTDAMPER:
        m_out << ".BLASTDAMPER.";
        break;
    case IfcDamperTypeEnum_GRAVITYDAMPER:
        m_out << ".GRAVITYDAMPER.";
        break;
    case IfcDamperTypeEnum_GRAVITYRELIEFDAMPER:
        m_out << ".GRAVITYRELIEFDAMPER.";
        break;
    case IfcDamperTypeEnum_BALANCINGDAMPER:
        m_out << ".BALANCINGDAMPER.";
        break;
    case IfcDamperTypeEnum_FUMEHOODEXHAUST:
        m_out << ".FUMEHOODEXHAUST.";
        break;
    case IfcDamperTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDamperTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDamperType(IfcDamperType *value) {
    m_out << "#" << value->getKey() << "=IFCDAMPERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcDamperTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDateAndTime(IfcDateAndTime *value) {
    m_out << "#" << value->getKey() << "=IFCDATEANDTIME(";
    if (Step::isUnset(value->getDateComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDateComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeComponent());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDefinedSymbolSelect(IfcDefinedSymbolSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcDefinedSymbolSelect::IFCPREDEFINEDSYMBOL:
        writeAttribute(selectData->getIfcPreDefinedSymbol());
        break;
    case IfcDefinedSymbolSelect::IFCEXTERNALLYDEFINEDSYMBOL:
        writeAttribute(selectData->getIfcExternallyDefinedSymbol());
        break;
        }
}

bool SPFWriter::visitIfcDefinedSymbol(IfcDefinedSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCDEFINEDSYMBOL(";
    if (Step::isUnset(value->getDefinition())) {
        m_out << "$";
    }
    else {
        writeIfcDefinedSymbolSelect(value->getDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getTarget())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTarget());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDerivedProfileDef(IfcDerivedProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCDERIVEDPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getParentProfile())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParentProfile());
    }
    m_out << ",";
    if (Step::isUnset(value->getOperator())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOperator());
    }
    m_out << ",";
    if (Step::isUnset(value->getLabel())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLabel());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDerivedUnitEnum(IfcDerivedUnitEnum enumData) {
    switch(enumData) {
    case IfcDerivedUnitEnum_ANGULARVELOCITYUNIT:
        m_out << ".ANGULARVELOCITYUNIT.";
        break;
    case IfcDerivedUnitEnum_COMPOUNDPLANEANGLEUNIT:
        m_out << ".COMPOUNDPLANEANGLEUNIT.";
        break;
    case IfcDerivedUnitEnum_DYNAMICVISCOSITYUNIT:
        m_out << ".DYNAMICVISCOSITYUNIT.";
        break;
    case IfcDerivedUnitEnum_HEATFLUXDENSITYUNIT:
        m_out << ".HEATFLUXDENSITYUNIT.";
        break;
    case IfcDerivedUnitEnum_INTEGERCOUNTRATEUNIT:
        m_out << ".INTEGERCOUNTRATEUNIT.";
        break;
    case IfcDerivedUnitEnum_ISOTHERMALMOISTURECAPACITYUNIT:
        m_out << ".ISOTHERMALMOISTURECAPACITYUNIT.";
        break;
    case IfcDerivedUnitEnum_KINEMATICVISCOSITYUNIT:
        m_out << ".KINEMATICVISCOSITYUNIT.";
        break;
    case IfcDerivedUnitEnum_LINEARVELOCITYUNIT:
        m_out << ".LINEARVELOCITYUNIT.";
        break;
    case IfcDerivedUnitEnum_MASSDENSITYUNIT:
        m_out << ".MASSDENSITYUNIT.";
        break;
    case IfcDerivedUnitEnum_MASSFLOWRATEUNIT:
        m_out << ".MASSFLOWRATEUNIT.";
        break;
    case IfcDerivedUnitEnum_MOISTUREDIFFUSIVITYUNIT:
        m_out << ".MOISTUREDIFFUSIVITYUNIT.";
        break;
    case IfcDerivedUnitEnum_MOLECULARWEIGHTUNIT:
        m_out << ".MOLECULARWEIGHTUNIT.";
        break;
    case IfcDerivedUnitEnum_SPECIFICHEATCAPACITYUNIT:
        m_out << ".SPECIFICHEATCAPACITYUNIT.";
        break;
    case IfcDerivedUnitEnum_THERMALADMITTANCEUNIT:
        m_out << ".THERMALADMITTANCEUNIT.";
        break;
    case IfcDerivedUnitEnum_THERMALCONDUCTANCEUNIT:
        m_out << ".THERMALCONDUCTANCEUNIT.";
        break;
    case IfcDerivedUnitEnum_THERMALRESISTANCEUNIT:
        m_out << ".THERMALRESISTANCEUNIT.";
        break;
    case IfcDerivedUnitEnum_THERMALTRANSMITTANCEUNIT:
        m_out << ".THERMALTRANSMITTANCEUNIT.";
        break;
    case IfcDerivedUnitEnum_VAPORPERMEABILITYUNIT:
        m_out << ".VAPORPERMEABILITYUNIT.";
        break;
    case IfcDerivedUnitEnum_VOLUMETRICFLOWRATEUNIT:
        m_out << ".VOLUMETRICFLOWRATEUNIT.";
        break;
    case IfcDerivedUnitEnum_ROTATIONALFREQUENCYUNIT:
        m_out << ".ROTATIONALFREQUENCYUNIT.";
        break;
    case IfcDerivedUnitEnum_TORQUEUNIT:
        m_out << ".TORQUEUNIT.";
        break;
    case IfcDerivedUnitEnum_MOMENTOFINERTIAUNIT:
        m_out << ".MOMENTOFINERTIAUNIT.";
        break;
    case IfcDerivedUnitEnum_LINEARMOMENTUNIT:
        m_out << ".LINEARMOMENTUNIT.";
        break;
    case IfcDerivedUnitEnum_LINEARFORCEUNIT:
        m_out << ".LINEARFORCEUNIT.";
        break;
    case IfcDerivedUnitEnum_PLANARFORCEUNIT:
        m_out << ".PLANARFORCEUNIT.";
        break;
    case IfcDerivedUnitEnum_MODULUSOFELASTICITYUNIT:
        m_out << ".MODULUSOFELASTICITYUNIT.";
        break;
    case IfcDerivedUnitEnum_SHEARMODULUSUNIT:
        m_out << ".SHEARMODULUSUNIT.";
        break;
    case IfcDerivedUnitEnum_LINEARSTIFFNESSUNIT:
        m_out << ".LINEARSTIFFNESSUNIT.";
        break;
    case IfcDerivedUnitEnum_ROTATIONALSTIFFNESSUNIT:
        m_out << ".ROTATIONALSTIFFNESSUNIT.";
        break;
    case IfcDerivedUnitEnum_MODULUSOFSUBGRADEREACTIONUNIT:
        m_out << ".MODULUSOFSUBGRADEREACTIONUNIT.";
        break;
    case IfcDerivedUnitEnum_ACCELERATIONUNIT:
        m_out << ".ACCELERATIONUNIT.";
        break;
    case IfcDerivedUnitEnum_CURVATUREUNIT:
        m_out << ".CURVATUREUNIT.";
        break;
    case IfcDerivedUnitEnum_HEATINGVALUEUNIT:
        m_out << ".HEATINGVALUEUNIT.";
        break;
    case IfcDerivedUnitEnum_IONCONCENTRATIONUNIT:
        m_out << ".IONCONCENTRATIONUNIT.";
        break;
    case IfcDerivedUnitEnum_LUMINOUSINTENSITYDISTRIBUTIONUNIT:
        m_out << ".LUMINOUSINTENSITYDISTRIBUTIONUNIT.";
        break;
    case IfcDerivedUnitEnum_MASSPERLENGTHUNIT:
        m_out << ".MASSPERLENGTHUNIT.";
        break;
    case IfcDerivedUnitEnum_MODULUSOFLINEARSUBGRADEREACTIONUNIT:
        m_out << ".MODULUSOFLINEARSUBGRADEREACTIONUNIT.";
        break;
    case IfcDerivedUnitEnum_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT:
        m_out << ".MODULUSOFROTATIONALSUBGRADEREACTIONUNIT.";
        break;
    case IfcDerivedUnitEnum_PHUNIT:
        m_out << ".PHUNIT.";
        break;
    case IfcDerivedUnitEnum_ROTATIONALMASSUNIT:
        m_out << ".ROTATIONALMASSUNIT.";
        break;
    case IfcDerivedUnitEnum_SECTIONAREAINTEGRALUNIT:
        m_out << ".SECTIONAREAINTEGRALUNIT.";
        break;
    case IfcDerivedUnitEnum_SECTIONMODULUSUNIT:
        m_out << ".SECTIONMODULUSUNIT.";
        break;
    case IfcDerivedUnitEnum_SOUNDPOWERUNIT:
        m_out << ".SOUNDPOWERUNIT.";
        break;
    case IfcDerivedUnitEnum_SOUNDPRESSUREUNIT:
        m_out << ".SOUNDPRESSUREUNIT.";
        break;
    case IfcDerivedUnitEnum_TEMPERATUREGRADIENTUNIT:
        m_out << ".TEMPERATUREGRADIENTUNIT.";
        break;
    case IfcDerivedUnitEnum_THERMALEXPANSIONCOEFFICIENTUNIT:
        m_out << ".THERMALEXPANSIONCOEFFICIENTUNIT.";
        break;
    case IfcDerivedUnitEnum_WARPINGCONSTANTUNIT:
        m_out << ".WARPINGCONSTANTUNIT.";
        break;
    case IfcDerivedUnitEnum_WARPINGMOMENTUNIT:
        m_out << ".WARPINGMOMENTUNIT.";
        break;
    case IfcDerivedUnitEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDerivedUnit(IfcDerivedUnit *value) {
    m_out << "#" << value->getKey() << "=IFCDERIVEDUNIT(";
    if (Step::isUnset(value->getElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDerivedUnitElement_1_n::iterator step_it0 = (value->getElements()).begin();
            if ((value->getElements()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getElements()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getUnitType())) {
        m_out << "$";
    }
    else {
        writeIfcDerivedUnitEnum(value->getUnitType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDerivedUnitElement(IfcDerivedUnitElement *value) {
    m_out << "#" << value->getKey() << "=IFCDERIVEDUNITELEMENT(";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExponent());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDiameterDimension(IfcDiameterDimension *value) {
    m_out << "#" << value->getKey() << "=IFCDIAMETERDIMENSION(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDimensionCalloutRelationship(IfcDimensionCalloutRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONCALLOUTRELATIONSHIP(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingDraughtingCallout());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedDraughtingCallout());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDimensionCurve(IfcDimensionCurve *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONCURVE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDimensionCurveDirectedCallout(IfcDimensionCurveDirectedCallout *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONCURVEDIRECTEDCALLOUT(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDimensionExtentUsage(IfcDimensionExtentUsage enumData) {
    switch(enumData) {
    case IfcDimensionExtentUsage_ORIGIN:
        m_out << ".ORIGIN.";
        break;
    case IfcDimensionExtentUsage_TARGET:
        m_out << ".TARGET.";
        break;
        }
}

bool SPFWriter::visitIfcDimensionCurveTerminator(IfcDimensionCurveTerminator *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONCURVETERMINATOR(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getAnnotatedCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAnnotatedCurve());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRole())) {
        m_out << "$";
    }
    else {
        writeIfcDimensionExtentUsage(value->getRole());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDimensionPair(IfcDimensionPair *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONPAIR(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingDraughtingCallout());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedDraughtingCallout());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDimensionalExponents(IfcDimensionalExponents *value) {
    m_out << "#" << value->getKey() << "=IFCDIMENSIONALEXPONENTS(";
    if (Step::isUnset(value->getLengthExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLengthExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getMassExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMassExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getElectricCurrentExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElectricCurrentExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermodynamicTemperatureExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermodynamicTemperatureExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmountOfSubstanceExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmountOfSubstanceExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getLuminousIntensityExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLuminousIntensityExponent());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDirection(IfcDirection *value) {
    m_out << "#" << value->getKey() << "=IFCDIRECTION(";
    if (Step::isUnset(value->getDirectionRatios())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_Real_2_3::iterator step_it0 = (value->getDirectionRatios()).begin();
            if ((value->getDirectionRatios()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getDirectionRatios()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDiscreteAccessory(IfcDiscreteAccessory *value) {
    m_out << "#" << value->getKey() << "=IFCDISCRETEACCESSORY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDiscreteAccessoryType(IfcDiscreteAccessoryType *value) {
    m_out << "#" << value->getKey() << "=IFCDISCRETEACCESSORYTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionChamberElement(IfcDistributionChamberElement *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONCHAMBERELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDistributionChamberElementTypeEnum(IfcDistributionChamberElementTypeEnum enumData) {
    switch(enumData) {
    case IfcDistributionChamberElementTypeEnum_FORMEDDUCT:
        m_out << ".FORMEDDUCT.";
        break;
    case IfcDistributionChamberElementTypeEnum_INSPECTIONCHAMBER:
        m_out << ".INSPECTIONCHAMBER.";
        break;
    case IfcDistributionChamberElementTypeEnum_INSPECTIONPIT:
        m_out << ".INSPECTIONPIT.";
        break;
    case IfcDistributionChamberElementTypeEnum_MANHOLE:
        m_out << ".MANHOLE.";
        break;
    case IfcDistributionChamberElementTypeEnum_METERCHAMBER:
        m_out << ".METERCHAMBER.";
        break;
    case IfcDistributionChamberElementTypeEnum_SUMP:
        m_out << ".SUMP.";
        break;
    case IfcDistributionChamberElementTypeEnum_TRENCH:
        m_out << ".TRENCH.";
        break;
    case IfcDistributionChamberElementTypeEnum_VALVECHAMBER:
        m_out << ".VALVECHAMBER.";
        break;
    case IfcDistributionChamberElementTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDistributionChamberElementTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDistributionChamberElementType(IfcDistributionChamberElementType *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONCHAMBERELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcDistributionChamberElementTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionControlElement(IfcDistributionControlElement *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONCONTROLELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getControlElementId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getControlElementId());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionControlElementType(IfcDistributionControlElementType *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONCONTROLELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionElement(IfcDistributionElement *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionElementType(IfcDistributionElementType *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionFlowElement(IfcDistributionFlowElement *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONFLOWELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDistributionFlowElementType(IfcDistributionFlowElementType *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONFLOWELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFlowDirectionEnum(IfcFlowDirectionEnum enumData) {
    switch(enumData) {
    case IfcFlowDirectionEnum_SOURCE:
        m_out << ".SOURCE.";
        break;
    case IfcFlowDirectionEnum_SINK:
        m_out << ".SINK.";
        break;
    case IfcFlowDirectionEnum_SOURCEANDSINK:
        m_out << ".SOURCEANDSINK.";
        break;
    case IfcFlowDirectionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDistributionPort(IfcDistributionPort *value) {
    m_out << "#" << value->getKey() << "=IFCDISTRIBUTIONPORT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getFlowDirection())) {
        m_out << "$";
    }
    else {
        writeIfcFlowDirectionEnum(value->getFlowDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDocumentElectronicFormat(IfcDocumentElectronicFormat *value) {
    m_out << "#" << value->getKey() << "=IFCDOCUMENTELECTRONICFORMAT(";
    if (Step::isUnset(value->getFileExtension())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFileExtension());
    }
    m_out << ",";
    if (Step::isUnset(value->getMimeContentType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMimeContentType());
    }
    m_out << ",";
    if (Step::isUnset(value->getMimeSubtype())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMimeSubtype());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDocumentConfidentialityEnum(IfcDocumentConfidentialityEnum enumData) {
    switch(enumData) {
    case IfcDocumentConfidentialityEnum_PUBLIC:
        m_out << ".PUBLIC.";
        break;
    case IfcDocumentConfidentialityEnum_RESTRICTED:
        m_out << ".RESTRICTED.";
        break;
    case IfcDocumentConfidentialityEnum_CONFIDENTIAL:
        m_out << ".CONFIDENTIAL.";
        break;
    case IfcDocumentConfidentialityEnum_PERSONAL:
        m_out << ".PERSONAL.";
        break;
    case IfcDocumentConfidentialityEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDocumentConfidentialityEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcDocumentStatusEnum(IfcDocumentStatusEnum enumData) {
    switch(enumData) {
    case IfcDocumentStatusEnum_DRAFT:
        m_out << ".DRAFT.";
        break;
    case IfcDocumentStatusEnum_FINALDRAFT:
        m_out << ".FINALDRAFT.";
        break;
    case IfcDocumentStatusEnum_FINAL:
        m_out << ".FINAL.";
        break;
    case IfcDocumentStatusEnum_REVISION:
        m_out << ".REVISION.";
        break;
    case IfcDocumentStatusEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDocumentInformation(IfcDocumentInformation *value) {
    m_out << "#" << value->getKey() << "=IFCDOCUMENTINFORMATION(";
    if (Step::isUnset(value->getDocumentId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDocumentId());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getDocumentReferences())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDocumentReference_1_n::iterator step_it0 = (value->getDocumentReferences()).begin();
            if ((value->getDocumentReferences()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getDocumentReferences()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntendedUse())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntendedUse());
    }
    m_out << ",";
    if (Step::isUnset(value->getScope())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScope());
    }
    m_out << ",";
    if (Step::isUnset(value->getRevision())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRevision());
    }
    m_out << ",";
    if (Step::isUnset(value->getDocumentOwner())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getDocumentOwner());
    }
    m_out << ",";
    if (Step::isUnset(value->getEditors())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcActorSelect_1_n::iterator step_it0 = (value->getEditors()).begin();
            if ((value->getEditors()).size()) {
                writeIfcActorSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getEditors()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcActorSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationTime())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCreationTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getLastRevisionTime())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLastRevisionTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getElectronicFormat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElectronicFormat());
    }
    m_out << ",";
    if (Step::isUnset(value->getValidFrom())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getValidFrom());
    }
    m_out << ",";
    if (Step::isUnset(value->getValidUntil())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getValidUntil());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConfidentiality())) {
        m_out << "$";
    }
    else {
        writeIfcDocumentConfidentialityEnum(value->getConfidentiality());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeIfcDocumentStatusEnum(value->getStatus());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDocumentInformationRelationship(IfcDocumentInformationRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCDOCUMENTINFORMATIONRELATIONSHIP(";
    if (Step::isUnset(value->getRelatingDocument())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingDocument());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedDocuments())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDocumentInformation_1_n::iterator step_it0 = (value->getRelatedDocuments()).begin();
            if ((value->getRelatedDocuments()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedDocuments()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelationshipType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelationshipType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDocumentReference(IfcDocumentReference *value) {
    m_out << "#" << value->getKey() << "=IFCDOCUMENTREFERENCE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDoor(IfcDoor *value) {
    m_out << "#" << value->getKey() << "=IFCDOOR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallWidth());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDoorLiningProperties(IfcDoorLiningProperties *value) {
    m_out << "#" << value->getKey() << "=IFCDOORLININGPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getLiningDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiningDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getLiningThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiningThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getThresholdDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThresholdDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getThresholdThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThresholdThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransomThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransomThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransomOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransomOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getLiningOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiningOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getThresholdOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThresholdOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getCasingThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCasingThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getCasingDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCasingDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getShapeAspectStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShapeAspectStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDoorPanelOperationEnum(IfcDoorPanelOperationEnum enumData) {
    switch(enumData) {
    case IfcDoorPanelOperationEnum_SWINGING:
        m_out << ".SWINGING.";
        break;
    case IfcDoorPanelOperationEnum_DOUBLE_ACTING:
        m_out << ".DOUBLE_ACTING.";
        break;
    case IfcDoorPanelOperationEnum_SLIDING:
        m_out << ".SLIDING.";
        break;
    case IfcDoorPanelOperationEnum_FOLDING:
        m_out << ".FOLDING.";
        break;
    case IfcDoorPanelOperationEnum_REVOLVING:
        m_out << ".REVOLVING.";
        break;
    case IfcDoorPanelOperationEnum_ROLLINGUP:
        m_out << ".ROLLINGUP.";
        break;
    case IfcDoorPanelOperationEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDoorPanelOperationEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcDoorPanelPositionEnum(IfcDoorPanelPositionEnum enumData) {
    switch(enumData) {
    case IfcDoorPanelPositionEnum_LEFT:
        m_out << ".LEFT.";
        break;
    case IfcDoorPanelPositionEnum_MIDDLE:
        m_out << ".MIDDLE.";
        break;
    case IfcDoorPanelPositionEnum_RIGHT:
        m_out << ".RIGHT.";
        break;
    case IfcDoorPanelPositionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDoorPanelProperties(IfcDoorPanelProperties *value) {
    m_out << "#" << value->getKey() << "=IFCDOORPANELPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getPanelDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPanelDepth());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPanelOperation())) {
        m_out << "$";
    }
    else {
        writeIfcDoorPanelOperationEnum(value->getPanelOperation());
    }
    m_out << ",";
    if (Step::isUnset(value->getPanelWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPanelWidth());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPanelPosition())) {
        m_out << "$";
    }
    else {
        writeIfcDoorPanelPositionEnum(value->getPanelPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getShapeAspectStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShapeAspectStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDoorStyleOperationEnum(IfcDoorStyleOperationEnum enumData) {
    switch(enumData) {
    case IfcDoorStyleOperationEnum_SINGLE_SWING_LEFT:
        m_out << ".SINGLE_SWING_LEFT.";
        break;
    case IfcDoorStyleOperationEnum_SINGLE_SWING_RIGHT:
        m_out << ".SINGLE_SWING_RIGHT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_SINGLE_SWING:
        m_out << ".DOUBLE_DOOR_SINGLE_SWING.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT:
        m_out << ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT:
        m_out << ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_SWING_LEFT:
        m_out << ".DOUBLE_SWING_LEFT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_SWING_RIGHT:
        m_out << ".DOUBLE_SWING_RIGHT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_DOUBLE_SWING:
        m_out << ".DOUBLE_DOOR_DOUBLE_SWING.";
        break;
    case IfcDoorStyleOperationEnum_SLIDING_TO_LEFT:
        m_out << ".SLIDING_TO_LEFT.";
        break;
    case IfcDoorStyleOperationEnum_SLIDING_TO_RIGHT:
        m_out << ".SLIDING_TO_RIGHT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_SLIDING:
        m_out << ".DOUBLE_DOOR_SLIDING.";
        break;
    case IfcDoorStyleOperationEnum_FOLDING_TO_LEFT:
        m_out << ".FOLDING_TO_LEFT.";
        break;
    case IfcDoorStyleOperationEnum_FOLDING_TO_RIGHT:
        m_out << ".FOLDING_TO_RIGHT.";
        break;
    case IfcDoorStyleOperationEnum_DOUBLE_DOOR_FOLDING:
        m_out << ".DOUBLE_DOOR_FOLDING.";
        break;
    case IfcDoorStyleOperationEnum_REVOLVING:
        m_out << ".REVOLVING.";
        break;
    case IfcDoorStyleOperationEnum_ROLLINGUP:
        m_out << ".ROLLINGUP.";
        break;
    case IfcDoorStyleOperationEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDoorStyleOperationEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcDoorStyleConstructionEnum(IfcDoorStyleConstructionEnum enumData) {
    switch(enumData) {
    case IfcDoorStyleConstructionEnum_ALUMINIUM:
        m_out << ".ALUMINIUM.";
        break;
    case IfcDoorStyleConstructionEnum_HIGH_GRADE_STEEL:
        m_out << ".HIGH_GRADE_STEEL.";
        break;
    case IfcDoorStyleConstructionEnum_STEEL:
        m_out << ".STEEL.";
        break;
    case IfcDoorStyleConstructionEnum_WOOD:
        m_out << ".WOOD.";
        break;
    case IfcDoorStyleConstructionEnum_ALUMINIUM_WOOD:
        m_out << ".ALUMINIUM_WOOD.";
        break;
    case IfcDoorStyleConstructionEnum_ALUMINIUM_PLASTIC:
        m_out << ".ALUMINIUM_PLASTIC.";
        break;
    case IfcDoorStyleConstructionEnum_PLASTIC:
        m_out << ".PLASTIC.";
        break;
    case IfcDoorStyleConstructionEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDoorStyleConstructionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDoorStyle(IfcDoorStyle *value) {
    m_out << "#" << value->getKey() << "=IFCDOORSTYLE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getOperationType())) {
        m_out << "$";
    }
    else {
        writeIfcDoorStyleOperationEnum(value->getOperationType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstructionType())) {
        m_out << "$";
    }
    else {
        writeIfcDoorStyleConstructionEnum(value->getConstructionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getParameterTakesPrecedence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParameterTakesPrecedence());
    }
    m_out << ",";
    if (Step::isUnset(value->getSizeable())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeable());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDraughtingCallout(IfcDraughtingCallout *value) {
    m_out << "#" << value->getKey() << "=IFCDRAUGHTINGCALLOUT(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDraughtingCalloutRelationship(IfcDraughtingCalloutRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCDRAUGHTINGCALLOUTRELATIONSHIP(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingDraughtingCallout());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedDraughtingCallout())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedDraughtingCallout());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDraughtingPreDefinedColour(IfcDraughtingPreDefinedColour *value) {
    m_out << "#" << value->getKey() << "=IFCDRAUGHTINGPREDEFINEDCOLOUR(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDraughtingPreDefinedCurveFont(IfcDraughtingPreDefinedCurveFont *value) {
    m_out << "#" << value->getKey() << "=IFCDRAUGHTINGPREDEFINEDCURVEFONT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcDraughtingPreDefinedTextFont(IfcDraughtingPreDefinedTextFont *value) {
    m_out << "#" << value->getKey() << "=IFCDRAUGHTINGPREDEFINEDTEXTFONT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDuctFittingTypeEnum(IfcDuctFittingTypeEnum enumData) {
    switch(enumData) {
    case IfcDuctFittingTypeEnum_BEND:
        m_out << ".BEND.";
        break;
    case IfcDuctFittingTypeEnum_CONNECTOR:
        m_out << ".CONNECTOR.";
        break;
    case IfcDuctFittingTypeEnum_ENTRY:
        m_out << ".ENTRY.";
        break;
    case IfcDuctFittingTypeEnum_EXIT:
        m_out << ".EXIT.";
        break;
    case IfcDuctFittingTypeEnum_JUNCTION:
        m_out << ".JUNCTION.";
        break;
    case IfcDuctFittingTypeEnum_OBSTRUCTION:
        m_out << ".OBSTRUCTION.";
        break;
    case IfcDuctFittingTypeEnum_TRANSITION:
        m_out << ".TRANSITION.";
        break;
    case IfcDuctFittingTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDuctFittingTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDuctFittingType(IfcDuctFittingType *value) {
    m_out << "#" << value->getKey() << "=IFCDUCTFITTINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcDuctFittingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDuctSegmentTypeEnum(IfcDuctSegmentTypeEnum enumData) {
    switch(enumData) {
    case IfcDuctSegmentTypeEnum_RIGIDSEGMENT:
        m_out << ".RIGIDSEGMENT.";
        break;
    case IfcDuctSegmentTypeEnum_FLEXIBLESEGMENT:
        m_out << ".FLEXIBLESEGMENT.";
        break;
    case IfcDuctSegmentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDuctSegmentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDuctSegmentType(IfcDuctSegmentType *value) {
    m_out << "#" << value->getKey() << "=IFCDUCTSEGMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcDuctSegmentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDuctSilencerTypeEnum(IfcDuctSilencerTypeEnum enumData) {
    switch(enumData) {
    case IfcDuctSilencerTypeEnum_FLATOVAL:
        m_out << ".FLATOVAL.";
        break;
    case IfcDuctSilencerTypeEnum_RECTANGULAR:
        m_out << ".RECTANGULAR.";
        break;
    case IfcDuctSilencerTypeEnum_ROUND:
        m_out << ".ROUND.";
        break;
    case IfcDuctSilencerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDuctSilencerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcDuctSilencerType(IfcDuctSilencerType *value) {
    m_out << "#" << value->getKey() << "=IFCDUCTSILENCERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcDuctSilencerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEdge(IfcEdge *value) {
    m_out << "#" << value->getKey() << "=IFCEDGE(";
    if (Step::isUnset(value->getEdgeStart())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeEnd())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeEnd());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEdgeCurve(IfcEdgeCurve *value) {
    m_out << "#" << value->getKey() << "=IFCEDGECURVE(";
    if (Step::isUnset(value->getEdgeStart())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeEnd())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeEnd());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeGeometry());
    }
    m_out << ",";
    if (Step::isUnset(value->getSameSense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSameSense());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEdgeFeature(IfcEdgeFeature *value) {
    m_out << "#" << value->getKey() << "=IFCEDGEFEATURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getFeatureLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFeatureLength());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEdgeLoop(IfcEdgeLoop *value) {
    m_out << "#" << value->getKey() << "=IFCEDGELOOP(";
    if (Step::isUnset(value->getEdgeList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcOrientedEdge_1_n::iterator step_it0 = (value->getEdgeList()).begin();
            if ((value->getEdgeList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getEdgeList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricApplianceTypeEnum(IfcElectricApplianceTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricApplianceTypeEnum_COMPUTER:
        m_out << ".COMPUTER.";
        break;
    case IfcElectricApplianceTypeEnum_DIRECTWATERHEATER:
        m_out << ".DIRECTWATERHEATER.";
        break;
    case IfcElectricApplianceTypeEnum_DISHWASHER:
        m_out << ".DISHWASHER.";
        break;
    case IfcElectricApplianceTypeEnum_ELECTRICCOOKER:
        m_out << ".ELECTRICCOOKER.";
        break;
    case IfcElectricApplianceTypeEnum_ELECTRICHEATER:
        m_out << ".ELECTRICHEATER.";
        break;
    case IfcElectricApplianceTypeEnum_FACSIMILE:
        m_out << ".FACSIMILE.";
        break;
    case IfcElectricApplianceTypeEnum_FREESTANDINGFAN:
        m_out << ".FREESTANDINGFAN.";
        break;
    case IfcElectricApplianceTypeEnum_FREEZER:
        m_out << ".FREEZER.";
        break;
    case IfcElectricApplianceTypeEnum_FRIDGE_FREEZER:
        m_out << ".FRIDGE_FREEZER.";
        break;
    case IfcElectricApplianceTypeEnum_HANDDRYER:
        m_out << ".HANDDRYER.";
        break;
    case IfcElectricApplianceTypeEnum_INDIRECTWATERHEATER:
        m_out << ".INDIRECTWATERHEATER.";
        break;
    case IfcElectricApplianceTypeEnum_MICROWAVE:
        m_out << ".MICROWAVE.";
        break;
    case IfcElectricApplianceTypeEnum_PHOTOCOPIER:
        m_out << ".PHOTOCOPIER.";
        break;
    case IfcElectricApplianceTypeEnum_PRINTER:
        m_out << ".PRINTER.";
        break;
    case IfcElectricApplianceTypeEnum_REFRIGERATOR:
        m_out << ".REFRIGERATOR.";
        break;
    case IfcElectricApplianceTypeEnum_RADIANTHEATER:
        m_out << ".RADIANTHEATER.";
        break;
    case IfcElectricApplianceTypeEnum_SCANNER:
        m_out << ".SCANNER.";
        break;
    case IfcElectricApplianceTypeEnum_TELEPHONE:
        m_out << ".TELEPHONE.";
        break;
    case IfcElectricApplianceTypeEnum_TUMBLEDRYER:
        m_out << ".TUMBLEDRYER.";
        break;
    case IfcElectricApplianceTypeEnum_TV:
        m_out << ".TV.";
        break;
    case IfcElectricApplianceTypeEnum_VENDINGMACHINE:
        m_out << ".VENDINGMACHINE.";
        break;
    case IfcElectricApplianceTypeEnum_WASHINGMACHINE:
        m_out << ".WASHINGMACHINE.";
        break;
    case IfcElectricApplianceTypeEnum_WATERHEATER:
        m_out << ".WATERHEATER.";
        break;
    case IfcElectricApplianceTypeEnum_WATERCOOLER:
        m_out << ".WATERCOOLER.";
        break;
    case IfcElectricApplianceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricApplianceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricApplianceType(IfcElectricApplianceType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICAPPLIANCETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricApplianceTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricDistributionPointFunctionEnum(IfcElectricDistributionPointFunctionEnum enumData) {
    switch(enumData) {
    case IfcElectricDistributionPointFunctionEnum_ALARMPANEL:
        m_out << ".ALARMPANEL.";
        break;
    case IfcElectricDistributionPointFunctionEnum_CONSUMERUNIT:
        m_out << ".CONSUMERUNIT.";
        break;
    case IfcElectricDistributionPointFunctionEnum_CONTROLPANEL:
        m_out << ".CONTROLPANEL.";
        break;
    case IfcElectricDistributionPointFunctionEnum_DISTRIBUTIONBOARD:
        m_out << ".DISTRIBUTIONBOARD.";
        break;
    case IfcElectricDistributionPointFunctionEnum_GASDETECTORPANEL:
        m_out << ".GASDETECTORPANEL.";
        break;
    case IfcElectricDistributionPointFunctionEnum_INDICATORPANEL:
        m_out << ".INDICATORPANEL.";
        break;
    case IfcElectricDistributionPointFunctionEnum_MIMICPANEL:
        m_out << ".MIMICPANEL.";
        break;
    case IfcElectricDistributionPointFunctionEnum_MOTORCONTROLCENTRE:
        m_out << ".MOTORCONTROLCENTRE.";
        break;
    case IfcElectricDistributionPointFunctionEnum_SWITCHBOARD:
        m_out << ".SWITCHBOARD.";
        break;
    case IfcElectricDistributionPointFunctionEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricDistributionPointFunctionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricDistributionPoint(IfcElectricDistributionPoint *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICDISTRIBUTIONPOINT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDistributionPointFunction())) {
        m_out << "$";
    }
    else {
        writeIfcElectricDistributionPointFunctionEnum(value->getDistributionPointFunction());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedFunction())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedFunction());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricFlowStorageDeviceTypeEnum(IfcElectricFlowStorageDeviceTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricFlowStorageDeviceTypeEnum_BATTERY:
        m_out << ".BATTERY.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_CAPACITORBANK:
        m_out << ".CAPACITORBANK.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_HARMONICFILTER:
        m_out << ".HARMONICFILTER.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_INDUCTORBANK:
        m_out << ".INDUCTORBANK.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_UPS:
        m_out << ".UPS.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricFlowStorageDeviceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricFlowStorageDeviceType(IfcElectricFlowStorageDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICFLOWSTORAGEDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricFlowStorageDeviceTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricGeneratorTypeEnum(IfcElectricGeneratorTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricGeneratorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricGeneratorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricGeneratorType(IfcElectricGeneratorType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICGENERATORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricGeneratorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricHeaterTypeEnum(IfcElectricHeaterTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricHeaterTypeEnum_ELECTRICPOINTHEATER:
        m_out << ".ELECTRICPOINTHEATER.";
        break;
    case IfcElectricHeaterTypeEnum_ELECTRICCABLEHEATER:
        m_out << ".ELECTRICCABLEHEATER.";
        break;
    case IfcElectricHeaterTypeEnum_ELECTRICMATHEATER:
        m_out << ".ELECTRICMATHEATER.";
        break;
    case IfcElectricHeaterTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricHeaterTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricHeaterType(IfcElectricHeaterType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICHEATERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricHeaterTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricMotorTypeEnum(IfcElectricMotorTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricMotorTypeEnum_DC:
        m_out << ".DC.";
        break;
    case IfcElectricMotorTypeEnum_INDUCTION:
        m_out << ".INDUCTION.";
        break;
    case IfcElectricMotorTypeEnum_POLYPHASE:
        m_out << ".POLYPHASE.";
        break;
    case IfcElectricMotorTypeEnum_RELUCTANCESYNCHRONOUS:
        m_out << ".RELUCTANCESYNCHRONOUS.";
        break;
    case IfcElectricMotorTypeEnum_SYNCHRONOUS:
        m_out << ".SYNCHRONOUS.";
        break;
    case IfcElectricMotorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricMotorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricMotorType(IfcElectricMotorType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICMOTORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricMotorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcElectricTimeControlTypeEnum(IfcElectricTimeControlTypeEnum enumData) {
    switch(enumData) {
    case IfcElectricTimeControlTypeEnum_TIMECLOCK:
        m_out << ".TIMECLOCK.";
        break;
    case IfcElectricTimeControlTypeEnum_TIMEDELAY:
        m_out << ".TIMEDELAY.";
        break;
    case IfcElectricTimeControlTypeEnum_RELAY:
        m_out << ".RELAY.";
        break;
    case IfcElectricTimeControlTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElectricTimeControlTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricTimeControlType(IfcElectricTimeControlType *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICTIMECONTROLTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricTimeControlTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcEnergySequenceEnum(IfcEnergySequenceEnum enumData) {
    switch(enumData) {
    case IfcEnergySequenceEnum_PRIMARY:
        m_out << ".PRIMARY.";
        break;
    case IfcEnergySequenceEnum_SECONDARY:
        m_out << ".SECONDARY.";
        break;
    case IfcEnergySequenceEnum_TERTIARY:
        m_out << ".TERTIARY.";
        break;
    case IfcEnergySequenceEnum_AUXILIARY:
        m_out << ".AUXILIARY.";
        break;
    case IfcEnergySequenceEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcEnergySequenceEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcElectricCurrentEnum(IfcElectricCurrentEnum enumData) {
    switch(enumData) {
    case IfcElectricCurrentEnum_ALTERNATING:
        m_out << ".ALTERNATING.";
        break;
    case IfcElectricCurrentEnum_DIRECT:
        m_out << ".DIRECT.";
        break;
    case IfcElectricCurrentEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElectricalBaseProperties(IfcElectricalBaseProperties *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICALBASEPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getEnergySequence())) {
        m_out << "$";
    }
    else {
        writeIfcEnergySequenceEnum(value->getEnergySequence());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedEnergySequence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedEnergySequence());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getElectricCurrentType())) {
        m_out << "$";
    }
    else {
        writeIfcElectricCurrentEnum(value->getElectricCurrentType());
    }
    m_out << ",";
    if (Step::isUnset(value->getInputVoltage())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInputVoltage());
    }
    m_out << ",";
    if (Step::isUnset(value->getInputFrequency())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInputFrequency());
    }
    m_out << ",";
    if (Step::isUnset(value->getFullLoadCurrent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFullLoadCurrent());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumCircuitCurrent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumCircuitCurrent());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumPowerInput())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumPowerInput());
    }
    m_out << ",";
    if (Step::isUnset(value->getRatedPowerInput())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRatedPowerInput());
    }
    m_out << ",";
    if (Step::isUnset(value->getInputPhase())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInputPhase());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElectricalCircuit(IfcElectricalCircuit *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICALCIRCUIT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElectricalElement(IfcElectricalElement *value) {
    m_out << "#" << value->getKey() << "=IFCELECTRICALELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElement(IfcElement *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAssemblyPlaceEnum(IfcAssemblyPlaceEnum enumData) {
    switch(enumData) {
    case IfcAssemblyPlaceEnum_SITE:
        m_out << ".SITE.";
        break;
    case IfcAssemblyPlaceEnum_FACTORY:
        m_out << ".FACTORY.";
        break;
    case IfcAssemblyPlaceEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcElementAssemblyTypeEnum(IfcElementAssemblyTypeEnum enumData) {
    switch(enumData) {
    case IfcElementAssemblyTypeEnum_ACCESSORY_ASSEMBLY:
        m_out << ".ACCESSORY_ASSEMBLY.";
        break;
    case IfcElementAssemblyTypeEnum_ARCH:
        m_out << ".ARCH.";
        break;
    case IfcElementAssemblyTypeEnum_BEAM_GRID:
        m_out << ".BEAM_GRID.";
        break;
    case IfcElementAssemblyTypeEnum_BRACED_FRAME:
        m_out << ".BRACED_FRAME.";
        break;
    case IfcElementAssemblyTypeEnum_GIRDER:
        m_out << ".GIRDER.";
        break;
    case IfcElementAssemblyTypeEnum_REINFORCEMENT_UNIT:
        m_out << ".REINFORCEMENT_UNIT.";
        break;
    case IfcElementAssemblyTypeEnum_RIGID_FRAME:
        m_out << ".RIGID_FRAME.";
        break;
    case IfcElementAssemblyTypeEnum_SLAB_FIELD:
        m_out << ".SLAB_FIELD.";
        break;
    case IfcElementAssemblyTypeEnum_TRUSS:
        m_out << ".TRUSS.";
        break;
    case IfcElementAssemblyTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcElementAssemblyTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcElementAssembly(IfcElementAssembly *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTASSEMBLY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getAssemblyPlace())) {
        m_out << "$";
    }
    else {
        writeIfcAssemblyPlaceEnum(value->getAssemblyPlace());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcElementAssemblyTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElementComponent(IfcElementComponent *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTCOMPONENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElementComponentType(IfcElementComponentType *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTCOMPONENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElementQuantity(IfcElementQuantity *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTQUANTITY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getMethodOfMeasurement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMethodOfMeasurement());
    }
    m_out << ",";
    if (Step::isUnset(value->getQuantities())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPhysicalQuantity_1_n::iterator step_it0 = (value->getQuantities()).begin();
            if ((value->getQuantities()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getQuantities()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElementType(IfcElementType *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcElementarySurface(IfcElementarySurface *value) {
    m_out << "#" << value->getKey() << "=IFCELEMENTARYSURFACE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEllipse(IfcEllipse *value) {
    m_out << "#" << value->getKey() << "=IFCELLIPSE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getSemiAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSemiAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getSemiAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSemiAxis2());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEllipseProfileDef(IfcEllipseProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCELLIPSEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getSemiAxis1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSemiAxis1());
    }
    m_out << ",";
    if (Step::isUnset(value->getSemiAxis2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSemiAxis2());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEnergyConversionDevice(IfcEnergyConversionDevice *value) {
    m_out << "#" << value->getKey() << "=IFCENERGYCONVERSIONDEVICE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEnergyConversionDeviceType(IfcEnergyConversionDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCENERGYCONVERSIONDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEnergyProperties(IfcEnergyProperties *value) {
    m_out << "#" << value->getKey() << "=IFCENERGYPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getEnergySequence())) {
        m_out << "$";
    }
    else {
        writeIfcEnergySequenceEnum(value->getEnergySequence());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedEnergySequence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedEnergySequence());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcEnvironmentalImpactCategoryEnum(IfcEnvironmentalImpactCategoryEnum enumData) {
    switch(enumData) {
    case IfcEnvironmentalImpactCategoryEnum_COMBINEDVALUE:
        m_out << ".COMBINEDVALUE.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_DISPOSAL:
        m_out << ".DISPOSAL.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_EXTRACTION:
        m_out << ".EXTRACTION.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_INSTALLATION:
        m_out << ".INSTALLATION.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_MANUFACTURE:
        m_out << ".MANUFACTURE.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_TRANSPORTATION:
        m_out << ".TRANSPORTATION.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcEnvironmentalImpactCategoryEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcEnvironmentalImpactValue(IfcEnvironmentalImpactValue *value) {
    m_out << "#" << value->getKey() << "=IFCENVIRONMENTALIMPACTVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedValue())) {
        m_out << "$";
    }
    else {
        writeIfcAppliedValueSelect(value->getAppliedValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnitBasis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnitBasis());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getApplicableDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getFixedUntilDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFixedUntilDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getImpactType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getImpactType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCategory())) {
        m_out << "$";
    }
    else {
        writeIfcEnvironmentalImpactCategoryEnum(value->getCategory());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedCategory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedCategory());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEquipmentElement(IfcEquipmentElement *value) {
    m_out << "#" << value->getKey() << "=IFCEQUIPMENTELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcEquipmentStandard(IfcEquipmentStandard *value) {
    m_out << "#" << value->getKey() << "=IFCEQUIPMENTSTANDARD(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcEvaporativeCoolerTypeEnum(IfcEvaporativeCoolerTypeEnum enumData) {
    switch(enumData) {
    case IfcEvaporativeCoolerTypeEnum_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER:
        m_out << ".DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER:
        m_out << ".DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER:
        m_out << ".DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER:
        m_out << ".DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_DIRECTEVAPORATIVEAIRWASHER:
        m_out << ".DIRECTEVAPORATIVEAIRWASHER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER:
        m_out << ".INDIRECTEVAPORATIVEPACKAGEAIRCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_INDIRECTEVAPORATIVEWETCOIL:
        m_out << ".INDIRECTEVAPORATIVEWETCOIL.";
        break;
    case IfcEvaporativeCoolerTypeEnum_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER:
        m_out << ".INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER.";
        break;
    case IfcEvaporativeCoolerTypeEnum_INDIRECTDIRECTCOMBINATION:
        m_out << ".INDIRECTDIRECTCOMBINATION.";
        break;
    case IfcEvaporativeCoolerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcEvaporativeCoolerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcEvaporativeCoolerType(IfcEvaporativeCoolerType *value) {
    m_out << "#" << value->getKey() << "=IFCEVAPORATIVECOOLERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcEvaporativeCoolerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcEvaporatorTypeEnum(IfcEvaporatorTypeEnum enumData) {
    switch(enumData) {
    case IfcEvaporatorTypeEnum_DIRECTEXPANSIONSHELLANDTUBE:
        m_out << ".DIRECTEXPANSIONSHELLANDTUBE.";
        break;
    case IfcEvaporatorTypeEnum_DIRECTEXPANSIONTUBEINTUBE:
        m_out << ".DIRECTEXPANSIONTUBEINTUBE.";
        break;
    case IfcEvaporatorTypeEnum_DIRECTEXPANSIONBRAZEDPLATE:
        m_out << ".DIRECTEXPANSIONBRAZEDPLATE.";
        break;
    case IfcEvaporatorTypeEnum_FLOODEDSHELLANDTUBE:
        m_out << ".FLOODEDSHELLANDTUBE.";
        break;
    case IfcEvaporatorTypeEnum_SHELLANDCOIL:
        m_out << ".SHELLANDCOIL.";
        break;
    case IfcEvaporatorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcEvaporatorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcEvaporatorType(IfcEvaporatorType *value) {
    m_out << "#" << value->getKey() << "=IFCEVAPORATORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcEvaporatorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExtendedMaterialProperties(IfcExtendedMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCEXTENDEDMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getExtendedProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getExtendedProperties()).begin();
            if ((value->getExtendedProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getExtendedProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExternalReference(IfcExternalReference *value) {
    m_out << "#" << value->getKey() << "=IFCEXTERNALREFERENCE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExternallyDefinedHatchStyle(IfcExternallyDefinedHatchStyle *value) {
    m_out << "#" << value->getKey() << "=IFCEXTERNALLYDEFINEDHATCHSTYLE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExternallyDefinedSurfaceStyle(IfcExternallyDefinedSurfaceStyle *value) {
    m_out << "#" << value->getKey() << "=IFCEXTERNALLYDEFINEDSURFACESTYLE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExternallyDefinedSymbol(IfcExternallyDefinedSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCEXTERNALLYDEFINEDSYMBOL(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExternallyDefinedTextFont(IfcExternallyDefinedTextFont *value) {
    m_out << "#" << value->getKey() << "=IFCEXTERNALLYDEFINEDTEXTFONT(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcExtrudedAreaSolid(IfcExtrudedAreaSolid *value) {
    m_out << "#" << value->getKey() << "=IFCEXTRUDEDAREASOLID(";
    if (Step::isUnset(value->getSweptArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getExtrudedDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExtrudedDirection());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFace(IfcFace *value) {
    m_out << "#" << value->getKey() << "=IFCFACE(";
    if (Step::isUnset(value->getBounds())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFaceBound_1_n::iterator step_it0 = (value->getBounds()).begin();
            if ((value->getBounds()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getBounds()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFaceBasedSurfaceModel(IfcFaceBasedSurfaceModel *value) {
    m_out << "#" << value->getKey() << "=IFCFACEBASEDSURFACEMODEL(";
    if (Step::isUnset(value->getFbsmFaces())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcConnectedFaceSet_1_n::iterator step_it0 = (value->getFbsmFaces()).begin();
            if ((value->getFbsmFaces()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getFbsmFaces()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFaceBound(IfcFaceBound *value) {
    m_out << "#" << value->getKey() << "=IFCFACEBOUND(";
    if (Step::isUnset(value->getBound())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBound());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFaceOuterBound(IfcFaceOuterBound *value) {
    m_out << "#" << value->getKey() << "=IFCFACEOUTERBOUND(";
    if (Step::isUnset(value->getBound())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBound());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFaceSurface(IfcFaceSurface *value) {
    m_out << "#" << value->getKey() << "=IFCFACESURFACE(";
    if (Step::isUnset(value->getBounds())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFaceBound_1_n::iterator step_it0 = (value->getBounds()).begin();
            if ((value->getBounds()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getBounds()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getFaceSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFaceSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getSameSense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSameSense());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFacetedBrep(IfcFacetedBrep *value) {
    m_out << "#" << value->getKey() << "=IFCFACETEDBREP(";
    if (Step::isUnset(value->getOuter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuter());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFacetedBrepWithVoids(IfcFacetedBrepWithVoids *value) {
    m_out << "#" << value->getKey() << "=IFCFACETEDBREPWITHVOIDS(";
    if (Step::isUnset(value->getOuter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuter());
    }
    m_out << ",";
    if (Step::isUnset(value->getVoids())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcClosedShell_1_n::iterator step_it0 = (value->getVoids()).begin();
            if ((value->getVoids()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getVoids()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFailureConnectionCondition(IfcFailureConnectionCondition *value) {
    m_out << "#" << value->getKey() << "=IFCFAILURECONNECTIONCONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getTensionFailureX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTensionFailureX());
    }
    m_out << ",";
    if (Step::isUnset(value->getTensionFailureY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTensionFailureY());
    }
    m_out << ",";
    if (Step::isUnset(value->getTensionFailureZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTensionFailureZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getCompressionFailureX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCompressionFailureX());
    }
    m_out << ",";
    if (Step::isUnset(value->getCompressionFailureY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCompressionFailureY());
    }
    m_out << ",";
    if (Step::isUnset(value->getCompressionFailureZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCompressionFailureZ());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFanTypeEnum(IfcFanTypeEnum enumData) {
    switch(enumData) {
    case IfcFanTypeEnum_CENTRIFUGALFORWARDCURVED:
        m_out << ".CENTRIFUGALFORWARDCURVED.";
        break;
    case IfcFanTypeEnum_CENTRIFUGALRADIAL:
        m_out << ".CENTRIFUGALRADIAL.";
        break;
    case IfcFanTypeEnum_CENTRIFUGALBACKWARDINCLINEDCURVED:
        m_out << ".CENTRIFUGALBACKWARDINCLINEDCURVED.";
        break;
    case IfcFanTypeEnum_CENTRIFUGALAIRFOIL:
        m_out << ".CENTRIFUGALAIRFOIL.";
        break;
    case IfcFanTypeEnum_TUBEAXIAL:
        m_out << ".TUBEAXIAL.";
        break;
    case IfcFanTypeEnum_VANEAXIAL:
        m_out << ".VANEAXIAL.";
        break;
    case IfcFanTypeEnum_PROPELLORAXIAL:
        m_out << ".PROPELLORAXIAL.";
        break;
    case IfcFanTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFanTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFanType(IfcFanType *value) {
    m_out << "#" << value->getKey() << "=IFCFANTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFanTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFastener(IfcFastener *value) {
    m_out << "#" << value->getKey() << "=IFCFASTENER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFastenerType(IfcFastenerType *value) {
    m_out << "#" << value->getKey() << "=IFCFASTENERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFeatureElement(IfcFeatureElement *value) {
    m_out << "#" << value->getKey() << "=IFCFEATUREELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFeatureElementAddition(IfcFeatureElementAddition *value) {
    m_out << "#" << value->getKey() << "=IFCFEATUREELEMENTADDITION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFeatureElementSubtraction(IfcFeatureElementSubtraction *value) {
    m_out << "#" << value->getKey() << "=IFCFEATUREELEMENTSUBTRACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFillStyleSelect(IfcFillStyleSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcFillStyleSelect::IFCFILLAREASTYLEHATCHING:
        writeAttribute(selectData->getIfcFillAreaStyleHatching());
        break;
    case IfcFillStyleSelect::IFCFILLAREASTYLETILES:
        writeAttribute(selectData->getIfcFillAreaStyleTiles());
        break;
    case IfcFillStyleSelect::IFCCOLOURSPECIFICATION:
        writeAttribute(selectData->getIfcColourSpecification());
        break;
    case IfcFillStyleSelect::IFCPREDEFINEDCOLOUR:
        writeAttribute(selectData->getIfcPreDefinedColour());
        break;
    case IfcFillStyleSelect::IFCEXTERNALLYDEFINEDHATCHSTYLE:
        writeAttribute(selectData->getIfcExternallyDefinedHatchStyle());
        break;
        }
}

bool SPFWriter::visitIfcFillAreaStyle(IfcFillAreaStyle *value) {
    m_out << "#" << value->getKey() << "=IFCFILLAREASTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getFillStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFillStyleSelect_1_n::iterator step_it0 = (value->getFillStyles()).begin();
            if ((value->getFillStyles()).size()) {
                writeIfcFillStyleSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getFillStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcFillStyleSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcHatchLineDistanceSelect(IfcHatchLineDistanceSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcHatchLineDistanceSelect::IFCONEDIRECTIONREPEATFACTOR:
        writeAttribute(selectData->getIfcOneDirectionRepeatFactor());
        break;
    case IfcHatchLineDistanceSelect::IFCPOSITIVELENGTHMEASURE:
        m_out << "IFCPOSITIVELENGTHMEASURE(";
        writeAttribute(selectData->getIfcPositiveLengthMeasure());
        m_out << ")";
        break;
        }
}

bool SPFWriter::visitIfcFillAreaStyleHatching(IfcFillAreaStyleHatching *value) {
    m_out << "#" << value->getKey() << "=IFCFILLAREASTYLEHATCHING(";
    if (Step::isUnset(value->getHatchLineAppearance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHatchLineAppearance());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartOfNextHatchLine())) {
        m_out << "$";
    }
    else {
        writeIfcHatchLineDistanceSelect(value->getStartOfNextHatchLine());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointOfReferenceHatchLine())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPointOfReferenceHatchLine());
    }
    m_out << ",";
    if (Step::isUnset(value->getPatternStart())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPatternStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getHatchLineAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHatchLineAngle());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFillAreaStyleTileSymbolWithStyle(IfcFillAreaStyleTileSymbolWithStyle *value) {
    m_out << "#" << value->getKey() << "=IFCFILLAREASTYLETILESYMBOLWITHSTYLE(";
    if (Step::isUnset(value->getSymbol())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSymbol());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFillAreaStyleTileShapeSelect(IfcFillAreaStyleTileShapeSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcFillAreaStyleTileShapeSelect::IFCFILLAREASTYLETILESYMBOLWITHSTYLE:
        writeAttribute(selectData->getIfcFillAreaStyleTileSymbolWithStyle());
        break;
        }
}

bool SPFWriter::visitIfcFillAreaStyleTiles(IfcFillAreaStyleTiles *value) {
    m_out << "#" << value->getKey() << "=IFCFILLAREASTYLETILES(";
    if (Step::isUnset(value->getTilingPattern())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTilingPattern());
    }
    m_out << ",";
    if (Step::isUnset(value->getTiles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFillAreaStyleTileShapeSelect_1_n::iterator step_it0 = (value->getTiles()).begin();
            if ((value->getTiles()).size()) {
                writeIfcFillAreaStyleTileShapeSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTiles()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcFillAreaStyleTileShapeSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTilingScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTilingScale());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFilterTypeEnum(IfcFilterTypeEnum enumData) {
    switch(enumData) {
    case IfcFilterTypeEnum_AIRPARTICLEFILTER:
        m_out << ".AIRPARTICLEFILTER.";
        break;
    case IfcFilterTypeEnum_ODORFILTER:
        m_out << ".ODORFILTER.";
        break;
    case IfcFilterTypeEnum_OILFILTER:
        m_out << ".OILFILTER.";
        break;
    case IfcFilterTypeEnum_STRAINER:
        m_out << ".STRAINER.";
        break;
    case IfcFilterTypeEnum_WATERFILTER:
        m_out << ".WATERFILTER.";
        break;
    case IfcFilterTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFilterTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFilterType(IfcFilterType *value) {
    m_out << "#" << value->getKey() << "=IFCFILTERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFilterTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFireSuppressionTerminalTypeEnum(IfcFireSuppressionTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcFireSuppressionTerminalTypeEnum_BREECHINGINLET:
        m_out << ".BREECHINGINLET.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_FIREHYDRANT:
        m_out << ".FIREHYDRANT.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_HOSEREEL:
        m_out << ".HOSEREEL.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_SPRINKLER:
        m_out << ".SPRINKLER.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_SPRINKLERDEFLECTOR:
        m_out << ".SPRINKLERDEFLECTOR.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFireSuppressionTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFireSuppressionTerminalType(IfcFireSuppressionTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCFIRESUPPRESSIONTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFireSuppressionTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowController(IfcFlowController *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWCONTROLLER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowControllerType(IfcFlowControllerType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWCONTROLLERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowFitting(IfcFlowFitting *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWFITTING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowFittingType(IfcFlowFittingType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWFITTINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFlowInstrumentTypeEnum(IfcFlowInstrumentTypeEnum enumData) {
    switch(enumData) {
    case IfcFlowInstrumentTypeEnum_PRESSUREGAUGE:
        m_out << ".PRESSUREGAUGE.";
        break;
    case IfcFlowInstrumentTypeEnum_THERMOMETER:
        m_out << ".THERMOMETER.";
        break;
    case IfcFlowInstrumentTypeEnum_AMMETER:
        m_out << ".AMMETER.";
        break;
    case IfcFlowInstrumentTypeEnum_FREQUENCYMETER:
        m_out << ".FREQUENCYMETER.";
        break;
    case IfcFlowInstrumentTypeEnum_POWERFACTORMETER:
        m_out << ".POWERFACTORMETER.";
        break;
    case IfcFlowInstrumentTypeEnum_PHASEANGLEMETER:
        m_out << ".PHASEANGLEMETER.";
        break;
    case IfcFlowInstrumentTypeEnum_VOLTMETER_PEAK:
        m_out << ".VOLTMETER_PEAK.";
        break;
    case IfcFlowInstrumentTypeEnum_VOLTMETER_RMS:
        m_out << ".VOLTMETER_RMS.";
        break;
    case IfcFlowInstrumentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFlowInstrumentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFlowInstrumentType(IfcFlowInstrumentType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWINSTRUMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFlowInstrumentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFlowMeterTypeEnum(IfcFlowMeterTypeEnum enumData) {
    switch(enumData) {
    case IfcFlowMeterTypeEnum_ELECTRICMETER:
        m_out << ".ELECTRICMETER.";
        break;
    case IfcFlowMeterTypeEnum_ENERGYMETER:
        m_out << ".ENERGYMETER.";
        break;
    case IfcFlowMeterTypeEnum_FLOWMETER:
        m_out << ".FLOWMETER.";
        break;
    case IfcFlowMeterTypeEnum_GASMETER:
        m_out << ".GASMETER.";
        break;
    case IfcFlowMeterTypeEnum_OILMETER:
        m_out << ".OILMETER.";
        break;
    case IfcFlowMeterTypeEnum_WATERMETER:
        m_out << ".WATERMETER.";
        break;
    case IfcFlowMeterTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFlowMeterTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFlowMeterType(IfcFlowMeterType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWMETERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFlowMeterTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowMovingDevice(IfcFlowMovingDevice *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWMOVINGDEVICE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowMovingDeviceType(IfcFlowMovingDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWMOVINGDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowSegment(IfcFlowSegment *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWSEGMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowSegmentType(IfcFlowSegmentType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWSEGMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowStorageDevice(IfcFlowStorageDevice *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWSTORAGEDEVICE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowStorageDeviceType(IfcFlowStorageDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWSTORAGEDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowTerminal(IfcFlowTerminal *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWTERMINAL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowTerminalType(IfcFlowTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowTreatmentDevice(IfcFlowTreatmentDevice *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWTREATMENTDEVICE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFlowTreatmentDeviceType(IfcFlowTreatmentDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCFLOWTREATMENTDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPropertySourceEnum(IfcPropertySourceEnum enumData) {
    switch(enumData) {
    case IfcPropertySourceEnum_DESIGN:
        m_out << ".DESIGN.";
        break;
    case IfcPropertySourceEnum_DESIGNMAXIMUM:
        m_out << ".DESIGNMAXIMUM.";
        break;
    case IfcPropertySourceEnum_DESIGNMINIMUM:
        m_out << ".DESIGNMINIMUM.";
        break;
    case IfcPropertySourceEnum_SIMULATED:
        m_out << ".SIMULATED.";
        break;
    case IfcPropertySourceEnum_ASBUILT:
        m_out << ".ASBUILT.";
        break;
    case IfcPropertySourceEnum_COMMISSIONING:
        m_out << ".COMMISSIONING.";
        break;
    case IfcPropertySourceEnum_MEASURED:
        m_out << ".MEASURED.";
        break;
    case IfcPropertySourceEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPropertySourceEnum_NOTKNOWN:
        m_out << ".NOTKNOWN.";
        break;
        }
}

void SPFWriter::writeIfcDerivedMeasureValue(IfcDerivedMeasureValue *selectData) {
    switch(selectData->currentType()) {
    case IfcDerivedMeasureValue::IFCVOLUMETRICFLOWRATEMEASURE:
        m_out << "IFCVOLUMETRICFLOWRATEMEASURE(";
        writeAttribute(selectData->getIfcVolumetricFlowRateMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTIMESTAMP:
        m_out << "IFCTIMESTAMP(";
        writeAttribute(selectData->getIfcTimeStamp());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTHERMALTRANSMITTANCEMEASURE:
        m_out << "IFCTHERMALTRANSMITTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalTransmittanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTHERMALRESISTANCEMEASURE:
        m_out << "IFCTHERMALRESISTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalResistanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTHERMALADMITTANCEMEASURE:
        m_out << "IFCTHERMALADMITTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalAdmittanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCPRESSUREMEASURE:
        m_out << "IFCPRESSUREMEASURE(";
        writeAttribute(selectData->getIfcPressureMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCPOWERMEASURE:
        m_out << "IFCPOWERMEASURE(";
        writeAttribute(selectData->getIfcPowerMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMASSFLOWRATEMEASURE:
        m_out << "IFCMASSFLOWRATEMEASURE(";
        writeAttribute(selectData->getIfcMassFlowRateMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMASSDENSITYMEASURE:
        m_out << "IFCMASSDENSITYMEASURE(";
        writeAttribute(selectData->getIfcMassDensityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLINEARVELOCITYMEASURE:
        m_out << "IFCLINEARVELOCITYMEASURE(";
        writeAttribute(selectData->getIfcLinearVelocityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCKINEMATICVISCOSITYMEASURE:
        m_out << "IFCKINEMATICVISCOSITYMEASURE(";
        writeAttribute(selectData->getIfcKinematicViscosityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCINTEGERCOUNTRATEMEASURE:
        m_out << "IFCINTEGERCOUNTRATEMEASURE(";
        writeAttribute(selectData->getIfcIntegerCountRateMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCHEATFLUXDENSITYMEASURE:
        m_out << "IFCHEATFLUXDENSITYMEASURE(";
        writeAttribute(selectData->getIfcHeatFluxDensityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCFREQUENCYMEASURE:
        m_out << "IFCFREQUENCYMEASURE(";
        writeAttribute(selectData->getIfcFrequencyMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCENERGYMEASURE:
        m_out << "IFCENERGYMEASURE(";
        writeAttribute(selectData->getIfcEnergyMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCELECTRICVOLTAGEMEASURE:
        m_out << "IFCELECTRICVOLTAGEMEASURE(";
        writeAttribute(selectData->getIfcElectricVoltageMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCDYNAMICVISCOSITYMEASURE:
        m_out << "IFCDYNAMICVISCOSITYMEASURE(";
        writeAttribute(selectData->getIfcDynamicViscosityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCCOMPOUNDPLANEANGLEMEASURE:
        m_out << "IFCCOMPOUNDPLANEANGLEMEASURE(";
        m_out << "(";
        {
            IfcCompoundPlaneAngleMeasure::iterator step_it0 = (selectData->getIfcCompoundPlaneAngleMeasure()).begin();
            if ((selectData->getIfcCompoundPlaneAngleMeasure()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (selectData->getIfcCompoundPlaneAngleMeasure()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCANGULARVELOCITYMEASURE:
        m_out << "IFCANGULARVELOCITYMEASURE(";
        writeAttribute(selectData->getIfcAngularVelocityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTHERMALCONDUCTIVITYMEASURE:
        m_out << "IFCTHERMALCONDUCTIVITYMEASURE(";
        writeAttribute(selectData->getIfcThermalConductivityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMOLECULARWEIGHTMEASURE:
        m_out << "IFCMOLECULARWEIGHTMEASURE(";
        writeAttribute(selectData->getIfcMolecularWeightMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCVAPORPERMEABILITYMEASURE:
        m_out << "IFCVAPORPERMEABILITYMEASURE(";
        writeAttribute(selectData->getIfcVaporPermeabilityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMOISTUREDIFFUSIVITYMEASURE:
        m_out << "IFCMOISTUREDIFFUSIVITYMEASURE(";
        writeAttribute(selectData->getIfcMoistureDiffusivityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCISOTHERMALMOISTURECAPACITYMEASURE:
        m_out << "IFCISOTHERMALMOISTURECAPACITYMEASURE(";
        writeAttribute(selectData->getIfcIsothermalMoistureCapacityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSPECIFICHEATCAPACITYMEASURE:
        m_out << "IFCSPECIFICHEATCAPACITYMEASURE(";
        writeAttribute(selectData->getIfcSpecificHeatCapacityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMONETARYMEASURE:
        m_out << "IFCMONETARYMEASURE(";
        writeAttribute(selectData->getIfcMonetaryMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMAGNETICFLUXDENSITYMEASURE:
        m_out << "IFCMAGNETICFLUXDENSITYMEASURE(";
        writeAttribute(selectData->getIfcMagneticFluxDensityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMAGNETICFLUXMEASURE:
        m_out << "IFCMAGNETICFLUXMEASURE(";
        writeAttribute(selectData->getIfcMagneticFluxMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLUMINOUSFLUXMEASURE:
        m_out << "IFCLUMINOUSFLUXMEASURE(";
        writeAttribute(selectData->getIfcLuminousFluxMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCFORCEMEASURE:
        m_out << "IFCFORCEMEASURE(";
        writeAttribute(selectData->getIfcForceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCINDUCTANCEMEASURE:
        m_out << "IFCINDUCTANCEMEASURE(";
        writeAttribute(selectData->getIfcInductanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCILLUMINANCEMEASURE:
        m_out << "IFCILLUMINANCEMEASURE(";
        writeAttribute(selectData->getIfcIlluminanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCELECTRICRESISTANCEMEASURE:
        m_out << "IFCELECTRICRESISTANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricResistanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCELECTRICCONDUCTANCEMEASURE:
        m_out << "IFCELECTRICCONDUCTANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricConductanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCELECTRICCHARGEMEASURE:
        m_out << "IFCELECTRICCHARGEMEASURE(";
        writeAttribute(selectData->getIfcElectricChargeMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCDOSEEQUIVALENTMEASURE:
        m_out << "IFCDOSEEQUIVALENTMEASURE(";
        writeAttribute(selectData->getIfcDoseEquivalentMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCELECTRICCAPACITANCEMEASURE:
        m_out << "IFCELECTRICCAPACITANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricCapacitanceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCABSORBEDDOSEMEASURE:
        m_out << "IFCABSORBEDDOSEMEASURE(";
        writeAttribute(selectData->getIfcAbsorbedDoseMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCRADIOACTIVITYMEASURE:
        m_out << "IFCRADIOACTIVITYMEASURE(";
        writeAttribute(selectData->getIfcRadioActivityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCROTATIONALFREQUENCYMEASURE:
        m_out << "IFCROTATIONALFREQUENCYMEASURE(";
        writeAttribute(selectData->getIfcRotationalFrequencyMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTORQUEMEASURE:
        m_out << "IFCTORQUEMEASURE(";
        writeAttribute(selectData->getIfcTorqueMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCACCELERATIONMEASURE:
        m_out << "IFCACCELERATIONMEASURE(";
        writeAttribute(selectData->getIfcAccelerationMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLINEARFORCEMEASURE:
        m_out << "IFCLINEARFORCEMEASURE(";
        writeAttribute(selectData->getIfcLinearForceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLINEARSTIFFNESSMEASURE:
        m_out << "IFCLINEARSTIFFNESSMEASURE(";
        writeAttribute(selectData->getIfcLinearStiffnessMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMODULUSOFSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMODULUSOFELASTICITYMEASURE:
        m_out << "IFCMODULUSOFELASTICITYMEASURE(";
        writeAttribute(selectData->getIfcModulusOfElasticityMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMOMENTOFINERTIAMEASURE:
        m_out << "IFCMOMENTOFINERTIAMEASURE(";
        writeAttribute(selectData->getIfcMomentOfInertiaMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCPLANARFORCEMEASURE:
        m_out << "IFCPLANARFORCEMEASURE(";
        writeAttribute(selectData->getIfcPlanarForceMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCROTATIONALSTIFFNESSMEASURE:
        m_out << "IFCROTATIONALSTIFFNESSMEASURE(";
        writeAttribute(selectData->getIfcRotationalStiffnessMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSHEARMODULUSMEASURE:
        m_out << "IFCSHEARMODULUSMEASURE(";
        writeAttribute(selectData->getIfcShearModulusMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLINEARMOMENTMEASURE:
        m_out << "IFCLINEARMOMENTMEASURE(";
        writeAttribute(selectData->getIfcLinearMomentMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE:
        m_out << "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE(";
        writeAttribute(selectData->getIfcLuminousIntensityDistributionMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCCURVATUREMEASURE:
        m_out << "IFCCURVATUREMEASURE(";
        writeAttribute(selectData->getIfcCurvatureMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMASSPERLENGTHMEASURE:
        m_out << "IFCMASSPERLENGTHMEASURE(";
        writeAttribute(selectData->getIfcMassPerLengthMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfLinearSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfRotationalSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCROTATIONALMASSMEASURE:
        m_out << "IFCROTATIONALMASSMEASURE(";
        writeAttribute(selectData->getIfcRotationalMassMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSECTIONALAREAINTEGRALMEASURE:
        m_out << "IFCSECTIONALAREAINTEGRALMEASURE(";
        writeAttribute(selectData->getIfcSectionalAreaIntegralMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSECTIONMODULUSMEASURE:
        m_out << "IFCSECTIONMODULUSMEASURE(";
        writeAttribute(selectData->getIfcSectionModulusMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTEMPERATUREGRADIENTMEASURE:
        m_out << "IFCTEMPERATUREGRADIENTMEASURE(";
        writeAttribute(selectData->getIfcTemperatureGradientMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCTHERMALEXPANSIONCOEFFICIENTMEASURE:
        m_out << "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE(";
        writeAttribute(selectData->getIfcThermalExpansionCoefficientMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCWARPINGCONSTANTMEASURE:
        m_out << "IFCWARPINGCONSTANTMEASURE(";
        writeAttribute(selectData->getIfcWarpingConstantMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCWARPINGMOMENTMEASURE:
        m_out << "IFCWARPINGMOMENTMEASURE(";
        writeAttribute(selectData->getIfcWarpingMomentMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSOUNDPOWERMEASURE:
        m_out << "IFCSOUNDPOWERMEASURE(";
        writeAttribute(selectData->getIfcSoundPowerMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCSOUNDPRESSUREMEASURE:
        m_out << "IFCSOUNDPRESSUREMEASURE(";
        writeAttribute(selectData->getIfcSoundPressureMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCHEATINGVALUEMEASURE:
        m_out << "IFCHEATINGVALUEMEASURE(";
        writeAttribute(selectData->getIfcHeatingValueMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCPHMEASURE:
        m_out << "IFCPHMEASURE(";
        writeAttribute(selectData->getIfcPHMeasure());
        m_out << ")";
        break;
    case IfcDerivedMeasureValue::IFCIONCONCENTRATIONMEASURE:
        m_out << "IFCIONCONCENTRATIONMEASURE(";
        writeAttribute(selectData->getIfcIonConcentrationMeasure());
        m_out << ")";
        break;
        }
}

bool SPFWriter::visitIfcFluidFlowProperties(IfcFluidFlowProperties *value) {
    m_out << "#" << value->getKey() << "=IFCFLUIDFLOWPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPropertySource())) {
        m_out << "$";
    }
    else {
        writeIfcPropertySourceEnum(value->getPropertySource());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlowConditionTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlowConditionTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getVelocityTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVelocityTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlowrateTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlowrateTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getFluid())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFluid());
    }
    m_out << ",";
    if (Step::isUnset(value->getPressureTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPressureTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedPropertySource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedPropertySource());
    }
    m_out << ",";
    if (Step::isUnset(value->getTemperatureSingleValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTemperatureSingleValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getWetBulbTemperatureSingleValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWetBulbTemperatureSingleValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getWetBulbTemperatureTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWetBulbTemperatureTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getTemperatureTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTemperatureTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlowrateSingleValue())) {
        m_out << "$";
    }
    else {
        writeIfcDerivedMeasureValue(value->getFlowrateSingleValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlowConditionSingleValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlowConditionSingleValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getVelocitySingleValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVelocitySingleValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getPressureSingleValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPressureSingleValue());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcFootingTypeEnum(IfcFootingTypeEnum enumData) {
    switch(enumData) {
    case IfcFootingTypeEnum_FOOTING_BEAM:
        m_out << ".FOOTING_BEAM.";
        break;
    case IfcFootingTypeEnum_PAD_FOOTING:
        m_out << ".PAD_FOOTING.";
        break;
    case IfcFootingTypeEnum_PILE_CAP:
        m_out << ".PILE_CAP.";
        break;
    case IfcFootingTypeEnum_STRIP_FOOTING:
        m_out << ".STRIP_FOOTING.";
        break;
    case IfcFootingTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcFootingTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcFooting(IfcFooting *value) {
    m_out << "#" << value->getKey() << "=IFCFOOTING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcFootingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFuelProperties(IfcFuelProperties *value) {
    m_out << "#" << value->getKey() << "=IFCFUELPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getCombustionTemperature())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCombustionTemperature());
    }
    m_out << ",";
    if (Step::isUnset(value->getCarbonContent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCarbonContent());
    }
    m_out << ",";
    if (Step::isUnset(value->getLowerHeatingValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLowerHeatingValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getHigherHeatingValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHigherHeatingValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFurnishingElement(IfcFurnishingElement *value) {
    m_out << "#" << value->getKey() << "=IFCFURNISHINGELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFurnishingElementType(IfcFurnishingElementType *value) {
    m_out << "#" << value->getKey() << "=IFCFURNISHINGELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFurnitureStandard(IfcFurnitureStandard *value) {
    m_out << "#" << value->getKey() << "=IFCFURNITURESTANDARD(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcFurnitureType(IfcFurnitureType *value) {
    m_out << "#" << value->getKey() << "=IFCFURNITURETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getAssemblyPlace())) {
        m_out << "$";
    }
    else {
        writeIfcAssemblyPlaceEnum(value->getAssemblyPlace());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcGasTerminalTypeEnum(IfcGasTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcGasTerminalTypeEnum_GASAPPLIANCE:
        m_out << ".GASAPPLIANCE.";
        break;
    case IfcGasTerminalTypeEnum_GASBOOSTER:
        m_out << ".GASBOOSTER.";
        break;
    case IfcGasTerminalTypeEnum_GASBURNER:
        m_out << ".GASBURNER.";
        break;
    case IfcGasTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcGasTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcGasTerminalType(IfcGasTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCGASTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcGasTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGeneralMaterialProperties(IfcGeneralMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCGENERALMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getMolecularWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMolecularWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getPorosity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPorosity());
    }
    m_out << ",";
    if (Step::isUnset(value->getMassDensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMassDensity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGeneralProfileProperties(IfcGeneralProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCGENERALPROFILEPROPERTIES(";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getPhysicalWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPhysicalWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getPerimeter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPerimeter());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCrossSectionArea());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcGeometricSetSelect(IfcGeometricSetSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcGeometricSetSelect::IFCPOINT:
        writeAttribute(selectData->getIfcPoint());
        break;
    case IfcGeometricSetSelect::IFCCURVE:
        writeAttribute(selectData->getIfcCurve());
        break;
    case IfcGeometricSetSelect::IFCSURFACE:
        writeAttribute(selectData->getIfcSurface());
        break;
        }
}

bool SPFWriter::visitIfcGeometricCurveSet(IfcGeometricCurveSet *value) {
    m_out << "#" << value->getKey() << "=IFCGEOMETRICCURVESET(";
    if (Step::isUnset(value->getElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcGeometricSetSelect_1_n::iterator step_it0 = (value->getElements()).begin();
            if ((value->getElements()).size()) {
                writeIfcGeometricSetSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getElements()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcGeometricSetSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGeometricRepresentationContext(IfcGeometricRepresentationContext *value) {
    m_out << "#" << value->getKey() << "=IFCGEOMETRICREPRESENTATIONCONTEXT(";
    if (Step::isUnset(value->getContextIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getContextType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextType());
    }
    m_out << ",";
    if (Step::isUnset(value->getCoordinateSpaceDimension())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCoordinateSpaceDimension());
    }
    m_out << ",";
    if (Step::isUnset(value->getPrecision())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPrecision());
    }
    m_out << ",";
    if (Step::isUnset(value->getWorldCoordinateSystem())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getWorldCoordinateSystem());
    }
    m_out << ",";
    if (Step::isUnset(value->getTrueNorth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTrueNorth());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGeometricRepresentationItem(IfcGeometricRepresentationItem *value) {
    m_out << "#" << value->getKey() << "=IFCGEOMETRICREPRESENTATIONITEM(";
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcGeometricProjectionEnum(IfcGeometricProjectionEnum enumData) {
    switch(enumData) {
    case IfcGeometricProjectionEnum_GRAPH_VIEW:
        m_out << ".GRAPH_VIEW.";
        break;
    case IfcGeometricProjectionEnum_SKETCH_VIEW:
        m_out << ".SKETCH_VIEW.";
        break;
    case IfcGeometricProjectionEnum_MODEL_VIEW:
        m_out << ".MODEL_VIEW.";
        break;
    case IfcGeometricProjectionEnum_PLAN_VIEW:
        m_out << ".PLAN_VIEW.";
        break;
    case IfcGeometricProjectionEnum_REFLECTED_PLAN_VIEW:
        m_out << ".REFLECTED_PLAN_VIEW.";
        break;
    case IfcGeometricProjectionEnum_SECTION_VIEW:
        m_out << ".SECTION_VIEW.";
        break;
    case IfcGeometricProjectionEnum_ELEVATION_VIEW:
        m_out << ".ELEVATION_VIEW.";
        break;
    case IfcGeometricProjectionEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcGeometricProjectionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcGeometricRepresentationSubContext(IfcGeometricRepresentationSubContext *value) {
    m_out << "#" << value->getKey() << "=IFCGEOMETRICREPRESENTATIONSUBCONTEXT(";
    if (Step::isUnset(value->getContextIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getContextType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextType());
    }
    m_out << ",";
    m_out << "*";
    m_out << ",";
    m_out << "*";
    m_out << ",";
    m_out << "*";
    m_out << ",";
    m_out << "*";
    m_out << ",";
    if (Step::isUnset(value->getParentContext())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParentContext());
    }
    m_out << ",";
    if (Step::isUnset(value->getTargetScale())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTargetScale());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTargetView())) {
        m_out << "$";
    }
    else {
        writeIfcGeometricProjectionEnum(value->getTargetView());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedTargetView())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedTargetView());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGeometricSet(IfcGeometricSet *value) {
    m_out << "#" << value->getKey() << "=IFCGEOMETRICSET(";
    if (Step::isUnset(value->getElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcGeometricSetSelect_1_n::iterator step_it0 = (value->getElements()).begin();
            if ((value->getElements()).size()) {
                writeIfcGeometricSetSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getElements()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcGeometricSetSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGrid(IfcGrid *value) {
    m_out << "#" << value->getKey() << "=IFCGRID(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getUAxes())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcGridAxis_1_n::iterator step_it0 = (value->getUAxes()).begin();
            if ((value->getUAxes()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getUAxes()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getVAxes())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcGridAxis_1_n::iterator step_it0 = (value->getVAxes()).begin();
            if ((value->getVAxes()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getVAxes()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getWAxes())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcGridAxis_1_n::iterator step_it0 = (value->getWAxes()).begin();
            if ((value->getWAxes()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getWAxes()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGridAxis(IfcGridAxis *value) {
    m_out << "#" << value->getKey() << "=IFCGRIDAXIS(";
    if (Step::isUnset(value->getAxisTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxisTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxisCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxisCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getSameSense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSameSense());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGridPlacement(IfcGridPlacement *value) {
    m_out << "#" << value->getKey() << "=IFCGRIDPLACEMENT(";
    if (Step::isUnset(value->getPlacementLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlacementLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlacementRefDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlacementRefDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcGroup(IfcGroup *value) {
    m_out << "#" << value->getKey() << "=IFCGROUP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcHalfSpaceSolid(IfcHalfSpaceSolid *value) {
    m_out << "#" << value->getKey() << "=IFCHALFSPACESOLID(";
    if (Step::isUnset(value->getBaseSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getAgreementFlag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAgreementFlag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcHeatExchangerTypeEnum(IfcHeatExchangerTypeEnum enumData) {
    switch(enumData) {
    case IfcHeatExchangerTypeEnum_PLATE:
        m_out << ".PLATE.";
        break;
    case IfcHeatExchangerTypeEnum_SHELLANDTUBE:
        m_out << ".SHELLANDTUBE.";
        break;
    case IfcHeatExchangerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcHeatExchangerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcHeatExchangerType(IfcHeatExchangerType *value) {
    m_out << "#" << value->getKey() << "=IFCHEATEXCHANGERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcHeatExchangerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcHumidifierTypeEnum(IfcHumidifierTypeEnum enumData) {
    switch(enumData) {
    case IfcHumidifierTypeEnum_STEAMINJECTION:
        m_out << ".STEAMINJECTION.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICAIRWASHER:
        m_out << ".ADIABATICAIRWASHER.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICPAN:
        m_out << ".ADIABATICPAN.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICWETTEDELEMENT:
        m_out << ".ADIABATICWETTEDELEMENT.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICATOMIZING:
        m_out << ".ADIABATICATOMIZING.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICULTRASONIC:
        m_out << ".ADIABATICULTRASONIC.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICRIGIDMEDIA:
        m_out << ".ADIABATICRIGIDMEDIA.";
        break;
    case IfcHumidifierTypeEnum_ADIABATICCOMPRESSEDAIRNOZZLE:
        m_out << ".ADIABATICCOMPRESSEDAIRNOZZLE.";
        break;
    case IfcHumidifierTypeEnum_ASSISTEDELECTRIC:
        m_out << ".ASSISTEDELECTRIC.";
        break;
    case IfcHumidifierTypeEnum_ASSISTEDNATURALGAS:
        m_out << ".ASSISTEDNATURALGAS.";
        break;
    case IfcHumidifierTypeEnum_ASSISTEDPROPANE:
        m_out << ".ASSISTEDPROPANE.";
        break;
    case IfcHumidifierTypeEnum_ASSISTEDBUTANE:
        m_out << ".ASSISTEDBUTANE.";
        break;
    case IfcHumidifierTypeEnum_ASSISTEDSTEAM:
        m_out << ".ASSISTEDSTEAM.";
        break;
    case IfcHumidifierTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcHumidifierTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcHumidifierType(IfcHumidifierType *value) {
    m_out << "#" << value->getKey() << "=IFCHUMIDIFIERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcHumidifierTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcHygroscopicMaterialProperties(IfcHygroscopicMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCHYGROSCOPICMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getUpperVaporResistanceFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUpperVaporResistanceFactor());
    }
    m_out << ",";
    if (Step::isUnset(value->getLowerVaporResistanceFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLowerVaporResistanceFactor());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsothermalMoistureCapacity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsothermalMoistureCapacity());
    }
    m_out << ",";
    if (Step::isUnset(value->getVaporPermeability())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVaporPermeability());
    }
    m_out << ",";
    if (Step::isUnset(value->getMoistureDiffusivity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMoistureDiffusivity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcIShapeProfileDef(IfcIShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCISHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcImageTexture(IfcImageTexture *value) {
    m_out << "#" << value->getKey() << "=IFCIMAGETEXTURE(";
    if (Step::isUnset(value->getRepeatS())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatS());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepeatT())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatT());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTextureType())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceTextureEnum(value->getTextureType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextureTransform())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextureTransform());
    }
    m_out << ",";
    if (Step::isUnset(value->getUrlReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUrlReference());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcInventoryTypeEnum(IfcInventoryTypeEnum enumData) {
    switch(enumData) {
    case IfcInventoryTypeEnum_ASSETINVENTORY:
        m_out << ".ASSETINVENTORY.";
        break;
    case IfcInventoryTypeEnum_SPACEINVENTORY:
        m_out << ".SPACEINVENTORY.";
        break;
    case IfcInventoryTypeEnum_FURNITUREINVENTORY:
        m_out << ".FURNITUREINVENTORY.";
        break;
    case IfcInventoryTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcInventoryTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcInventory(IfcInventory *value) {
    m_out << "#" << value->getKey() << "=IFCINVENTORY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getInventoryType())) {
        m_out << "$";
    }
    else {
        writeIfcInventoryTypeEnum(value->getInventoryType());
    }
    m_out << ",";
    if (Step::isUnset(value->getJurisdiction())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getJurisdiction());
    }
    m_out << ",";
    if (Step::isUnset(value->getResponsiblePersons())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPerson_1_n::iterator step_it0 = (value->getResponsiblePersons()).begin();
            if ((value->getResponsiblePersons()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getResponsiblePersons()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getLastUpdateDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLastUpdateDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getCurrentValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCurrentValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getOriginalValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOriginalValue());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTimeSeriesDataTypeEnum(IfcTimeSeriesDataTypeEnum enumData) {
    switch(enumData) {
    case IfcTimeSeriesDataTypeEnum_CONTINUOUS:
        m_out << ".CONTINUOUS.";
        break;
    case IfcTimeSeriesDataTypeEnum_DISCRETE:
        m_out << ".DISCRETE.";
        break;
    case IfcTimeSeriesDataTypeEnum_DISCRETEBINARY:
        m_out << ".DISCRETEBINARY.";
        break;
    case IfcTimeSeriesDataTypeEnum_PIECEWISEBINARY:
        m_out << ".PIECEWISEBINARY.";
        break;
    case IfcTimeSeriesDataTypeEnum_PIECEWISECONSTANT:
        m_out << ".PIECEWISECONSTANT.";
        break;
    case IfcTimeSeriesDataTypeEnum_PIECEWISECONTINUOUS:
        m_out << ".PIECEWISECONTINUOUS.";
        break;
    case IfcTimeSeriesDataTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcDataOriginEnum(IfcDataOriginEnum enumData) {
    switch(enumData) {
    case IfcDataOriginEnum_MEASURED:
        m_out << ".MEASURED.";
        break;
    case IfcDataOriginEnum_PREDICTED:
        m_out << ".PREDICTED.";
        break;
    case IfcDataOriginEnum_SIMULATED:
        m_out << ".SIMULATED.";
        break;
    case IfcDataOriginEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcDataOriginEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcUnit(IfcUnit *selectData) {
    switch(selectData->currentType()) {
    case IfcUnit::IFCDERIVEDUNIT:
        writeAttribute(selectData->getIfcDerivedUnit());
        break;
    case IfcUnit::IFCNAMEDUNIT:
        writeAttribute(selectData->getIfcNamedUnit());
        break;
    case IfcUnit::IFCMONETARYUNIT:
        writeAttribute(selectData->getIfcMonetaryUnit());
        break;
        }
}

bool SPFWriter::visitIfcIrregularTimeSeries(IfcIrregularTimeSeries *value) {
    m_out << "#" << value->getKey() << "=IFCIRREGULARTIMESERIES(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getEndTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTimeSeriesDataType())) {
        m_out << "$";
    }
    else {
        writeIfcTimeSeriesDataTypeEnum(value->getTimeSeriesDataType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDataOrigin())) {
        m_out << "$";
    }
    else {
        writeIfcDataOriginEnum(value->getDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedDataOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcIrregularTimeSeriesValue_1_n::iterator step_it0 = (value->getValues()).begin();
            if ((value->getValues()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getValues()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcValue(IfcValue *selectData) {
    switch(selectData->currentType()) {
    case IfcValue::IFCVOLUMEMEASURE:
        m_out << "IFCVOLUMEMEASURE(";
        writeAttribute(selectData->getIfcVolumeMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTIMEMEASURE:
        m_out << "IFCTIMEMEASURE(";
        writeAttribute(selectData->getIfcTimeMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMODYNAMICTEMPERATUREMEASURE:
        m_out << "IFCTHERMODYNAMICTEMPERATUREMEASURE(";
        writeAttribute(selectData->getIfcThermodynamicTemperatureMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSOLIDANGLEMEASURE:
        m_out << "IFCSOLIDANGLEMEASURE(";
        writeAttribute(selectData->getIfcSolidAngleMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPOSITIVERATIOMEASURE:
        m_out << "IFCPOSITIVERATIOMEASURE(";
        writeAttribute(selectData->getIfcPositiveRatioMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCRATIOMEASURE:
        m_out << "IFCRATIOMEASURE(";
        writeAttribute(selectData->getIfcRatioMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPOSITIVEPLANEANGLEMEASURE:
        m_out << "IFCPOSITIVEPLANEANGLEMEASURE(";
        writeAttribute(selectData->getIfcPositivePlaneAngleMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPLANEANGLEMEASURE:
        m_out << "IFCPLANEANGLEMEASURE(";
        writeAttribute(selectData->getIfcPlaneAngleMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPARAMETERVALUE:
        m_out << "IFCPARAMETERVALUE(";
        writeAttribute(selectData->getIfcParameterValue());
        m_out << ")";
        break;
    case IfcValue::IFCNUMERICMEASURE:
        m_out << "IFCNUMERICMEASURE(";
        writeAttribute(selectData->getIfcNumericMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMASSMEASURE:
        m_out << "IFCMASSMEASURE(";
        writeAttribute(selectData->getIfcMassMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPOSITIVELENGTHMEASURE:
        m_out << "IFCPOSITIVELENGTHMEASURE(";
        writeAttribute(selectData->getIfcPositiveLengthMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLENGTHMEASURE:
        m_out << "IFCLENGTHMEASURE(";
        writeAttribute(selectData->getIfcLengthMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICCURRENTMEASURE:
        m_out << "IFCELECTRICCURRENTMEASURE(";
        writeAttribute(selectData->getIfcElectricCurrentMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCDESCRIPTIVEMEASURE:
        m_out << "IFCDESCRIPTIVEMEASURE(";
        writeAttribute(selectData->getIfcDescriptiveMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCCOUNTMEASURE:
        m_out << "IFCCOUNTMEASURE(";
        writeAttribute(selectData->getIfcCountMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCCONTEXTDEPENDENTMEASURE:
        m_out << "IFCCONTEXTDEPENDENTMEASURE(";
        writeAttribute(selectData->getIfcContextDependentMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCAREAMEASURE:
        m_out << "IFCAREAMEASURE(";
        writeAttribute(selectData->getIfcAreaMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCAMOUNTOFSUBSTANCEMEASURE:
        m_out << "IFCAMOUNTOFSUBSTANCEMEASURE(";
        writeAttribute(selectData->getIfcAmountOfSubstanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLUMINOUSINTENSITYMEASURE:
        m_out << "IFCLUMINOUSINTENSITYMEASURE(";
        writeAttribute(selectData->getIfcLuminousIntensityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCNORMALISEDRATIOMEASURE:
        m_out << "IFCNORMALISEDRATIOMEASURE(";
        writeAttribute(selectData->getIfcNormalisedRatioMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCCOMPLEXNUMBER:
        m_out << "IFCCOMPLEXNUMBER(";
        m_out << "(";
        {
            IfcComplexNumber::iterator step_it1 = (selectData->getIfcComplexNumber()).begin();
            if ((selectData->getIfcComplexNumber()).size()) {
                writeAttribute(*step_it1);
                for (step_it1++; step_it1 != (selectData->getIfcComplexNumber()).end(); step_it1++) {
                    m_out << ",";
                    writeAttribute(*step_it1);
                }
            }
        }
        m_out << ")";
        m_out << ")";
        break;
    case IfcValue::IFCINTEGER:
        m_out << "IFCINTEGER(";
        writeAttribute(selectData->getIfcInteger());
        m_out << ")";
        break;
    case IfcValue::IFCREAL:
        m_out << "IFCREAL(";
        writeAttribute(selectData->getIfcReal());
        m_out << ")";
        break;
    case IfcValue::IFCBOOLEAN:
        m_out << "IFCBOOLEAN(";
        writeAttribute(selectData->getIfcBoolean());
        m_out << ")";
        break;
    case IfcValue::IFCIDENTIFIER:
        m_out << "IFCIDENTIFIER(";
        writeAttribute(selectData->getIfcIdentifier());
        m_out << ")";
        break;
    case IfcValue::IFCTEXT:
        m_out << "IFCTEXT(";
        writeAttribute(selectData->getIfcText());
        m_out << ")";
        break;
    case IfcValue::IFCLABEL:
        m_out << "IFCLABEL(";
        writeAttribute(selectData->getIfcLabel());
        m_out << ")";
        break;
    case IfcValue::IFCLOGICAL:
        m_out << "IFCLOGICAL(";
        writeAttribute(selectData->getIfcLogical());
        m_out << ")";
        break;
    case IfcValue::IFCVOLUMETRICFLOWRATEMEASURE:
        m_out << "IFCVOLUMETRICFLOWRATEMEASURE(";
        writeAttribute(selectData->getIfcVolumetricFlowRateMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTIMESTAMP:
        m_out << "IFCTIMESTAMP(";
        writeAttribute(selectData->getIfcTimeStamp());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMALTRANSMITTANCEMEASURE:
        m_out << "IFCTHERMALTRANSMITTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalTransmittanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMALRESISTANCEMEASURE:
        m_out << "IFCTHERMALRESISTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalResistanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMALADMITTANCEMEASURE:
        m_out << "IFCTHERMALADMITTANCEMEASURE(";
        writeAttribute(selectData->getIfcThermalAdmittanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPRESSUREMEASURE:
        m_out << "IFCPRESSUREMEASURE(";
        writeAttribute(selectData->getIfcPressureMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPOWERMEASURE:
        m_out << "IFCPOWERMEASURE(";
        writeAttribute(selectData->getIfcPowerMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMASSFLOWRATEMEASURE:
        m_out << "IFCMASSFLOWRATEMEASURE(";
        writeAttribute(selectData->getIfcMassFlowRateMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMASSDENSITYMEASURE:
        m_out << "IFCMASSDENSITYMEASURE(";
        writeAttribute(selectData->getIfcMassDensityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLINEARVELOCITYMEASURE:
        m_out << "IFCLINEARVELOCITYMEASURE(";
        writeAttribute(selectData->getIfcLinearVelocityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCKINEMATICVISCOSITYMEASURE:
        m_out << "IFCKINEMATICVISCOSITYMEASURE(";
        writeAttribute(selectData->getIfcKinematicViscosityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCINTEGERCOUNTRATEMEASURE:
        m_out << "IFCINTEGERCOUNTRATEMEASURE(";
        writeAttribute(selectData->getIfcIntegerCountRateMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCHEATFLUXDENSITYMEASURE:
        m_out << "IFCHEATFLUXDENSITYMEASURE(";
        writeAttribute(selectData->getIfcHeatFluxDensityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCFREQUENCYMEASURE:
        m_out << "IFCFREQUENCYMEASURE(";
        writeAttribute(selectData->getIfcFrequencyMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCENERGYMEASURE:
        m_out << "IFCENERGYMEASURE(";
        writeAttribute(selectData->getIfcEnergyMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICVOLTAGEMEASURE:
        m_out << "IFCELECTRICVOLTAGEMEASURE(";
        writeAttribute(selectData->getIfcElectricVoltageMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCDYNAMICVISCOSITYMEASURE:
        m_out << "IFCDYNAMICVISCOSITYMEASURE(";
        writeAttribute(selectData->getIfcDynamicViscosityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCCOMPOUNDPLANEANGLEMEASURE:
        m_out << "IFCCOMPOUNDPLANEANGLEMEASURE(";
        m_out << "(";
        {
            IfcCompoundPlaneAngleMeasure::iterator step_it1 = (selectData->getIfcCompoundPlaneAngleMeasure()).begin();
            if ((selectData->getIfcCompoundPlaneAngleMeasure()).size()) {
                writeAttribute(*step_it1);
                for (step_it1++; step_it1 != (selectData->getIfcCompoundPlaneAngleMeasure()).end(); step_it1++) {
                    m_out << ",";
                    writeAttribute(*step_it1);
                }
            }
        }
        m_out << ")";
        m_out << ")";
        break;
    case IfcValue::IFCANGULARVELOCITYMEASURE:
        m_out << "IFCANGULARVELOCITYMEASURE(";
        writeAttribute(selectData->getIfcAngularVelocityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMALCONDUCTIVITYMEASURE:
        m_out << "IFCTHERMALCONDUCTIVITYMEASURE(";
        writeAttribute(selectData->getIfcThermalConductivityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMOLECULARWEIGHTMEASURE:
        m_out << "IFCMOLECULARWEIGHTMEASURE(";
        writeAttribute(selectData->getIfcMolecularWeightMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCVAPORPERMEABILITYMEASURE:
        m_out << "IFCVAPORPERMEABILITYMEASURE(";
        writeAttribute(selectData->getIfcVaporPermeabilityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMOISTUREDIFFUSIVITYMEASURE:
        m_out << "IFCMOISTUREDIFFUSIVITYMEASURE(";
        writeAttribute(selectData->getIfcMoistureDiffusivityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCISOTHERMALMOISTURECAPACITYMEASURE:
        m_out << "IFCISOTHERMALMOISTURECAPACITYMEASURE(";
        writeAttribute(selectData->getIfcIsothermalMoistureCapacityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSPECIFICHEATCAPACITYMEASURE:
        m_out << "IFCSPECIFICHEATCAPACITYMEASURE(";
        writeAttribute(selectData->getIfcSpecificHeatCapacityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMONETARYMEASURE:
        m_out << "IFCMONETARYMEASURE(";
        writeAttribute(selectData->getIfcMonetaryMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMAGNETICFLUXDENSITYMEASURE:
        m_out << "IFCMAGNETICFLUXDENSITYMEASURE(";
        writeAttribute(selectData->getIfcMagneticFluxDensityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMAGNETICFLUXMEASURE:
        m_out << "IFCMAGNETICFLUXMEASURE(";
        writeAttribute(selectData->getIfcMagneticFluxMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLUMINOUSFLUXMEASURE:
        m_out << "IFCLUMINOUSFLUXMEASURE(";
        writeAttribute(selectData->getIfcLuminousFluxMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCFORCEMEASURE:
        m_out << "IFCFORCEMEASURE(";
        writeAttribute(selectData->getIfcForceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCINDUCTANCEMEASURE:
        m_out << "IFCINDUCTANCEMEASURE(";
        writeAttribute(selectData->getIfcInductanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCILLUMINANCEMEASURE:
        m_out << "IFCILLUMINANCEMEASURE(";
        writeAttribute(selectData->getIfcIlluminanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICRESISTANCEMEASURE:
        m_out << "IFCELECTRICRESISTANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricResistanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICCONDUCTANCEMEASURE:
        m_out << "IFCELECTRICCONDUCTANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricConductanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICCHARGEMEASURE:
        m_out << "IFCELECTRICCHARGEMEASURE(";
        writeAttribute(selectData->getIfcElectricChargeMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCDOSEEQUIVALENTMEASURE:
        m_out << "IFCDOSEEQUIVALENTMEASURE(";
        writeAttribute(selectData->getIfcDoseEquivalentMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCELECTRICCAPACITANCEMEASURE:
        m_out << "IFCELECTRICCAPACITANCEMEASURE(";
        writeAttribute(selectData->getIfcElectricCapacitanceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCABSORBEDDOSEMEASURE:
        m_out << "IFCABSORBEDDOSEMEASURE(";
        writeAttribute(selectData->getIfcAbsorbedDoseMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCRADIOACTIVITYMEASURE:
        m_out << "IFCRADIOACTIVITYMEASURE(";
        writeAttribute(selectData->getIfcRadioActivityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCROTATIONALFREQUENCYMEASURE:
        m_out << "IFCROTATIONALFREQUENCYMEASURE(";
        writeAttribute(selectData->getIfcRotationalFrequencyMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTORQUEMEASURE:
        m_out << "IFCTORQUEMEASURE(";
        writeAttribute(selectData->getIfcTorqueMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCACCELERATIONMEASURE:
        m_out << "IFCACCELERATIONMEASURE(";
        writeAttribute(selectData->getIfcAccelerationMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLINEARFORCEMEASURE:
        m_out << "IFCLINEARFORCEMEASURE(";
        writeAttribute(selectData->getIfcLinearForceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLINEARSTIFFNESSMEASURE:
        m_out << "IFCLINEARSTIFFNESSMEASURE(";
        writeAttribute(selectData->getIfcLinearStiffnessMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMODULUSOFSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMODULUSOFELASTICITYMEASURE:
        m_out << "IFCMODULUSOFELASTICITYMEASURE(";
        writeAttribute(selectData->getIfcModulusOfElasticityMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMOMENTOFINERTIAMEASURE:
        m_out << "IFCMOMENTOFINERTIAMEASURE(";
        writeAttribute(selectData->getIfcMomentOfInertiaMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPLANARFORCEMEASURE:
        m_out << "IFCPLANARFORCEMEASURE(";
        writeAttribute(selectData->getIfcPlanarForceMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCROTATIONALSTIFFNESSMEASURE:
        m_out << "IFCROTATIONALSTIFFNESSMEASURE(";
        writeAttribute(selectData->getIfcRotationalStiffnessMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSHEARMODULUSMEASURE:
        m_out << "IFCSHEARMODULUSMEASURE(";
        writeAttribute(selectData->getIfcShearModulusMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLINEARMOMENTMEASURE:
        m_out << "IFCLINEARMOMENTMEASURE(";
        writeAttribute(selectData->getIfcLinearMomentMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE:
        m_out << "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE(";
        writeAttribute(selectData->getIfcLuminousIntensityDistributionMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCCURVATUREMEASURE:
        m_out << "IFCCURVATUREMEASURE(";
        writeAttribute(selectData->getIfcCurvatureMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMASSPERLENGTHMEASURE:
        m_out << "IFCMASSPERLENGTHMEASURE(";
        writeAttribute(selectData->getIfcMassPerLengthMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfLinearSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE:
        m_out << "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE(";
        writeAttribute(selectData->getIfcModulusOfRotationalSubgradeReactionMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCROTATIONALMASSMEASURE:
        m_out << "IFCROTATIONALMASSMEASURE(";
        writeAttribute(selectData->getIfcRotationalMassMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSECTIONALAREAINTEGRALMEASURE:
        m_out << "IFCSECTIONALAREAINTEGRALMEASURE(";
        writeAttribute(selectData->getIfcSectionalAreaIntegralMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSECTIONMODULUSMEASURE:
        m_out << "IFCSECTIONMODULUSMEASURE(";
        writeAttribute(selectData->getIfcSectionModulusMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTEMPERATUREGRADIENTMEASURE:
        m_out << "IFCTEMPERATUREGRADIENTMEASURE(";
        writeAttribute(selectData->getIfcTemperatureGradientMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCTHERMALEXPANSIONCOEFFICIENTMEASURE:
        m_out << "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE(";
        writeAttribute(selectData->getIfcThermalExpansionCoefficientMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCWARPINGCONSTANTMEASURE:
        m_out << "IFCWARPINGCONSTANTMEASURE(";
        writeAttribute(selectData->getIfcWarpingConstantMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCWARPINGMOMENTMEASURE:
        m_out << "IFCWARPINGMOMENTMEASURE(";
        writeAttribute(selectData->getIfcWarpingMomentMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSOUNDPOWERMEASURE:
        m_out << "IFCSOUNDPOWERMEASURE(";
        writeAttribute(selectData->getIfcSoundPowerMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCSOUNDPRESSUREMEASURE:
        m_out << "IFCSOUNDPRESSUREMEASURE(";
        writeAttribute(selectData->getIfcSoundPressureMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCHEATINGVALUEMEASURE:
        m_out << "IFCHEATINGVALUEMEASURE(";
        writeAttribute(selectData->getIfcHeatingValueMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCPHMEASURE:
        m_out << "IFCPHMEASURE(";
        writeAttribute(selectData->getIfcPHMeasure());
        m_out << ")";
        break;
    case IfcValue::IFCIONCONCENTRATIONMEASURE:
        m_out << "IFCIONCONCENTRATIONMEASURE(";
        writeAttribute(selectData->getIfcIonConcentrationMeasure());
        m_out << ")";
        break;
        }
}

bool SPFWriter::visitIfcIrregularTimeSeriesValue(IfcIrregularTimeSeriesValue *value) {
    m_out << "#" << value->getKey() << "=IFCIRREGULARTIMESERIESVALUE(";
    if (Step::isUnset(value->getTimeStamp())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getTimeStamp());
    }
    m_out << ",";
    if (Step::isUnset(value->getListValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getListValues()).begin();
            if ((value->getListValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getListValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcJunctionBoxTypeEnum(IfcJunctionBoxTypeEnum enumData) {
    switch(enumData) {
    case IfcJunctionBoxTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcJunctionBoxTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcJunctionBoxType(IfcJunctionBoxType *value) {
    m_out << "#" << value->getKey() << "=IFCJUNCTIONBOXTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcJunctionBoxTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLShapeProfileDef(IfcLShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCLSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getLegSlope())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLegSlope());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLaborResource(IfcLaborResource *value) {
    m_out << "#" << value->getKey() << "=IFCLABORRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ",";
    if (Step::isUnset(value->getSkillSet())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSkillSet());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLampTypeEnum(IfcLampTypeEnum enumData) {
    switch(enumData) {
    case IfcLampTypeEnum_COMPACTFLUORESCENT:
        m_out << ".COMPACTFLUORESCENT.";
        break;
    case IfcLampTypeEnum_FLUORESCENT:
        m_out << ".FLUORESCENT.";
        break;
    case IfcLampTypeEnum_HIGHPRESSUREMERCURY:
        m_out << ".HIGHPRESSUREMERCURY.";
        break;
    case IfcLampTypeEnum_HIGHPRESSURESODIUM:
        m_out << ".HIGHPRESSURESODIUM.";
        break;
    case IfcLampTypeEnum_METALHALIDE:
        m_out << ".METALHALIDE.";
        break;
    case IfcLampTypeEnum_TUNGSTENFILAMENT:
        m_out << ".TUNGSTENFILAMENT.";
        break;
    case IfcLampTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcLampTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcLampType(IfcLampType *value) {
    m_out << "#" << value->getKey() << "=IFCLAMPTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcLampTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLibraryInformation(IfcLibraryInformation *value) {
    m_out << "#" << value->getKey() << "=IFCLIBRARYINFORMATION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getVersion())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVersion());
    }
    m_out << ",";
    if (Step::isUnset(value->getPublisher())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPublisher());
    }
    m_out << ",";
    if (Step::isUnset(value->getVersionDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVersionDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getLibraryReference())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcLibraryReference_1_n::iterator step_it0 = (value->getLibraryReference()).begin();
            if ((value->getLibraryReference()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getLibraryReference()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLibraryReference(IfcLibraryReference *value) {
    m_out << "#" << value->getKey() << "=IFCLIBRARYREFERENCE(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getItemReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItemReference());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightDistributionData(IfcLightDistributionData *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTDISTRIBUTIONDATA(";
    if (Step::isUnset(value->getMainPlaneAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMainPlaneAngle());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondaryPlaneAngle())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcPlaneAngleMeasure_1_n::iterator step_it0 = (value->getSecondaryPlaneAngle()).begin();
            if ((value->getSecondaryPlaneAngle()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getSecondaryPlaneAngle()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getLuminousIntensity())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLuminousIntensityDistributionMeasure_1_n::iterator step_it0 = (value->getLuminousIntensity()).begin();
            if ((value->getLuminousIntensity()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getLuminousIntensity()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLightFixtureTypeEnum(IfcLightFixtureTypeEnum enumData) {
    switch(enumData) {
    case IfcLightFixtureTypeEnum_POINTSOURCE:
        m_out << ".POINTSOURCE.";
        break;
    case IfcLightFixtureTypeEnum_DIRECTIONSOURCE:
        m_out << ".DIRECTIONSOURCE.";
        break;
    case IfcLightFixtureTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcLightFixtureTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcLightFixtureType(IfcLightFixtureType *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTFIXTURETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcLightFixtureTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLightDistributionCurveEnum(IfcLightDistributionCurveEnum enumData) {
    switch(enumData) {
    case IfcLightDistributionCurveEnum_TYPE_A:
        m_out << ".TYPE_A.";
        break;
    case IfcLightDistributionCurveEnum_TYPE_B:
        m_out << ".TYPE_B.";
        break;
    case IfcLightDistributionCurveEnum_TYPE_C:
        m_out << ".TYPE_C.";
        break;
    case IfcLightDistributionCurveEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcLightIntensityDistribution(IfcLightIntensityDistribution *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTINTENSITYDISTRIBUTION(";
    if (Step::isUnsetEnum(value->getLightDistributionCurve())) {
        m_out << "$";
    }
    else {
        writeIfcLightDistributionCurveEnum(value->getLightDistributionCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistributionData())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLightDistributionData_1_n::iterator step_it0 = (value->getDistributionData()).begin();
            if ((value->getDistributionData()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getDistributionData()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightSource(IfcLightSource *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightSourceAmbient(IfcLightSourceAmbient *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCEAMBIENT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightSourceDirectional(IfcLightSourceDirectional *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCEDIRECTIONAL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLightEmissionSourceEnum(IfcLightEmissionSourceEnum enumData) {
    switch(enumData) {
    case IfcLightEmissionSourceEnum_COMPACTFLUORESCENT:
        m_out << ".COMPACTFLUORESCENT.";
        break;
    case IfcLightEmissionSourceEnum_FLUORESCENT:
        m_out << ".FLUORESCENT.";
        break;
    case IfcLightEmissionSourceEnum_HIGHPRESSUREMERCURY:
        m_out << ".HIGHPRESSUREMERCURY.";
        break;
    case IfcLightEmissionSourceEnum_HIGHPRESSURESODIUM:
        m_out << ".HIGHPRESSURESODIUM.";
        break;
    case IfcLightEmissionSourceEnum_LIGHTEMITTINGDIODE:
        m_out << ".LIGHTEMITTINGDIODE.";
        break;
    case IfcLightEmissionSourceEnum_LOWPRESSURESODIUM:
        m_out << ".LOWPRESSURESODIUM.";
        break;
    case IfcLightEmissionSourceEnum_LOWVOLTAGEHALOGEN:
        m_out << ".LOWVOLTAGEHALOGEN.";
        break;
    case IfcLightEmissionSourceEnum_MAINVOLTAGEHALOGEN:
        m_out << ".MAINVOLTAGEHALOGEN.";
        break;
    case IfcLightEmissionSourceEnum_METALHALIDE:
        m_out << ".METALHALIDE.";
        break;
    case IfcLightEmissionSourceEnum_TUNGSTENFILAMENT:
        m_out << ".TUNGSTENFILAMENT.";
        break;
    case IfcLightEmissionSourceEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcLightDistributionDataSourceSelect(IfcLightDistributionDataSourceSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcLightDistributionDataSourceSelect::IFCEXTERNALREFERENCE:
        writeAttribute(selectData->getIfcExternalReference());
        break;
    case IfcLightDistributionDataSourceSelect::IFCLIGHTINTENSITYDISTRIBUTION:
        writeAttribute(selectData->getIfcLightIntensityDistribution());
        break;
        }
}

bool SPFWriter::visitIfcLightSourceGoniometric(IfcLightSourceGoniometric *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCEGONIOMETRIC(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getColourAppearance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getColourAppearance());
    }
    m_out << ",";
    if (Step::isUnset(value->getColourTemperature())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getColourTemperature());
    }
    m_out << ",";
    if (Step::isUnset(value->getLuminousFlux())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLuminousFlux());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getLightEmissionSource())) {
        m_out << "$";
    }
    else {
        writeIfcLightEmissionSourceEnum(value->getLightEmissionSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightDistributionDataSource())) {
        m_out << "$";
    }
    else {
        writeIfcLightDistributionDataSourceSelect(value->getLightDistributionDataSource());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightSourcePositional(IfcLightSourcePositional *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCEPOSITIONAL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getConstantAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConstantAttenuation());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistanceAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDistanceAttenuation());
    }
    m_out << ",";
    if (Step::isUnset(value->getQuadricAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getQuadricAttenuation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLightSourceSpot(IfcLightSourceSpot *value) {
    m_out << "#" << value->getKey() << "=IFCLIGHTSOURCESPOT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLightColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLightColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getAmbientIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAmbientIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getIntensity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntensity());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getConstantAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConstantAttenuation());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistanceAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDistanceAttenuation());
    }
    m_out << ",";
    if (Step::isUnset(value->getQuadricAttenuation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getQuadricAttenuation());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ",";
    if (Step::isUnset(value->getConcentrationExponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConcentrationExponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpreadAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSpreadAngle());
    }
    m_out << ",";
    if (Step::isUnset(value->getBeamWidthAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBeamWidthAngle());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLine(IfcLine *value) {
    m_out << "#" << value->getKey() << "=IFCLINE(";
    if (Step::isUnset(value->getPnt())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPnt());
    }
    m_out << ",";
    if (Step::isUnset(value->getDir())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDir());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLinearDimension(IfcLinearDimension *value) {
    m_out << "#" << value->getKey() << "=IFCLINEARDIMENSION(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLocalPlacement(IfcLocalPlacement *value) {
    m_out << "#" << value->getKey() << "=IFCLOCALPLACEMENT(";
    if (Step::isUnset(value->getPlacementRelTo())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlacementRelTo());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelativePlacement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getRelativePlacement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLocalTime(IfcLocalTime *value) {
    m_out << "#" << value->getKey() << "=IFCLOCALTIME(";
    if (Step::isUnset(value->getHourComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHourComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinuteComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinuteComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondComponent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSecondComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getZone())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getZone());
    }
    m_out << ",";
    if (Step::isUnset(value->getDaylightSavingOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDaylightSavingOffset());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcLoop(IfcLoop *value) {
    m_out << "#" << value->getKey() << "=IFCLOOP(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcManifoldSolidBrep(IfcManifoldSolidBrep *value) {
    m_out << "#" << value->getKey() << "=IFCMANIFOLDSOLIDBREP(";
    if (Step::isUnset(value->getOuter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuter());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMappedItem(IfcMappedItem *value) {
    m_out << "#" << value->getKey() << "=IFCMAPPEDITEM(";
    if (Step::isUnset(value->getMappingSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMappingSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getMappingTarget())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMappingTarget());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterial(IfcMaterial *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIAL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialClassificationRelationship(IfcMaterialClassificationRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALCLASSIFICATIONRELATIONSHIP(";
    if (Step::isUnset(value->getMaterialClassifications())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcClassificationNotationSelect_1_n::iterator step_it0 = (value->getMaterialClassifications()).begin();
            if ((value->getMaterialClassifications()).size()) {
                writeIfcClassificationNotationSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getMaterialClassifications()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcClassificationNotationSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getClassifiedMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getClassifiedMaterial());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialDefinitionRepresentation(IfcMaterialDefinitionRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALDEFINITIONREPRESENTATION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentation_1_n::iterator step_it0 = (value->getRepresentations()).begin();
            if ((value->getRepresentations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentedMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentedMaterial());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialLayer(IfcMaterialLayer *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALLAYER(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLayerThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsVentilated())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsVentilated());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialLayerSet(IfcMaterialLayerSet *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALLAYERSET(";
    if (Step::isUnset(value->getMaterialLayers())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcMaterialLayer_1_n::iterator step_it0 = (value->getMaterialLayers()).begin();
            if ((value->getMaterialLayers()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getMaterialLayers()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerSetName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLayerSetName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLayerSetDirectionEnum(IfcLayerSetDirectionEnum enumData) {
    switch(enumData) {
    case IfcLayerSetDirectionEnum_AXIS1:
        m_out << ".AXIS1.";
        break;
    case IfcLayerSetDirectionEnum_AXIS2:
        m_out << ".AXIS2.";
        break;
    case IfcLayerSetDirectionEnum_AXIS3:
        m_out << ".AXIS3.";
        break;
        }
}

void SPFWriter::writeIfcDirectionSenseEnum(IfcDirectionSenseEnum enumData) {
    switch(enumData) {
    case IfcDirectionSenseEnum_POSITIVE:
        m_out << ".POSITIVE.";
        break;
    case IfcDirectionSenseEnum_NEGATIVE:
        m_out << ".NEGATIVE.";
        break;
        }
}

bool SPFWriter::visitIfcMaterialLayerSetUsage(IfcMaterialLayerSetUsage *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALLAYERSETUSAGE(";
    if (Step::isUnset(value->getForLayerSet())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForLayerSet());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getLayerSetDirection())) {
        m_out << "$";
    }
    else {
        writeIfcLayerSetDirectionEnum(value->getLayerSetDirection());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDirectionSense())) {
        m_out << "$";
    }
    else {
        writeIfcDirectionSenseEnum(value->getDirectionSense());
    }
    m_out << ",";
    if (Step::isUnset(value->getOffsetFromReferenceLine())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOffsetFromReferenceLine());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialList(IfcMaterialList *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALLIST(";
    if (Step::isUnset(value->getMaterials())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcMaterial_1_n::iterator step_it0 = (value->getMaterials()).begin();
            if ((value->getMaterials()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getMaterials()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMaterialProperties(IfcMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMeasureWithUnit(IfcMeasureWithUnit *value) {
    m_out << "#" << value->getKey() << "=IFCMEASUREWITHUNIT(";
    if (Step::isUnset(value->getValueComponent())) {
        m_out << "$";
    }
    else {
        writeIfcValue(value->getValueComponent());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnitComponent())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnitComponent());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMechanicalConcreteMaterialProperties(IfcMechanicalConcreteMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCMECHANICALCONCRETEMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getDynamicViscosity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDynamicViscosity());
    }
    m_out << ",";
    if (Step::isUnset(value->getYoungModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYoungModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getPoissonRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPoissonRatio());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalExpansionCoefficient())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalExpansionCoefficient());
    }
    m_out << ",";
    if (Step::isUnset(value->getCompressiveStrength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCompressiveStrength());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaxAggregateSize())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaxAggregateSize());
    }
    m_out << ",";
    if (Step::isUnset(value->getAdmixturesDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAdmixturesDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getWorkability())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWorkability());
    }
    m_out << ",";
    if (Step::isUnset(value->getProtectivePoreRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProtectivePoreRatio());
    }
    m_out << ",";
    if (Step::isUnset(value->getWaterImpermeability())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWaterImpermeability());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMechanicalFastener(IfcMechanicalFastener *value) {
    m_out << "#" << value->getKey() << "=IFCMECHANICALFASTENER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNominalDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNominalLength());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMechanicalFastenerType(IfcMechanicalFastenerType *value) {
    m_out << "#" << value->getKey() << "=IFCMECHANICALFASTENERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMechanicalMaterialProperties(IfcMechanicalMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCMECHANICALMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getDynamicViscosity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDynamicViscosity());
    }
    m_out << ",";
    if (Step::isUnset(value->getYoungModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYoungModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getPoissonRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPoissonRatio());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalExpansionCoefficient())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalExpansionCoefficient());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMechanicalSteelMaterialProperties(IfcMechanicalSteelMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCMECHANICALSTEELMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getDynamicViscosity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDynamicViscosity());
    }
    m_out << ",";
    if (Step::isUnset(value->getYoungModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYoungModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getPoissonRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPoissonRatio());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalExpansionCoefficient())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalExpansionCoefficient());
    }
    m_out << ",";
    if (Step::isUnset(value->getYieldStress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYieldStress());
    }
    m_out << ",";
    if (Step::isUnset(value->getUltimateStress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUltimateStress());
    }
    m_out << ",";
    if (Step::isUnset(value->getUltimateStrain())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUltimateStrain());
    }
    m_out << ",";
    if (Step::isUnset(value->getHardeningModule())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHardeningModule());
    }
    m_out << ",";
    if (Step::isUnset(value->getProportionalStress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProportionalStress());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlasticStrain())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlasticStrain());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelaxations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRelaxation_1_n::iterator step_it0 = (value->getRelaxations()).begin();
            if ((value->getRelaxations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelaxations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMember(IfcMember *value) {
    m_out << "#" << value->getKey() << "=IFCMEMBER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcMemberTypeEnum(IfcMemberTypeEnum enumData) {
    switch(enumData) {
    case IfcMemberTypeEnum_BRACE:
        m_out << ".BRACE.";
        break;
    case IfcMemberTypeEnum_CHORD:
        m_out << ".CHORD.";
        break;
    case IfcMemberTypeEnum_COLLAR:
        m_out << ".COLLAR.";
        break;
    case IfcMemberTypeEnum_MEMBER:
        m_out << ".MEMBER.";
        break;
    case IfcMemberTypeEnum_MULLION:
        m_out << ".MULLION.";
        break;
    case IfcMemberTypeEnum_PLATE:
        m_out << ".PLATE.";
        break;
    case IfcMemberTypeEnum_POST:
        m_out << ".POST.";
        break;
    case IfcMemberTypeEnum_PURLIN:
        m_out << ".PURLIN.";
        break;
    case IfcMemberTypeEnum_RAFTER:
        m_out << ".RAFTER.";
        break;
    case IfcMemberTypeEnum_STRINGER:
        m_out << ".STRINGER.";
        break;
    case IfcMemberTypeEnum_STRUT:
        m_out << ".STRUT.";
        break;
    case IfcMemberTypeEnum_STUD:
        m_out << ".STUD.";
        break;
    case IfcMemberTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcMemberTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcMemberType(IfcMemberType *value) {
    m_out << "#" << value->getKey() << "=IFCMEMBERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcMemberTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcBenchmarkEnum(IfcBenchmarkEnum enumData) {
    switch(enumData) {
    case IfcBenchmarkEnum_GREATERTHAN:
        m_out << ".GREATERTHAN.";
        break;
    case IfcBenchmarkEnum_GREATERTHANOREQUALTO:
        m_out << ".GREATERTHANOREQUALTO.";
        break;
    case IfcBenchmarkEnum_LESSTHAN:
        m_out << ".LESSTHAN.";
        break;
    case IfcBenchmarkEnum_LESSTHANOREQUALTO:
        m_out << ".LESSTHANOREQUALTO.";
        break;
    case IfcBenchmarkEnum_EQUALTO:
        m_out << ".EQUALTO.";
        break;
    case IfcBenchmarkEnum_NOTEQUALTO:
        m_out << ".NOTEQUALTO.";
        break;
        }
}

void SPFWriter::writeIfcMetricValueSelect(IfcMetricValueSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcMetricValueSelect::IFCCALENDARDATE:
        writeAttribute(selectData->getIfcCalendarDate());
        break;
    case IfcMetricValueSelect::IFCLOCALTIME:
        writeAttribute(selectData->getIfcLocalTime());
        break;
    case IfcMetricValueSelect::IFCDATEANDTIME:
        writeAttribute(selectData->getIfcDateAndTime());
        break;
    case IfcMetricValueSelect::IFCMEASUREWITHUNIT:
        writeAttribute(selectData->getIfcMeasureWithUnit());
        break;
    case IfcMetricValueSelect::IFCTABLE:
        writeAttribute(selectData->getIfcTable());
        break;
    case IfcMetricValueSelect::IFCTEXT:
        m_out << "IFCTEXT(";
        writeAttribute(selectData->getIfcText());
        m_out << ")";
        break;
    case IfcMetricValueSelect::IFCTIMESERIES:
        writeAttribute(selectData->getIfcTimeSeries());
        break;
    case IfcMetricValueSelect::IFCCOSTVALUE:
        writeAttribute(selectData->getIfcCostValue());
        break;
        }
}

bool SPFWriter::visitIfcMetric(IfcMetric *value) {
    m_out << "#" << value->getKey() << "=IFCMETRIC(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstraintGrade())) {
        m_out << "$";
    }
    else {
        writeIfcConstraintEnum(value->getConstraintGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getConstraintSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConstraintSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreatingActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getCreatingActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedGrade());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getBenchmark())) {
        m_out << "$";
    }
    else {
        writeIfcBenchmarkEnum(value->getBenchmark());
    }
    m_out << ",";
    if (Step::isUnset(value->getValueSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getValueSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getDataValue())) {
        m_out << "$";
    }
    else {
        writeIfcMetricValueSelect(value->getDataValue());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCurrencyEnum(IfcCurrencyEnum enumData) {
    switch(enumData) {
    case IfcCurrencyEnum_AED:
        m_out << ".AED.";
        break;
    case IfcCurrencyEnum_AES:
        m_out << ".AES.";
        break;
    case IfcCurrencyEnum_ATS:
        m_out << ".ATS.";
        break;
    case IfcCurrencyEnum_AUD:
        m_out << ".AUD.";
        break;
    case IfcCurrencyEnum_BBD:
        m_out << ".BBD.";
        break;
    case IfcCurrencyEnum_BEG:
        m_out << ".BEG.";
        break;
    case IfcCurrencyEnum_BGL:
        m_out << ".BGL.";
        break;
    case IfcCurrencyEnum_BHD:
        m_out << ".BHD.";
        break;
    case IfcCurrencyEnum_BMD:
        m_out << ".BMD.";
        break;
    case IfcCurrencyEnum_BND:
        m_out << ".BND.";
        break;
    case IfcCurrencyEnum_BRL:
        m_out << ".BRL.";
        break;
    case IfcCurrencyEnum_BSD:
        m_out << ".BSD.";
        break;
    case IfcCurrencyEnum_BWP:
        m_out << ".BWP.";
        break;
    case IfcCurrencyEnum_BZD:
        m_out << ".BZD.";
        break;
    case IfcCurrencyEnum_CAD:
        m_out << ".CAD.";
        break;
    case IfcCurrencyEnum_CBD:
        m_out << ".CBD.";
        break;
    case IfcCurrencyEnum_CHF:
        m_out << ".CHF.";
        break;
    case IfcCurrencyEnum_CLP:
        m_out << ".CLP.";
        break;
    case IfcCurrencyEnum_CNY:
        m_out << ".CNY.";
        break;
    case IfcCurrencyEnum_CYS:
        m_out << ".CYS.";
        break;
    case IfcCurrencyEnum_CZK:
        m_out << ".CZK.";
        break;
    case IfcCurrencyEnum_DDP:
        m_out << ".DDP.";
        break;
    case IfcCurrencyEnum_DEM:
        m_out << ".DEM.";
        break;
    case IfcCurrencyEnum_DKK:
        m_out << ".DKK.";
        break;
    case IfcCurrencyEnum_EGL:
        m_out << ".EGL.";
        break;
    case IfcCurrencyEnum_EST:
        m_out << ".EST.";
        break;
    case IfcCurrencyEnum_EUR:
        m_out << ".EUR.";
        break;
    case IfcCurrencyEnum_FAK:
        m_out << ".FAK.";
        break;
    case IfcCurrencyEnum_FIM:
        m_out << ".FIM.";
        break;
    case IfcCurrencyEnum_FJD:
        m_out << ".FJD.";
        break;
    case IfcCurrencyEnum_FKP:
        m_out << ".FKP.";
        break;
    case IfcCurrencyEnum_FRF:
        m_out << ".FRF.";
        break;
    case IfcCurrencyEnum_GBP:
        m_out << ".GBP.";
        break;
    case IfcCurrencyEnum_GIP:
        m_out << ".GIP.";
        break;
    case IfcCurrencyEnum_GMD:
        m_out << ".GMD.";
        break;
    case IfcCurrencyEnum_GRX:
        m_out << ".GRX.";
        break;
    case IfcCurrencyEnum_HKD:
        m_out << ".HKD.";
        break;
    case IfcCurrencyEnum_HUF:
        m_out << ".HUF.";
        break;
    case IfcCurrencyEnum_ICK:
        m_out << ".ICK.";
        break;
    case IfcCurrencyEnum_IDR:
        m_out << ".IDR.";
        break;
    case IfcCurrencyEnum_ILS:
        m_out << ".ILS.";
        break;
    case IfcCurrencyEnum_INR:
        m_out << ".INR.";
        break;
    case IfcCurrencyEnum_IRP:
        m_out << ".IRP.";
        break;
    case IfcCurrencyEnum_ITL:
        m_out << ".ITL.";
        break;
    case IfcCurrencyEnum_JMD:
        m_out << ".JMD.";
        break;
    case IfcCurrencyEnum_JOD:
        m_out << ".JOD.";
        break;
    case IfcCurrencyEnum_JPY:
        m_out << ".JPY.";
        break;
    case IfcCurrencyEnum_KES:
        m_out << ".KES.";
        break;
    case IfcCurrencyEnum_KRW:
        m_out << ".KRW.";
        break;
    case IfcCurrencyEnum_KWD:
        m_out << ".KWD.";
        break;
    case IfcCurrencyEnum_KYD:
        m_out << ".KYD.";
        break;
    case IfcCurrencyEnum_LKR:
        m_out << ".LKR.";
        break;
    case IfcCurrencyEnum_LUF:
        m_out << ".LUF.";
        break;
    case IfcCurrencyEnum_MTL:
        m_out << ".MTL.";
        break;
    case IfcCurrencyEnum_MUR:
        m_out << ".MUR.";
        break;
    case IfcCurrencyEnum_MXN:
        m_out << ".MXN.";
        break;
    case IfcCurrencyEnum_MYR:
        m_out << ".MYR.";
        break;
    case IfcCurrencyEnum_NLG:
        m_out << ".NLG.";
        break;
    case IfcCurrencyEnum_NZD:
        m_out << ".NZD.";
        break;
    case IfcCurrencyEnum_OMR:
        m_out << ".OMR.";
        break;
    case IfcCurrencyEnum_PGK:
        m_out << ".PGK.";
        break;
    case IfcCurrencyEnum_PHP:
        m_out << ".PHP.";
        break;
    case IfcCurrencyEnum_PKR:
        m_out << ".PKR.";
        break;
    case IfcCurrencyEnum_PLN:
        m_out << ".PLN.";
        break;
    case IfcCurrencyEnum_PTN:
        m_out << ".PTN.";
        break;
    case IfcCurrencyEnum_QAR:
        m_out << ".QAR.";
        break;
    case IfcCurrencyEnum_RUR:
        m_out << ".RUR.";
        break;
    case IfcCurrencyEnum_SAR:
        m_out << ".SAR.";
        break;
    case IfcCurrencyEnum_SCR:
        m_out << ".SCR.";
        break;
    case IfcCurrencyEnum_SEK:
        m_out << ".SEK.";
        break;
    case IfcCurrencyEnum_SGD:
        m_out << ".SGD.";
        break;
    case IfcCurrencyEnum_SKP:
        m_out << ".SKP.";
        break;
    case IfcCurrencyEnum_THB:
        m_out << ".THB.";
        break;
    case IfcCurrencyEnum_TRL:
        m_out << ".TRL.";
        break;
    case IfcCurrencyEnum_TTD:
        m_out << ".TTD.";
        break;
    case IfcCurrencyEnum_TWD:
        m_out << ".TWD.";
        break;
    case IfcCurrencyEnum_USD:
        m_out << ".USD.";
        break;
    case IfcCurrencyEnum_VEB:
        m_out << ".VEB.";
        break;
    case IfcCurrencyEnum_VND:
        m_out << ".VND.";
        break;
    case IfcCurrencyEnum_XEU:
        m_out << ".XEU.";
        break;
    case IfcCurrencyEnum_ZAR:
        m_out << ".ZAR.";
        break;
    case IfcCurrencyEnum_ZWD:
        m_out << ".ZWD.";
        break;
    case IfcCurrencyEnum_NOK:
        m_out << ".NOK.";
        break;
        }
}

bool SPFWriter::visitIfcMonetaryUnit(IfcMonetaryUnit *value) {
    m_out << "#" << value->getKey() << "=IFCMONETARYUNIT(";
    if (Step::isUnsetEnum(value->getCurrency())) {
        m_out << "$";
    }
    else {
        writeIfcCurrencyEnum(value->getCurrency());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcMotorConnectionTypeEnum(IfcMotorConnectionTypeEnum enumData) {
    switch(enumData) {
    case IfcMotorConnectionTypeEnum_BELTDRIVE:
        m_out << ".BELTDRIVE.";
        break;
    case IfcMotorConnectionTypeEnum_COUPLING:
        m_out << ".COUPLING.";
        break;
    case IfcMotorConnectionTypeEnum_DIRECTDRIVE:
        m_out << ".DIRECTDRIVE.";
        break;
    case IfcMotorConnectionTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcMotorConnectionTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcMotorConnectionType(IfcMotorConnectionType *value) {
    m_out << "#" << value->getKey() << "=IFCMOTORCONNECTIONTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcMotorConnectionTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcMove(IfcMove *value) {
    m_out << "#" << value->getKey() << "=IFCMOVE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTaskId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTaskId());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStatus());
    }
    m_out << ",";
    if (Step::isUnset(value->getWorkMethod())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWorkMethod());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsMilestone())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsMilestone());
    }
    m_out << ",";
    if (Step::isUnset(value->getPriority())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPriority());
    }
    m_out << ",";
    if (Step::isUnset(value->getMoveFrom())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMoveFrom());
    }
    m_out << ",";
    if (Step::isUnset(value->getMoveTo())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMoveTo());
    }
    m_out << ",";
    if (Step::isUnset(value->getPunchList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcText_1_n::iterator step_it0 = (value->getPunchList()).begin();
            if ((value->getPunchList()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getPunchList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcNamedUnit(IfcNamedUnit *value) {
    m_out << "#" << value->getKey() << "=IFCNAMEDUNIT(";
    if (Step::isUnset(value->getDimensions())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDimensions());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getUnitType())) {
        m_out << "$";
    }
    else {
        writeIfcUnitEnum(value->getUnitType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcObject(IfcObject *value) {
    m_out << "#" << value->getKey() << "=IFCOBJECT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcObjectDefinition(IfcObjectDefinition *value) {
    m_out << "#" << value->getKey() << "=IFCOBJECTDEFINITION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcObjectPlacement(IfcObjectPlacement *value) {
    m_out << "#" << value->getKey() << "=IFCOBJECTPLACEMENT(";
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcObjectiveEnum(IfcObjectiveEnum enumData) {
    switch(enumData) {
    case IfcObjectiveEnum_CODECOMPLIANCE:
        m_out << ".CODECOMPLIANCE.";
        break;
    case IfcObjectiveEnum_DESIGNINTENT:
        m_out << ".DESIGNINTENT.";
        break;
    case IfcObjectiveEnum_HEALTHANDSAFETY:
        m_out << ".HEALTHANDSAFETY.";
        break;
    case IfcObjectiveEnum_REQUIREMENT:
        m_out << ".REQUIREMENT.";
        break;
    case IfcObjectiveEnum_SPECIFICATION:
        m_out << ".SPECIFICATION.";
        break;
    case IfcObjectiveEnum_TRIGGERCONDITION:
        m_out << ".TRIGGERCONDITION.";
        break;
    case IfcObjectiveEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcObjectiveEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcObjective(IfcObjective *value) {
    m_out << "#" << value->getKey() << "=IFCOBJECTIVE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstraintGrade())) {
        m_out << "$";
    }
    else {
        writeIfcConstraintEnum(value->getConstraintGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getConstraintSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConstraintSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreatingActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getCreatingActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getBenchmarkValues())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBenchmarkValues());
    }
    m_out << ",";
    if (Step::isUnset(value->getResultValues())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResultValues());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getObjectiveQualifier())) {
        m_out << "$";
    }
    else {
        writeIfcObjectiveEnum(value->getObjectiveQualifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedQualifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedQualifier());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcOccupantTypeEnum(IfcOccupantTypeEnum enumData) {
    switch(enumData) {
    case IfcOccupantTypeEnum_ASSIGNEE:
        m_out << ".ASSIGNEE.";
        break;
    case IfcOccupantTypeEnum_ASSIGNOR:
        m_out << ".ASSIGNOR.";
        break;
    case IfcOccupantTypeEnum_LESSEE:
        m_out << ".LESSEE.";
        break;
    case IfcOccupantTypeEnum_LESSOR:
        m_out << ".LESSOR.";
        break;
    case IfcOccupantTypeEnum_LETTINGAGENT:
        m_out << ".LETTINGAGENT.";
        break;
    case IfcOccupantTypeEnum_OWNER:
        m_out << ".OWNER.";
        break;
    case IfcOccupantTypeEnum_TENANT:
        m_out << ".TENANT.";
        break;
    case IfcOccupantTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcOccupantTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcOccupant(IfcOccupant *value) {
    m_out << "#" << value->getKey() << "=IFCOCCUPANT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTheActor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getTheActor());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcOccupantTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOffsetCurve2D(IfcOffsetCurve2D *value) {
    m_out << "#" << value->getKey() << "=IFCOFFSETCURVE2D(";
    if (Step::isUnset(value->getBasisCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDistance());
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOffsetCurve3D(IfcOffsetCurve3D *value) {
    m_out << "#" << value->getKey() << "=IFCOFFSETCURVE3D(";
    if (Step::isUnset(value->getBasisCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDistance());
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ",";
    if (Step::isUnset(value->getRefDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRefDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOneDirectionRepeatFactor(IfcOneDirectionRepeatFactor *value) {
    m_out << "#" << value->getKey() << "=IFCONEDIRECTIONREPEATFACTOR(";
    if (Step::isUnset(value->getRepeatFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatFactor());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOpenShell(IfcOpenShell *value) {
    m_out << "#" << value->getKey() << "=IFCOPENSHELL(";
    if (Step::isUnset(value->getCfsFaces())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcFace_1_n::iterator step_it0 = (value->getCfsFaces()).begin();
            if ((value->getCfsFaces()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCfsFaces()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOpeningElement(IfcOpeningElement *value) {
    m_out << "#" << value->getKey() << "=IFCOPENINGELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOpticalMaterialProperties(IfcOpticalMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCOPTICALMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getVisibleTransmittance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVisibleTransmittance());
    }
    m_out << ",";
    if (Step::isUnset(value->getSolarTransmittance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSolarTransmittance());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalIrTransmittance())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalIrTransmittance());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalIrEmissivityBack())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalIrEmissivityBack());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalIrEmissivityFront())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalIrEmissivityFront());
    }
    m_out << ",";
    if (Step::isUnset(value->getVisibleReflectanceBack())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVisibleReflectanceBack());
    }
    m_out << ",";
    if (Step::isUnset(value->getVisibleReflectanceFront())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVisibleReflectanceFront());
    }
    m_out << ",";
    if (Step::isUnset(value->getSolarReflectanceFront())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSolarReflectanceFront());
    }
    m_out << ",";
    if (Step::isUnset(value->getSolarReflectanceBack())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSolarReflectanceBack());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOrderAction(IfcOrderAction *value) {
    m_out << "#" << value->getKey() << "=IFCORDERACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTaskId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTaskId());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStatus());
    }
    m_out << ",";
    if (Step::isUnset(value->getWorkMethod())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWorkMethod());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsMilestone())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsMilestone());
    }
    m_out << ",";
    if (Step::isUnset(value->getPriority())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPriority());
    }
    m_out << ",";
    if (Step::isUnset(value->getActionID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getActionID());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOrganization(IfcOrganization *value) {
    m_out << "#" << value->getKey() << "=IFCORGANIZATION(";
    if (Step::isUnset(value->getId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getId());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRoles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcActorRole_1_n::iterator step_it0 = (value->getRoles()).begin();
            if ((value->getRoles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRoles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getAddresses())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcAddress_1_n::iterator step_it0 = (value->getAddresses()).begin();
            if ((value->getAddresses()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getAddresses()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOrganizationRelationship(IfcOrganizationRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCORGANIZATIONRELATIONSHIP(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingOrganization())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingOrganization());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedOrganizations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcOrganization_1_n::iterator step_it0 = (value->getRelatedOrganizations()).begin();
            if ((value->getRelatedOrganizations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedOrganizations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcOrientedEdge(IfcOrientedEdge *value) {
    m_out << "#" << value->getKey() << "=IFCORIENTEDEDGE(";
    m_out << "*";
    m_out << ",";
    m_out << "*";
    m_out << ",";
    if (Step::isUnset(value->getEdgeElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcOutletTypeEnum(IfcOutletTypeEnum enumData) {
    switch(enumData) {
    case IfcOutletTypeEnum_AUDIOVISUALOUTLET:
        m_out << ".AUDIOVISUALOUTLET.";
        break;
    case IfcOutletTypeEnum_COMMUNICATIONSOUTLET:
        m_out << ".COMMUNICATIONSOUTLET.";
        break;
    case IfcOutletTypeEnum_POWEROUTLET:
        m_out << ".POWEROUTLET.";
        break;
    case IfcOutletTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcOutletTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcOutletType(IfcOutletType *value) {
    m_out << "#" << value->getKey() << "=IFCOUTLETTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcOutletTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStateEnum(IfcStateEnum enumData) {
    switch(enumData) {
    case IfcStateEnum_READWRITE:
        m_out << ".READWRITE.";
        break;
    case IfcStateEnum_READONLY:
        m_out << ".READONLY.";
        break;
    case IfcStateEnum_LOCKED:
        m_out << ".LOCKED.";
        break;
    case IfcStateEnum_READWRITELOCKED:
        m_out << ".READWRITELOCKED.";
        break;
    case IfcStateEnum_READONLYLOCKED:
        m_out << ".READONLYLOCKED.";
        break;
        }
}

void SPFWriter::writeIfcChangeActionEnum(IfcChangeActionEnum enumData) {
    switch(enumData) {
    case IfcChangeActionEnum_NOCHANGE:
        m_out << ".NOCHANGE.";
        break;
    case IfcChangeActionEnum_MODIFIED:
        m_out << ".MODIFIED.";
        break;
    case IfcChangeActionEnum_ADDED:
        m_out << ".ADDED.";
        break;
    case IfcChangeActionEnum_DELETED:
        m_out << ".DELETED.";
        break;
    case IfcChangeActionEnum_MODIFIEDADDED:
        m_out << ".MODIFIEDADDED.";
        break;
    case IfcChangeActionEnum_MODIFIEDDELETED:
        m_out << ".MODIFIEDDELETED.";
        break;
        }
}

bool SPFWriter::visitIfcOwnerHistory(IfcOwnerHistory *value) {
    m_out << "#" << value->getKey() << "=IFCOWNERHISTORY(";
    if (Step::isUnset(value->getOwningUser())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwningUser());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwningApplication())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwningApplication());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getState())) {
        m_out << "$";
    }
    else {
        writeIfcStateEnum(value->getState());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getChangeAction())) {
        m_out << "$";
    }
    else {
        writeIfcChangeActionEnum(value->getChangeAction());
    }
    m_out << ",";
    if (Step::isUnset(value->getLastModifiedDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLastModifiedDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getLastModifyingUser())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLastModifyingUser());
    }
    m_out << ",";
    if (Step::isUnset(value->getLastModifyingApplication())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLastModifyingApplication());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationDate())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCreationDate());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcParameterizedProfileDef(IfcParameterizedProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCPARAMETERIZEDPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPath(IfcPath *value) {
    m_out << "#" << value->getKey() << "=IFCPATH(";
    if (Step::isUnset(value->getEdgeList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcOrientedEdge_1_n::iterator step_it0 = (value->getEdgeList()).begin();
            if ((value->getEdgeList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getEdgeList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPerformanceHistory(IfcPerformanceHistory *value) {
    m_out << "#" << value->getKey() << "=IFCPERFORMANCEHISTORY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getLifeCyclePhase())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLifeCyclePhase());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPermeableCoveringOperationEnum(IfcPermeableCoveringOperationEnum enumData) {
    switch(enumData) {
    case IfcPermeableCoveringOperationEnum_GRILL:
        m_out << ".GRILL.";
        break;
    case IfcPermeableCoveringOperationEnum_LOUVER:
        m_out << ".LOUVER.";
        break;
    case IfcPermeableCoveringOperationEnum_SCREEN:
        m_out << ".SCREEN.";
        break;
    case IfcPermeableCoveringOperationEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPermeableCoveringOperationEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcWindowPanelPositionEnum(IfcWindowPanelPositionEnum enumData) {
    switch(enumData) {
    case IfcWindowPanelPositionEnum_LEFT:
        m_out << ".LEFT.";
        break;
    case IfcWindowPanelPositionEnum_MIDDLE:
        m_out << ".MIDDLE.";
        break;
    case IfcWindowPanelPositionEnum_RIGHT:
        m_out << ".RIGHT.";
        break;
    case IfcWindowPanelPositionEnum_BOTTOM:
        m_out << ".BOTTOM.";
        break;
    case IfcWindowPanelPositionEnum_TOP:
        m_out << ".TOP.";
        break;
    case IfcWindowPanelPositionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPermeableCoveringProperties(IfcPermeableCoveringProperties *value) {
    m_out << "#" << value->getKey() << "=IFCPERMEABLECOVERINGPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getOperationType())) {
        m_out << "$";
    }
    else {
        writeIfcPermeableCoveringOperationEnum(value->getOperationType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPanelPosition())) {
        m_out << "$";
    }
    else {
        writeIfcWindowPanelPositionEnum(value->getPanelPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrameDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrameDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrameThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrameThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getShapeAspectStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShapeAspectStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPermit(IfcPermit *value) {
    m_out << "#" << value->getKey() << "=IFCPERMIT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getPermitID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPermitID());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPerson(IfcPerson *value) {
    m_out << "#" << value->getKey() << "=IFCPERSON(";
    if (Step::isUnset(value->getId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getId());
    }
    m_out << ",";
    if (Step::isUnset(value->getFamilyName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFamilyName());
    }
    m_out << ",";
    if (Step::isUnset(value->getGivenName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGivenName());
    }
    m_out << ",";
    if (Step::isUnset(value->getMiddleNames())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getMiddleNames()).begin();
            if ((value->getMiddleNames()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getMiddleNames()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPrefixTitles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getPrefixTitles()).begin();
            if ((value->getPrefixTitles()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getPrefixTitles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getSuffixTitles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getSuffixTitles()).begin();
            if ((value->getSuffixTitles()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getSuffixTitles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRoles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcActorRole_1_n::iterator step_it0 = (value->getRoles()).begin();
            if ((value->getRoles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRoles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getAddresses())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcAddress_1_n::iterator step_it0 = (value->getAddresses()).begin();
            if ((value->getAddresses()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getAddresses()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPersonAndOrganization(IfcPersonAndOrganization *value) {
    m_out << "#" << value->getKey() << "=IFCPERSONANDORGANIZATION(";
    if (Step::isUnset(value->getThePerson())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThePerson());
    }
    m_out << ",";
    if (Step::isUnset(value->getTheOrganization())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTheOrganization());
    }
    m_out << ",";
    if (Step::isUnset(value->getRoles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcActorRole_1_n::iterator step_it0 = (value->getRoles()).begin();
            if ((value->getRoles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRoles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPhysicalComplexQuantity(IfcPhysicalComplexQuantity *value) {
    m_out << "#" << value->getKey() << "=IFCPHYSICALCOMPLEXQUANTITY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasQuantities())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPhysicalQuantity_1_n::iterator step_it0 = (value->getHasQuantities()).begin();
            if ((value->getHasQuantities()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasQuantities()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getDiscrimination())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDiscrimination());
    }
    m_out << ",";
    if (Step::isUnset(value->getQuality())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getQuality());
    }
    m_out << ",";
    if (Step::isUnset(value->getUsage())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUsage());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPhysicalQuantity(IfcPhysicalQuantity *value) {
    m_out << "#" << value->getKey() << "=IFCPHYSICALQUANTITY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPhysicalSimpleQuantity(IfcPhysicalSimpleQuantity *value) {
    m_out << "#" << value->getKey() << "=IFCPHYSICALSIMPLEQUANTITY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPileTypeEnum(IfcPileTypeEnum enumData) {
    switch(enumData) {
    case IfcPileTypeEnum_COHESION:
        m_out << ".COHESION.";
        break;
    case IfcPileTypeEnum_FRICTION:
        m_out << ".FRICTION.";
        break;
    case IfcPileTypeEnum_SUPPORT:
        m_out << ".SUPPORT.";
        break;
    case IfcPileTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPileTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcPileConstructionEnum(IfcPileConstructionEnum enumData) {
    switch(enumData) {
    case IfcPileConstructionEnum_CAST_IN_PLACE:
        m_out << ".CAST_IN_PLACE.";
        break;
    case IfcPileConstructionEnum_COMPOSITE:
        m_out << ".COMPOSITE.";
        break;
    case IfcPileConstructionEnum_PRECAST_CONCRETE:
        m_out << ".PRECAST_CONCRETE.";
        break;
    case IfcPileConstructionEnum_PREFAB_STEEL:
        m_out << ".PREFAB_STEEL.";
        break;
    case IfcPileConstructionEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPileConstructionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPile(IfcPile *value) {
    m_out << "#" << value->getKey() << "=IFCPILE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcPileTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstructionType())) {
        m_out << "$";
    }
    else {
        writeIfcPileConstructionEnum(value->getConstructionType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPipeFittingTypeEnum(IfcPipeFittingTypeEnum enumData) {
    switch(enumData) {
    case IfcPipeFittingTypeEnum_BEND:
        m_out << ".BEND.";
        break;
    case IfcPipeFittingTypeEnum_CONNECTOR:
        m_out << ".CONNECTOR.";
        break;
    case IfcPipeFittingTypeEnum_ENTRY:
        m_out << ".ENTRY.";
        break;
    case IfcPipeFittingTypeEnum_EXIT:
        m_out << ".EXIT.";
        break;
    case IfcPipeFittingTypeEnum_JUNCTION:
        m_out << ".JUNCTION.";
        break;
    case IfcPipeFittingTypeEnum_OBSTRUCTION:
        m_out << ".OBSTRUCTION.";
        break;
    case IfcPipeFittingTypeEnum_TRANSITION:
        m_out << ".TRANSITION.";
        break;
    case IfcPipeFittingTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPipeFittingTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPipeFittingType(IfcPipeFittingType *value) {
    m_out << "#" << value->getKey() << "=IFCPIPEFITTINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcPipeFittingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPipeSegmentTypeEnum(IfcPipeSegmentTypeEnum enumData) {
    switch(enumData) {
    case IfcPipeSegmentTypeEnum_FLEXIBLESEGMENT:
        m_out << ".FLEXIBLESEGMENT.";
        break;
    case IfcPipeSegmentTypeEnum_RIGIDSEGMENT:
        m_out << ".RIGIDSEGMENT.";
        break;
    case IfcPipeSegmentTypeEnum_GUTTER:
        m_out << ".GUTTER.";
        break;
    case IfcPipeSegmentTypeEnum_SPOOL:
        m_out << ".SPOOL.";
        break;
    case IfcPipeSegmentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPipeSegmentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPipeSegmentType(IfcPipeSegmentType *value) {
    m_out << "#" << value->getKey() << "=IFCPIPESEGMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcPipeSegmentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPixelTexture(IfcPixelTexture *value) {
    m_out << "#" << value->getKey() << "=IFCPIXELTEXTURE(";
    if (Step::isUnset(value->getRepeatS())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatS());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepeatT())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatT());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTextureType())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceTextureEnum(value->getTextureType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextureTransform())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextureTransform());
    }
    m_out << ",";
    if (Step::isUnset(value->getWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getColourComponents())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getColourComponents());
    }
    m_out << ",";
    if (Step::isUnset(value->getPixel())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_32_1_n::iterator step_it0 = (value->getPixel()).begin();
            if ((value->getPixel()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getPixel()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPlacement(IfcPlacement *value) {
    m_out << "#" << value->getKey() << "=IFCPLACEMENT(";
    if (Step::isUnset(value->getLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPlanarBox(IfcPlanarBox *value) {
    m_out << "#" << value->getKey() << "=IFCPLANARBOX(";
    if (Step::isUnset(value->getSizeInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getSizeInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeInY());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlacement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPlacement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPlanarExtent(IfcPlanarExtent *value) {
    m_out << "#" << value->getKey() << "=IFCPLANAREXTENT(";
    if (Step::isUnset(value->getSizeInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getSizeInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPlane(IfcPlane *value) {
    m_out << "#" << value->getKey() << "=IFCPLANE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPlate(IfcPlate *value) {
    m_out << "#" << value->getKey() << "=IFCPLATE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPlateTypeEnum(IfcPlateTypeEnum enumData) {
    switch(enumData) {
    case IfcPlateTypeEnum_CURTAIN_PANEL:
        m_out << ".CURTAIN_PANEL.";
        break;
    case IfcPlateTypeEnum_SHEET:
        m_out << ".SHEET.";
        break;
    case IfcPlateTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPlateTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPlateType(IfcPlateType *value) {
    m_out << "#" << value->getKey() << "=IFCPLATETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcPlateTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPoint(IfcPoint *value) {
    m_out << "#" << value->getKey() << "=IFCPOINT(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPointOnCurve(IfcPointOnCurve *value) {
    m_out << "#" << value->getKey() << "=IFCPOINTONCURVE(";
    if (Step::isUnset(value->getBasisCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointParameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPointParameter());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPointOnSurface(IfcPointOnSurface *value) {
    m_out << "#" << value->getKey() << "=IFCPOINTONSURFACE(";
    if (Step::isUnset(value->getBasisSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointParameterU())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPointParameterU());
    }
    m_out << ",";
    if (Step::isUnset(value->getPointParameterV())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPointParameterV());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPolyLoop(IfcPolyLoop *value) {
    m_out << "#" << value->getKey() << "=IFCPOLYLOOP(";
    if (Step::isUnset(value->getPolygon())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_3_n::iterator step_it0 = (value->getPolygon()).begin();
            if ((value->getPolygon()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getPolygon()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPolygonalBoundedHalfSpace(IfcPolygonalBoundedHalfSpace *value) {
    m_out << "#" << value->getKey() << "=IFCPOLYGONALBOUNDEDHALFSPACE(";
    if (Step::isUnset(value->getBaseSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getAgreementFlag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAgreementFlag());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getPolygonalBoundary())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPolygonalBoundary());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPolyline(IfcPolyline *value) {
    m_out << "#" << value->getKey() << "=IFCPOLYLINE(";
    if (Step::isUnset(value->getPoints())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_2_n::iterator step_it0 = (value->getPoints()).begin();
            if ((value->getPoints()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getPoints()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPort(IfcPort *value) {
    m_out << "#" << value->getKey() << "=IFCPORT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPostalAddress(IfcPostalAddress *value) {
    m_out << "#" << value->getKey() << "=IFCPOSTALADDRESS(";
    if (Step::isUnsetEnum(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeIfcAddressTypeEnum(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getInternalLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInternalLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAddressLines())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getAddressLines()).begin();
            if ((value->getAddressLines()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getAddressLines()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPostalBox())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPostalBox());
    }
    m_out << ",";
    if (Step::isUnset(value->getTown())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTown());
    }
    m_out << ",";
    if (Step::isUnset(value->getRegion())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRegion());
    }
    m_out << ",";
    if (Step::isUnset(value->getPostalCode())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPostalCode());
    }
    m_out << ",";
    if (Step::isUnset(value->getCountry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCountry());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedColour(IfcPreDefinedColour *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDCOLOUR(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedCurveFont(IfcPreDefinedCurveFont *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDCURVEFONT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedDimensionSymbol(IfcPreDefinedDimensionSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDDIMENSIONSYMBOL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedItem(IfcPreDefinedItem *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDITEM(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedPointMarkerSymbol(IfcPreDefinedPointMarkerSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDPOINTMARKERSYMBOL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedSymbol(IfcPreDefinedSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDSYMBOL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedTerminatorSymbol(IfcPreDefinedTerminatorSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDTERMINATORSYMBOL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPreDefinedTextFont(IfcPreDefinedTextFont *value) {
    m_out << "#" << value->getKey() << "=IFCPREDEFINEDTEXTFONT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLayeredItem(IfcLayeredItem *selectData) {
    switch(selectData->currentType()) {
    case IfcLayeredItem::IFCREPRESENTATIONITEM:
        writeAttribute(selectData->getIfcRepresentationItem());
        break;
    case IfcLayeredItem::IFCREPRESENTATION:
        writeAttribute(selectData->getIfcRepresentation());
        break;
        }
}

bool SPFWriter::visitIfcPresentationLayerAssignment(IfcPresentationLayerAssignment *value) {
    m_out << "#" << value->getKey() << "=IFCPRESENTATIONLAYERASSIGNMENT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getAssignedItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcLayeredItem_1_n::iterator step_it0 = (value->getAssignedItems()).begin();
            if ((value->getAssignedItems()).size()) {
                writeIfcLayeredItem((*step_it0).get());
                for (step_it0++; step_it0 != (value->getAssignedItems()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcLayeredItem((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPresentationStyleSelect(IfcPresentationStyleSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcPresentationStyleSelect::IFCNULLSTYLE:
        m_out << "IFCNULLSTYLE(";
        writeIfcNullStyle(selectData->getIfcNullStyle());
        m_out << ")";
        break;
    case IfcPresentationStyleSelect::IFCCURVESTYLE:
        writeAttribute(selectData->getIfcCurveStyle());
        break;
    case IfcPresentationStyleSelect::IFCSYMBOLSTYLE:
        writeAttribute(selectData->getIfcSymbolStyle());
        break;
    case IfcPresentationStyleSelect::IFCFILLAREASTYLE:
        writeAttribute(selectData->getIfcFillAreaStyle());
        break;
    case IfcPresentationStyleSelect::IFCTEXTSTYLE:
        writeAttribute(selectData->getIfcTextStyle());
        break;
    case IfcPresentationStyleSelect::IFCSURFACESTYLE:
        writeAttribute(selectData->getIfcSurfaceStyle());
        break;
        }
}

void SPFWriter::writeIfcNullStyle(IfcNullStyle enumData) {
    switch(enumData) {
    case IfcNullStyle_NULL:
        m_out << ".NULL.";
        break;
        }
}

bool SPFWriter::visitIfcPresentationLayerWithStyle(IfcPresentationLayerWithStyle *value) {
    m_out << "#" << value->getKey() << "=IFCPRESENTATIONLAYERWITHSTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getAssignedItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcLayeredItem_1_n::iterator step_it0 = (value->getAssignedItems()).begin();
            if ((value->getAssignedItems()).size()) {
                writeIfcLayeredItem((*step_it0).get());
                for (step_it0++; step_it0 != (value->getAssignedItems()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcLayeredItem((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerOn())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLayerOn());
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerFrozen())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLayerFrozen());
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerBlocked())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLayerBlocked());
    }
    m_out << ",";
    if (Step::isUnset(value->getLayerStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleSelect_0_n::iterator step_it0 = (value->getLayerStyles()).begin();
            if ((value->getLayerStyles()).size()) {
                writeIfcPresentationStyleSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getLayerStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcPresentationStyleSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPresentationStyle(IfcPresentationStyle *value) {
    m_out << "#" << value->getKey() << "=IFCPRESENTATIONSTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPresentationStyleAssignment(IfcPresentationStyleAssignment *value) {
    m_out << "#" << value->getKey() << "=IFCPRESENTATIONSTYLEASSIGNMENT(";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleSelect_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeIfcPresentationStyleSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcPresentationStyleSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProcedureTypeEnum(IfcProcedureTypeEnum enumData) {
    switch(enumData) {
    case IfcProcedureTypeEnum_ADVICE_CAUTION:
        m_out << ".ADVICE_CAUTION.";
        break;
    case IfcProcedureTypeEnum_ADVICE_NOTE:
        m_out << ".ADVICE_NOTE.";
        break;
    case IfcProcedureTypeEnum_ADVICE_WARNING:
        m_out << ".ADVICE_WARNING.";
        break;
    case IfcProcedureTypeEnum_CALIBRATION:
        m_out << ".CALIBRATION.";
        break;
    case IfcProcedureTypeEnum_DIAGNOSTIC:
        m_out << ".DIAGNOSTIC.";
        break;
    case IfcProcedureTypeEnum_SHUTDOWN:
        m_out << ".SHUTDOWN.";
        break;
    case IfcProcedureTypeEnum_STARTUP:
        m_out << ".STARTUP.";
        break;
    case IfcProcedureTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcProcedureTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcProcedure(IfcProcedure *value) {
    m_out << "#" << value->getKey() << "=IFCPROCEDURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProcedureID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProcedureID());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProcedureType())) {
        m_out << "$";
    }
    else {
        writeIfcProcedureTypeEnum(value->getProcedureType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedProcedureType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedProcedureType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProcess(IfcProcess *value) {
    m_out << "#" << value->getKey() << "=IFCPROCESS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProduct(IfcProduct *value) {
    m_out << "#" << value->getKey() << "=IFCPRODUCT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProductDefinitionShape(IfcProductDefinitionShape *value) {
    m_out << "#" << value->getKey() << "=IFCPRODUCTDEFINITIONSHAPE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentation_1_n::iterator step_it0 = (value->getRepresentations()).begin();
            if ((value->getRepresentations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProductRepresentation(IfcProductRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCPRODUCTREPRESENTATION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentation_1_n::iterator step_it0 = (value->getRepresentations()).begin();
            if ((value->getRepresentations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProductsOfCombustionProperties(IfcProductsOfCombustionProperties *value) {
    m_out << "#" << value->getKey() << "=IFCPRODUCTSOFCOMBUSTIONPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpecificHeatCapacity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSpecificHeatCapacity());
    }
    m_out << ",";
    if (Step::isUnset(value->getN20Content())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getN20Content());
    }
    m_out << ",";
    if (Step::isUnset(value->getCOContent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCOContent());
    }
    m_out << ",";
    if (Step::isUnset(value->getCO2Content())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCO2Content());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProfileDef(IfcProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProfileProperties(IfcProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCPROFILEPROPERTIES(";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileDefinition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProject(IfcProject *value) {
    m_out << "#" << value->getKey() << "=IFCPROJECT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPhase())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPhase());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationContexts())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationContext_1_n::iterator step_it0 = (value->getRepresentationContexts()).begin();
            if ((value->getRepresentationContexts()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationContexts()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getUnitsInContext())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnitsInContext());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProjectOrderTypeEnum(IfcProjectOrderTypeEnum enumData) {
    switch(enumData) {
    case IfcProjectOrderTypeEnum_CHANGEORDER:
        m_out << ".CHANGEORDER.";
        break;
    case IfcProjectOrderTypeEnum_MAINTENANCEWORKORDER:
        m_out << ".MAINTENANCEWORKORDER.";
        break;
    case IfcProjectOrderTypeEnum_MOVEORDER:
        m_out << ".MOVEORDER.";
        break;
    case IfcProjectOrderTypeEnum_PURCHASEORDER:
        m_out << ".PURCHASEORDER.";
        break;
    case IfcProjectOrderTypeEnum_WORKORDER:
        m_out << ".WORKORDER.";
        break;
    case IfcProjectOrderTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcProjectOrderTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcProjectOrder(IfcProjectOrder *value) {
    m_out << "#" << value->getKey() << "=IFCPROJECTORDER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getID())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getID());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcProjectOrderTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStatus());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProjectOrderRecordTypeEnum(IfcProjectOrderRecordTypeEnum enumData) {
    switch(enumData) {
    case IfcProjectOrderRecordTypeEnum_CHANGE:
        m_out << ".CHANGE.";
        break;
    case IfcProjectOrderRecordTypeEnum_MAINTENANCE:
        m_out << ".MAINTENANCE.";
        break;
    case IfcProjectOrderRecordTypeEnum_MOVE:
        m_out << ".MOVE.";
        break;
    case IfcProjectOrderRecordTypeEnum_PURCHASE:
        m_out << ".PURCHASE.";
        break;
    case IfcProjectOrderRecordTypeEnum_WORK:
        m_out << ".WORK.";
        break;
    case IfcProjectOrderRecordTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcProjectOrderRecordTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcProjectOrderRecord(IfcProjectOrderRecord *value) {
    m_out << "#" << value->getKey() << "=IFCPROJECTORDERRECORD(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRecords())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRelAssignsToProjectOrder_1_n::iterator step_it0 = (value->getRecords()).begin();
            if ((value->getRecords()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRecords()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcProjectOrderRecordTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProjectionCurve(IfcProjectionCurve *value) {
    m_out << "#" << value->getKey() << "=IFCPROJECTIONCURVE(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProjectionElement(IfcProjectionElement *value) {
    m_out << "#" << value->getKey() << "=IFCPROJECTIONELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcProperty(IfcProperty *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyBoundedValue(IfcPropertyBoundedValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYBOUNDEDVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUpperBoundValue())) {
        m_out << "$";
    }
    else {
        writeIfcValue(value->getUpperBoundValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getLowerBoundValue())) {
        m_out << "$";
    }
    else {
        writeIfcValue(value->getLowerBoundValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyConstraintRelationship(IfcPropertyConstraintRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYCONSTRAINTRELATIONSHIP(";
    if (Step::isUnset(value->getRelatingConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingConstraint());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getRelatedProperties()).begin();
            if ((value->getRelatedProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyDefinition(IfcPropertyDefinition *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYDEFINITION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyDependencyRelationship(IfcPropertyDependencyRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYDEPENDENCYRELATIONSHIP(";
    if (Step::isUnset(value->getDependingProperty())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDependingProperty());
    }
    m_out << ",";
    if (Step::isUnset(value->getDependantProperty())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDependantProperty());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getExpression())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExpression());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyEnumeratedValue(IfcPropertyEnumeratedValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYENUMERATEDVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getEnumerationValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getEnumerationValues()).begin();
            if ((value->getEnumerationValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getEnumerationValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getEnumerationReference())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEnumerationReference());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyEnumeration(IfcPropertyEnumeration *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYENUMERATION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getEnumerationValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getEnumerationValues()).begin();
            if ((value->getEnumerationValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getEnumerationValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyListValue(IfcPropertyListValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYLISTVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getListValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getListValues()).begin();
            if ((value->getListValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getListValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcObjectReferenceSelect(IfcObjectReferenceSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcObjectReferenceSelect::IFCMATERIAL:
        writeAttribute(selectData->getIfcMaterial());
        break;
    case IfcObjectReferenceSelect::IFCPERSON:
        writeAttribute(selectData->getIfcPerson());
        break;
    case IfcObjectReferenceSelect::IFCDATEANDTIME:
        writeAttribute(selectData->getIfcDateAndTime());
        break;
    case IfcObjectReferenceSelect::IFCMATERIALLIST:
        writeAttribute(selectData->getIfcMaterialList());
        break;
    case IfcObjectReferenceSelect::IFCORGANIZATION:
        writeAttribute(selectData->getIfcOrganization());
        break;
    case IfcObjectReferenceSelect::IFCCALENDARDATE:
        writeAttribute(selectData->getIfcCalendarDate());
        break;
    case IfcObjectReferenceSelect::IFCLOCALTIME:
        writeAttribute(selectData->getIfcLocalTime());
        break;
    case IfcObjectReferenceSelect::IFCPERSONANDORGANIZATION:
        writeAttribute(selectData->getIfcPersonAndOrganization());
        break;
    case IfcObjectReferenceSelect::IFCMATERIALLAYER:
        writeAttribute(selectData->getIfcMaterialLayer());
        break;
    case IfcObjectReferenceSelect::IFCEXTERNALREFERENCE:
        writeAttribute(selectData->getIfcExternalReference());
        break;
    case IfcObjectReferenceSelect::IFCTIMESERIES:
        writeAttribute(selectData->getIfcTimeSeries());
        break;
    case IfcObjectReferenceSelect::IFCADDRESS:
        writeAttribute(selectData->getIfcAddress());
        break;
    case IfcObjectReferenceSelect::IFCAPPLIEDVALUE:
        writeAttribute(selectData->getIfcAppliedValue());
        break;
        }
}

bool SPFWriter::visitIfcPropertyReferenceValue(IfcPropertyReferenceValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYREFERENCEVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUsageName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUsageName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPropertyReference())) {
        m_out << "$";
    }
    else {
        writeIfcObjectReferenceSelect(value->getPropertyReference());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertySet(IfcPropertySet *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYSET(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getHasProperties()).begin();
            if ((value->getHasProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertySetDefinition(IfcPropertySetDefinition *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYSETDEFINITION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertySingleValue(IfcPropertySingleValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYSINGLEVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalValue())) {
        m_out << "$";
    }
    else {
        writeIfcValue(value->getNominalValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcPropertyTableValue(IfcPropertyTableValue *value) {
    m_out << "#" << value->getKey() << "=IFCPROPERTYTABLEVALUE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getDefiningValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getDefiningValues()).begin();
            if ((value->getDefiningValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getDefiningValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getDefinedValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getDefinedValues()).begin();
            if ((value->getDefinedValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getDefinedValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getExpression())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExpression());
    }
    m_out << ",";
    if (Step::isUnset(value->getDefiningUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getDefiningUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getDefinedUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getDefinedUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProtectiveDeviceTypeEnum(IfcProtectiveDeviceTypeEnum enumData) {
    switch(enumData) {
    case IfcProtectiveDeviceTypeEnum_FUSEDISCONNECTOR:
        m_out << ".FUSEDISCONNECTOR.";
        break;
    case IfcProtectiveDeviceTypeEnum_CIRCUITBREAKER:
        m_out << ".CIRCUITBREAKER.";
        break;
    case IfcProtectiveDeviceTypeEnum_EARTHFAILUREDEVICE:
        m_out << ".EARTHFAILUREDEVICE.";
        break;
    case IfcProtectiveDeviceTypeEnum_RESIDUALCURRENTCIRCUITBREAKER:
        m_out << ".RESIDUALCURRENTCIRCUITBREAKER.";
        break;
    case IfcProtectiveDeviceTypeEnum_RESIDUALCURRENTSWITCH:
        m_out << ".RESIDUALCURRENTSWITCH.";
        break;
    case IfcProtectiveDeviceTypeEnum_VARISTOR:
        m_out << ".VARISTOR.";
        break;
    case IfcProtectiveDeviceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcProtectiveDeviceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcProtectiveDeviceType(IfcProtectiveDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCPROTECTIVEDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcProtectiveDeviceTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcObjectTypeEnum(IfcObjectTypeEnum enumData) {
    switch(enumData) {
    case IfcObjectTypeEnum_PRODUCT:
        m_out << ".PRODUCT.";
        break;
    case IfcObjectTypeEnum_PROCESS:
        m_out << ".PROCESS.";
        break;
    case IfcObjectTypeEnum_CONTROL:
        m_out << ".CONTROL.";
        break;
    case IfcObjectTypeEnum_RESOURCE:
        m_out << ".RESOURCE.";
        break;
    case IfcObjectTypeEnum_ACTOR:
        m_out << ".ACTOR.";
        break;
    case IfcObjectTypeEnum_GROUP:
        m_out << ".GROUP.";
        break;
    case IfcObjectTypeEnum_PROJECT:
        m_out << ".PROJECT.";
        break;
    case IfcObjectTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcProxy(IfcProxy *value) {
    m_out << "#" << value->getKey() << "=IFCPROXY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProxyType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getProxyType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPumpTypeEnum(IfcPumpTypeEnum enumData) {
    switch(enumData) {
    case IfcPumpTypeEnum_CIRCULATOR:
        m_out << ".CIRCULATOR.";
        break;
    case IfcPumpTypeEnum_ENDSUCTION:
        m_out << ".ENDSUCTION.";
        break;
    case IfcPumpTypeEnum_SPLITCASE:
        m_out << ".SPLITCASE.";
        break;
    case IfcPumpTypeEnum_VERTICALINLINE:
        m_out << ".VERTICALINLINE.";
        break;
    case IfcPumpTypeEnum_VERTICALTURBINE:
        m_out << ".VERTICALTURBINE.";
        break;
    case IfcPumpTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcPumpTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcPumpType(IfcPumpType *value) {
    m_out << "#" << value->getKey() << "=IFCPUMPTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcPumpTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityArea(IfcQuantityArea *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYAREA(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getAreaValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAreaValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityCount(IfcQuantityCount *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYCOUNT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getCountValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCountValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityLength(IfcQuantityLength *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYLENGTH(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getLengthValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLengthValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityTime(IfcQuantityTime *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYTIME(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityVolume(IfcQuantityVolume *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYVOLUME(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getVolumeValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVolumeValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcQuantityWeight(IfcQuantityWeight *value) {
    m_out << "#" << value->getKey() << "=IFCQUANTITYWEIGHT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getWeightValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWeightValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRadiusDimension(IfcRadiusDimension *value) {
    m_out << "#" << value->getKey() << "=IFCRADIUSDIMENSION(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRailingTypeEnum(IfcRailingTypeEnum enumData) {
    switch(enumData) {
    case IfcRailingTypeEnum_HANDRAIL:
        m_out << ".HANDRAIL.";
        break;
    case IfcRailingTypeEnum_GUARDRAIL:
        m_out << ".GUARDRAIL.";
        break;
    case IfcRailingTypeEnum_BALUSTRADE:
        m_out << ".BALUSTRADE.";
        break;
    case IfcRailingTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcRailingTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRailing(IfcRailing *value) {
    m_out << "#" << value->getKey() << "=IFCRAILING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcRailingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRailingType(IfcRailingType *value) {
    m_out << "#" << value->getKey() << "=IFCRAILINGTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcRailingTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRampTypeEnum(IfcRampTypeEnum enumData) {
    switch(enumData) {
    case IfcRampTypeEnum_STRAIGHT_RUN_RAMP:
        m_out << ".STRAIGHT_RUN_RAMP.";
        break;
    case IfcRampTypeEnum_TWO_STRAIGHT_RUN_RAMP:
        m_out << ".TWO_STRAIGHT_RUN_RAMP.";
        break;
    case IfcRampTypeEnum_QUARTER_TURN_RAMP:
        m_out << ".QUARTER_TURN_RAMP.";
        break;
    case IfcRampTypeEnum_TWO_QUARTER_TURN_RAMP:
        m_out << ".TWO_QUARTER_TURN_RAMP.";
        break;
    case IfcRampTypeEnum_HALF_TURN_RAMP:
        m_out << ".HALF_TURN_RAMP.";
        break;
    case IfcRampTypeEnum_SPIRAL_RAMP:
        m_out << ".SPIRAL_RAMP.";
        break;
    case IfcRampTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcRampTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRamp(IfcRamp *value) {
    m_out << "#" << value->getKey() << "=IFCRAMP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getShapeType())) {
        m_out << "$";
    }
    else {
        writeIfcRampTypeEnum(value->getShapeType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRampFlight(IfcRampFlight *value) {
    m_out << "#" << value->getKey() << "=IFCRAMPFLIGHT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRampFlightTypeEnum(IfcRampFlightTypeEnum enumData) {
    switch(enumData) {
    case IfcRampFlightTypeEnum_STRAIGHT:
        m_out << ".STRAIGHT.";
        break;
    case IfcRampFlightTypeEnum_SPIRAL:
        m_out << ".SPIRAL.";
        break;
    case IfcRampFlightTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcRampFlightTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRampFlightType(IfcRampFlightType *value) {
    m_out << "#" << value->getKey() << "=IFCRAMPFLIGHTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcRampFlightTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRationalBezierCurve(IfcRationalBezierCurve *value) {
    m_out << "#" << value->getKey() << "=IFCRATIONALBEZIERCURVE(";
    if (Step::isUnset(value->getDegree())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDegree());
    }
    m_out << ",";
    if (Step::isUnset(value->getControlPointsList())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_2_n::iterator step_it0 = (value->getControlPointsList()).begin();
            if ((value->getControlPointsList()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getControlPointsList()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCurveForm())) {
        m_out << "$";
    }
    else {
        writeIfcBSplineCurveForm(value->getCurveForm());
    }
    m_out << ",";
    if (Step::isUnset(value->getClosedCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getClosedCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getSelfIntersect())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSelfIntersect());
    }
    m_out << ",";
    if (Step::isUnset(value->getWeightsData())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_Real_2_n::iterator step_it0 = (value->getWeightsData()).begin();
            if ((value->getWeightsData()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getWeightsData()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRectangleHollowProfileDef(IfcRectangleHollowProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCRECTANGLEHOLLOWPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getYDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getWallThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWallThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getInnerFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInnerFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getOuterFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOuterFilletRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRectangleProfileDef(IfcRectangleProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCRECTANGLEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getYDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYDim());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRectangularPyramid(IfcRectangularPyramid *value) {
    m_out << "#" << value->getKey() << "=IFCRECTANGULARPYRAMID(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getXLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getYLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeight());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRectangularTrimmedSurface(IfcRectangularTrimmedSurface *value) {
    m_out << "#" << value->getKey() << "=IFCRECTANGULARTRIMMEDSURFACE(";
    if (Step::isUnset(value->getBasisSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getU1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getU1());
    }
    m_out << ",";
    if (Step::isUnset(value->getV1())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getV1());
    }
    m_out << ",";
    if (Step::isUnset(value->getU2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getU2());
    }
    m_out << ",";
    if (Step::isUnset(value->getV2())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getV2());
    }
    m_out << ",";
    if (Step::isUnset(value->getUsense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUsense());
    }
    m_out << ",";
    if (Step::isUnset(value->getVsense())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVsense());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcDocumentSelect(IfcDocumentSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcDocumentSelect::IFCDOCUMENTREFERENCE:
        writeAttribute(selectData->getIfcDocumentReference());
        break;
    case IfcDocumentSelect::IFCDOCUMENTINFORMATION:
        writeAttribute(selectData->getIfcDocumentInformation());
        break;
        }
}

bool SPFWriter::visitIfcReferencesValueDocument(IfcReferencesValueDocument *value) {
    m_out << "#" << value->getKey() << "=IFCREFERENCESVALUEDOCUMENT(";
    if (Step::isUnset(value->getReferencedDocument())) {
        m_out << "$";
    }
    else {
        writeIfcDocumentSelect(value->getReferencedDocument());
    }
    m_out << ",";
    if (Step::isUnset(value->getReferencingValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcAppliedValue_1_n::iterator step_it0 = (value->getReferencingValues()).begin();
            if ((value->getReferencingValues()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getReferencingValues()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRegularTimeSeries(IfcRegularTimeSeries *value) {
    m_out << "#" << value->getKey() << "=IFCREGULARTIMESERIES(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getEndTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTimeSeriesDataType())) {
        m_out << "$";
    }
    else {
        writeIfcTimeSeriesDataTypeEnum(value->getTimeSeriesDataType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDataOrigin())) {
        m_out << "$";
    }
    else {
        writeIfcDataOriginEnum(value->getDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedDataOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeStep())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeStep());
    }
    m_out << ",";
    if (Step::isUnset(value->getValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcTimeSeriesValue_1_n::iterator step_it0 = (value->getValues()).begin();
            if ((value->getValues()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getValues()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcReinforcingBarSurfaceEnum(IfcReinforcingBarSurfaceEnum enumData) {
    switch(enumData) {
    case IfcReinforcingBarSurfaceEnum_PLAIN:
        m_out << ".PLAIN.";
        break;
    case IfcReinforcingBarSurfaceEnum_TEXTURED:
        m_out << ".TEXTURED.";
        break;
        }
}

bool SPFWriter::visitIfcReinforcementBarProperties(IfcReinforcementBarProperties *value) {
    m_out << "#" << value->getKey() << "=IFCREINFORCEMENTBARPROPERTIES(";
    if (Step::isUnset(value->getTotalCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getBarSurface())) {
        m_out << "$";
    }
    else {
        writeIfcReinforcingBarSurfaceEnum(value->getBarSurface());
    }
    m_out << ",";
    if (Step::isUnset(value->getEffectiveDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEffectiveDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalBarDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNominalBarDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getBarCount())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBarCount());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcReinforcementDefinitionProperties(IfcReinforcementDefinitionProperties *value) {
    m_out << "#" << value->getKey() << "=IFCREINFORCEMENTDEFINITIONPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getDefinitionType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDefinitionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getReinforcementSectionDefinitions())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcSectionReinforcementProperties_1_n::iterator step_it0 = (value->getReinforcementSectionDefinitions()).begin();
            if ((value->getReinforcementSectionDefinitions()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getReinforcementSectionDefinitions()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcReinforcingBarRoleEnum(IfcReinforcingBarRoleEnum enumData) {
    switch(enumData) {
    case IfcReinforcingBarRoleEnum_MAIN:
        m_out << ".MAIN.";
        break;
    case IfcReinforcingBarRoleEnum_SHEAR:
        m_out << ".SHEAR.";
        break;
    case IfcReinforcingBarRoleEnum_LIGATURE:
        m_out << ".LIGATURE.";
        break;
    case IfcReinforcingBarRoleEnum_STUD:
        m_out << ".STUD.";
        break;
    case IfcReinforcingBarRoleEnum_PUNCHING:
        m_out << ".PUNCHING.";
        break;
    case IfcReinforcingBarRoleEnum_EDGE:
        m_out << ".EDGE.";
        break;
    case IfcReinforcingBarRoleEnum_RING:
        m_out << ".RING.";
        break;
    case IfcReinforcingBarRoleEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcReinforcingBarRoleEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcReinforcingBar(IfcReinforcingBar *value) {
    m_out << "#" << value->getKey() << "=IFCREINFORCINGBAR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNominalDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getBarLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBarLength());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getBarRole())) {
        m_out << "$";
    }
    else {
        writeIfcReinforcingBarRoleEnum(value->getBarRole());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getBarSurface())) {
        m_out << "$";
    }
    else {
        writeIfcReinforcingBarSurfaceEnum(value->getBarSurface());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcReinforcingElement(IfcReinforcingElement *value) {
    m_out << "#" << value->getKey() << "=IFCREINFORCINGELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcReinforcingMesh(IfcReinforcingMesh *value) {
    m_out << "#" << value->getKey() << "=IFCREINFORCINGMESH(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ",";
    if (Step::isUnset(value->getMeshLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMeshLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getMeshWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMeshWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongitudinalBarNominalDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongitudinalBarNominalDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransverseBarNominalDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransverseBarNominalDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongitudinalBarCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongitudinalBarCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransverseBarCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransverseBarCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongitudinalBarSpacing())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongitudinalBarSpacing());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransverseBarSpacing())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransverseBarSpacing());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAggregates(IfcRelAggregates *value) {
    m_out << "#" << value->getKey() << "=IFCRELAGGREGATES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingObject())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingObject());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssigns(IfcRelAssigns *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsTasks(IfcRelAssignsTasks *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTASKS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingControl())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingControl());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeForTask())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeForTask());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToActor(IfcRelAssignsToActor *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOACTOR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingActor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getActingRole())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getActingRole());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToControl(IfcRelAssignsToControl *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOCONTROL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingControl())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingControl());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToGroup(IfcRelAssignsToGroup *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOGROUP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingGroup());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToProcess(IfcRelAssignsToProcess *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOPROCESS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingProcess())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingProcess());
    }
    m_out << ",";
    if (Step::isUnset(value->getQuantityInProcess())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getQuantityInProcess());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToProduct(IfcRelAssignsToProduct *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOPRODUCT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingProduct())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingProduct());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToProjectOrder(IfcRelAssignsToProjectOrder *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTOPROJECTORDER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingControl())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingControl());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssignsToResource(IfcRelAssignsToResource *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSIGNSTORESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingResource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingResource());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociates(IfcRelAssociates *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociatesAppliedValue(IfcRelAssociatesAppliedValue *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESAPPLIEDVALUE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingAppliedValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingAppliedValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociatesApproval(IfcRelAssociatesApproval *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESAPPROVAL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingApproval())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingApproval());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociatesClassification(IfcRelAssociatesClassification *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESCLASSIFICATION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingClassification())) {
        m_out << "$";
    }
    else {
        writeIfcClassificationNotationSelect(value->getRelatingClassification());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociatesConstraint(IfcRelAssociatesConstraint *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESCONSTRAINT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getIntent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIntent());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingConstraint());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelAssociatesDocument(IfcRelAssociatesDocument *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESDOCUMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingDocument())) {
        m_out << "$";
    }
    else {
        writeIfcDocumentSelect(value->getRelatingDocument());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLibrarySelect(IfcLibrarySelect *selectData) {
    switch(selectData->currentType()) {
    case IfcLibrarySelect::IFCLIBRARYREFERENCE:
        writeAttribute(selectData->getIfcLibraryReference());
        break;
    case IfcLibrarySelect::IFCLIBRARYINFORMATION:
        writeAttribute(selectData->getIfcLibraryInformation());
        break;
        }
}

bool SPFWriter::visitIfcRelAssociatesLibrary(IfcRelAssociatesLibrary *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESLIBRARY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingLibrary())) {
        m_out << "$";
    }
    else {
        writeIfcLibrarySelect(value->getRelatingLibrary());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcMaterialSelect(IfcMaterialSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcMaterialSelect::IFCMATERIAL:
        writeAttribute(selectData->getIfcMaterial());
        break;
    case IfcMaterialSelect::IFCMATERIALLIST:
        writeAttribute(selectData->getIfcMaterialList());
        break;
    case IfcMaterialSelect::IFCMATERIALLAYERSETUSAGE:
        writeAttribute(selectData->getIfcMaterialLayerSetUsage());
        break;
    case IfcMaterialSelect::IFCMATERIALLAYERSET:
        writeAttribute(selectData->getIfcMaterialLayerSet());
        break;
    case IfcMaterialSelect::IFCMATERIALLAYER:
        writeAttribute(selectData->getIfcMaterialLayer());
        break;
        }
}

bool SPFWriter::visitIfcRelAssociatesMaterial(IfcRelAssociatesMaterial *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESMATERIAL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingMaterial())) {
        m_out << "$";
    }
    else {
        writeIfcMaterialSelect(value->getRelatingMaterial());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcOrientationSelect(IfcOrientationSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcOrientationSelect::IFCPLANEANGLEMEASURE:
        m_out << "IFCPLANEANGLEMEASURE(";
        writeAttribute(selectData->getIfcPlaneAngleMeasure());
        m_out << ")";
        break;
    case IfcOrientationSelect::IFCDIRECTION:
        writeAttribute(selectData->getIfcDirection());
        break;
        }
}

bool SPFWriter::visitIfcRelAssociatesProfileProperties(IfcRelAssociatesProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCRELASSOCIATESPROFILEPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRoot_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingProfileProperties())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingProfileProperties());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileSectionLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileSectionLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileOrientation())) {
        m_out << "$";
    }
    else {
        writeIfcOrientationSelect(value->getProfileOrientation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnects(IfcRelConnects *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsElements(IfcRelConnectsElements *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSELEMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionGeometry());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedElement());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcConnectionTypeEnum(IfcConnectionTypeEnum enumData) {
    switch(enumData) {
    case IfcConnectionTypeEnum_ATPATH:
        m_out << ".ATPATH.";
        break;
    case IfcConnectionTypeEnum_ATSTART:
        m_out << ".ATSTART.";
        break;
    case IfcConnectionTypeEnum_ATEND:
        m_out << ".ATEND.";
        break;
    case IfcConnectionTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRelConnectsPathElements(IfcRelConnectsPathElements *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSPATHELEMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionGeometry());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingPriorities())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_Integer_0_n::iterator step_it0 = (value->getRelatingPriorities()).begin();
            if ((value->getRelatingPriorities()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getRelatingPriorities()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedPriorities())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_Integer_0_n::iterator step_it0 = (value->getRelatedPriorities()).begin();
            if ((value->getRelatedPriorities()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getRelatedPriorities()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedConnectionType())) {
        m_out << "$";
    }
    else {
        writeIfcConnectionTypeEnum(value->getRelatedConnectionType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatingConnectionType())) {
        m_out << "$";
    }
    else {
        writeIfcConnectionTypeEnum(value->getRelatingConnectionType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsPortToElement(IfcRelConnectsPortToElement *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSPORTTOELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingPort())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingPort());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsPorts(IfcRelConnectsPorts *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSPORTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingPort())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingPort());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedPort())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedPort());
    }
    m_out << ",";
    if (Step::isUnset(value->getRealizingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRealizingElement());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStructuralActivityAssignmentSelect(IfcStructuralActivityAssignmentSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcStructuralActivityAssignmentSelect::IFCSTRUCTURALITEM:
        writeAttribute(selectData->getIfcStructuralItem());
        break;
    case IfcStructuralActivityAssignmentSelect::IFCELEMENT:
        writeAttribute(selectData->getIfcElement());
        break;
        }
}

bool SPFWriter::visitIfcRelConnectsStructuralActivity(IfcRelConnectsStructuralActivity *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSSTRUCTURALACTIVITY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeIfcStructuralActivityAssignmentSelect(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedStructuralActivity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedStructuralActivity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsStructuralElement(IfcRelConnectsStructuralElement *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSSTRUCTURALELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedStructuralMember())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedStructuralMember());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsStructuralMember(IfcRelConnectsStructuralMember *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSSTRUCTURALMEMBER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingStructuralMember())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingStructuralMember());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedStructuralConnection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedStructuralConnection());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ",";
    if (Step::isUnset(value->getAdditionalConditions())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAdditionalConditions());
    }
    m_out << ",";
    if (Step::isUnset(value->getSupportedLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSupportedLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getConditionCoordinateSystem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConditionCoordinateSystem());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsWithEccentricity(IfcRelConnectsWithEccentricity *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSWITHECCENTRICITY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingStructuralMember())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingStructuralMember());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedStructuralConnection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedStructuralConnection());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ",";
    if (Step::isUnset(value->getAdditionalConditions())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAdditionalConditions());
    }
    m_out << ",";
    if (Step::isUnset(value->getSupportedLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSupportedLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getConditionCoordinateSystem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConditionCoordinateSystem());
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionConstraint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionConstraint());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelConnectsWithRealizingElements(IfcRelConnectsWithRealizingElements *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONNECTSWITHREALIZINGELEMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionGeometry());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRealizingElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcElement_1_n::iterator step_it0 = (value->getRealizingElements()).begin();
            if ((value->getRealizingElements()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRealizingElements()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelContainedInSpatialStructure(IfcRelContainedInSpatialStructure *value) {
    m_out << "#" << value->getKey() << "=IFCRELCONTAINEDINSPATIALSTRUCTURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProduct_1_n::iterator step_it0 = (value->getRelatedElements()).begin();
            if ((value->getRelatedElements()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedElements()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingStructure())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingStructure());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelCoversBldgElements(IfcRelCoversBldgElements *value) {
    m_out << "#" << value->getKey() << "=IFCRELCOVERSBLDGELEMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingBuildingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingBuildingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedCoverings())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcCovering_1_n::iterator step_it0 = (value->getRelatedCoverings()).begin();
            if ((value->getRelatedCoverings()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedCoverings()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelCoversSpaces(IfcRelCoversSpaces *value) {
    m_out << "#" << value->getKey() << "=IFCRELCOVERSSPACES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedSpace())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedSpace());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedCoverings())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcCovering_1_n::iterator step_it0 = (value->getRelatedCoverings()).begin();
            if ((value->getRelatedCoverings()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedCoverings()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelDecomposes(IfcRelDecomposes *value) {
    m_out << "#" << value->getKey() << "=IFCRELDECOMPOSES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingObject())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingObject());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelDefines(IfcRelDefines *value) {
    m_out << "#" << value->getKey() << "=IFCRELDEFINES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObject_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelDefinesByProperties(IfcRelDefinesByProperties *value) {
    m_out << "#" << value->getKey() << "=IFCRELDEFINESBYPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObject_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingPropertyDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingPropertyDefinition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelDefinesByType(IfcRelDefinesByType *value) {
    m_out << "#" << value->getKey() << "=IFCRELDEFINESBYTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObject_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelFillsElement(IfcRelFillsElement *value) {
    m_out << "#" << value->getKey() << "=IFCRELFILLSELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingOpeningElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingOpeningElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedBuildingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedBuildingElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelFlowControlElements(IfcRelFlowControlElements *value) {
    m_out << "#" << value->getKey() << "=IFCRELFLOWCONTROLELEMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedControlElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDistributionControlElement_1_n::iterator step_it0 = (value->getRelatedControlElements()).begin();
            if ((value->getRelatedControlElements()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedControlElements()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingFlowElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingFlowElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelInteractionRequirements(IfcRelInteractionRequirements *value) {
    m_out << "#" << value->getKey() << "=IFCRELINTERACTIONREQUIREMENTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getDailyInteraction())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDailyInteraction());
    }
    m_out << ",";
    if (Step::isUnset(value->getImportanceRating())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getImportanceRating());
    }
    m_out << ",";
    if (Step::isUnset(value->getLocationOfInteraction())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLocationOfInteraction());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedSpaceProgram())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedSpaceProgram());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingSpaceProgram())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingSpaceProgram());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelNests(IfcRelNests *value) {
    m_out << "#" << value->getKey() << "=IFCRELNESTS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingObject())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingObject());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelOccupiesSpaces(IfcRelOccupiesSpaces *value) {
    m_out << "#" << value->getKey() << "=IFCRELOCCUPIESSPACES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingActor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingActor());
    }
    m_out << ",";
    if (Step::isUnset(value->getActingRole())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getActingRole());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelOverridesProperties(IfcRelOverridesProperties *value) {
    m_out << "#" << value->getKey() << "=IFCRELOVERRIDESPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObject_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingPropertyDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingPropertyDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverridingProperties())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProperty_1_n::iterator step_it0 = (value->getOverridingProperties()).begin();
            if ((value->getOverridingProperties()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getOverridingProperties()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelProjectsElement(IfcRelProjectsElement *value) {
    m_out << "#" << value->getKey() << "=IFCRELPROJECTSELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedFeatureElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedFeatureElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelReferencedInSpatialStructure(IfcRelReferencedInSpatialStructure *value) {
    m_out << "#" << value->getKey() << "=IFCRELREFERENCEDINSPATIALSTRUCTURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedElements())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcProduct_1_n::iterator step_it0 = (value->getRelatedElements()).begin();
            if ((value->getRelatedElements()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedElements()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingStructure())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingStructure());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelSchedulesCostItems(IfcRelSchedulesCostItems *value) {
    m_out << "#" << value->getKey() << "=IFCRELSCHEDULESCOSTITEMS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedObjects())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcObjectDefinition_1_n::iterator step_it0 = (value->getRelatedObjects()).begin();
            if ((value->getRelatedObjects()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedObjects()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getRelatedObjectsType())) {
        m_out << "$";
    }
    else {
        writeIfcObjectTypeEnum(value->getRelatedObjectsType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingControl())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingControl());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSequenceEnum(IfcSequenceEnum enumData) {
    switch(enumData) {
    case IfcSequenceEnum_START_START:
        m_out << ".START_START.";
        break;
    case IfcSequenceEnum_START_FINISH:
        m_out << ".START_FINISH.";
        break;
    case IfcSequenceEnum_FINISH_START:
        m_out << ".FINISH_START.";
        break;
    case IfcSequenceEnum_FINISH_FINISH:
        m_out << ".FINISH_FINISH.";
        break;
    case IfcSequenceEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRelSequence(IfcRelSequence *value) {
    m_out << "#" << value->getKey() << "=IFCRELSEQUENCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingProcess())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingProcess());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedProcess())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedProcess());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeLag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeLag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getSequenceType())) {
        m_out << "$";
    }
    else {
        writeIfcSequenceEnum(value->getSequenceType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelServicesBuildings(IfcRelServicesBuildings *value) {
    m_out << "#" << value->getKey() << "=IFCRELSERVICESBUILDINGS(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingSystem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingSystem());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedBuildings())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcSpatialStructureElement_1_n::iterator step_it0 = (value->getRelatedBuildings()).begin();
            if ((value->getRelatedBuildings()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRelatedBuildings()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcPhysicalOrVirtualEnum(IfcPhysicalOrVirtualEnum enumData) {
    switch(enumData) {
    case IfcPhysicalOrVirtualEnum_PHYSICAL:
        m_out << ".PHYSICAL.";
        break;
    case IfcPhysicalOrVirtualEnum_VIRTUAL:
        m_out << ".VIRTUAL.";
        break;
    case IfcPhysicalOrVirtualEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcInternalOrExternalEnum(IfcInternalOrExternalEnum enumData) {
    switch(enumData) {
    case IfcInternalOrExternalEnum_INTERNAL:
        m_out << ".INTERNAL.";
        break;
    case IfcInternalOrExternalEnum_EXTERNAL:
        m_out << ".EXTERNAL.";
        break;
    case IfcInternalOrExternalEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRelSpaceBoundary(IfcRelSpaceBoundary *value) {
    m_out << "#" << value->getKey() << "=IFCRELSPACEBOUNDARY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingSpace())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingSpace());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedBuildingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedBuildingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getConnectionGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getConnectionGeometry());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPhysicalOrVirtualBoundary())) {
        m_out << "$";
    }
    else {
        writeIfcPhysicalOrVirtualEnum(value->getPhysicalOrVirtualBoundary());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getInternalOrExternalBoundary())) {
        m_out << "$";
    }
    else {
        writeIfcInternalOrExternalEnum(value->getInternalOrExternalBoundary());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelVoidsElement(IfcRelVoidsElement *value) {
    m_out << "#" << value->getKey() << "=IFCRELVOIDSELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatingBuildingElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatingBuildingElement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRelatedOpeningElement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelatedOpeningElement());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelationship(IfcRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCRELATIONSHIP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRelaxation(IfcRelaxation *value) {
    m_out << "#" << value->getKey() << "=IFCRELAXATION(";
    if (Step::isUnset(value->getRelaxationValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRelaxationValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getInitialStress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInitialStress());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRepresentation(IfcRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCREPRESENTATION(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRepresentationContext(IfcRepresentationContext *value) {
    m_out << "#" << value->getKey() << "=IFCREPRESENTATIONCONTEXT(";
    if (Step::isUnset(value->getContextIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getContextType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRepresentationItem(IfcRepresentationItem *value) {
    m_out << "#" << value->getKey() << "=IFCREPRESENTATIONITEM(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRepresentationMap(IfcRepresentationMap *value) {
    m_out << "#" << value->getKey() << "=IFCREPRESENTATIONMAP(";
    if (Step::isUnset(value->getMappingOrigin())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getMappingOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getMappedRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMappedRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcResource(IfcResource *value) {
    m_out << "#" << value->getKey() << "=IFCRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRevolvedAreaSolid(IfcRevolvedAreaSolid *value) {
    m_out << "#" << value->getKey() << "=IFCREVOLVEDAREASOLID(";
    if (Step::isUnset(value->getSweptArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxis())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxis());
    }
    m_out << ",";
    if (Step::isUnset(value->getAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAngle());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRibPlateDirectionEnum(IfcRibPlateDirectionEnum enumData) {
    switch(enumData) {
    case IfcRibPlateDirectionEnum_DIRECTION_X:
        m_out << ".DIRECTION_X.";
        break;
    case IfcRibPlateDirectionEnum_DIRECTION_Y:
        m_out << ".DIRECTION_Y.";
        break;
        }
}

bool SPFWriter::visitIfcRibPlateProfileProperties(IfcRibPlateProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCRIBPLATEPROFILEPROPERTIES(";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getRibHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRibHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getRibWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRibWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getRibSpacing())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRibSpacing());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDirection())) {
        m_out << "$";
    }
    else {
        writeIfcRibPlateDirectionEnum(value->getDirection());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRightCircularCone(IfcRightCircularCone *value) {
    m_out << "#" << value->getKey() << "=IFCRIGHTCIRCULARCONE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getBottomRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBottomRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRightCircularCylinder(IfcRightCircularCylinder *value) {
    m_out << "#" << value->getKey() << "=IFCRIGHTCIRCULARCYLINDER(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcRoofTypeEnum(IfcRoofTypeEnum enumData) {
    switch(enumData) {
    case IfcRoofTypeEnum_FLAT_ROOF:
        m_out << ".FLAT_ROOF.";
        break;
    case IfcRoofTypeEnum_SHED_ROOF:
        m_out << ".SHED_ROOF.";
        break;
    case IfcRoofTypeEnum_GABLE_ROOF:
        m_out << ".GABLE_ROOF.";
        break;
    case IfcRoofTypeEnum_HIP_ROOF:
        m_out << ".HIP_ROOF.";
        break;
    case IfcRoofTypeEnum_HIPPED_GABLE_ROOF:
        m_out << ".HIPPED_GABLE_ROOF.";
        break;
    case IfcRoofTypeEnum_GAMBREL_ROOF:
        m_out << ".GAMBREL_ROOF.";
        break;
    case IfcRoofTypeEnum_MANSARD_ROOF:
        m_out << ".MANSARD_ROOF.";
        break;
    case IfcRoofTypeEnum_BARREL_ROOF:
        m_out << ".BARREL_ROOF.";
        break;
    case IfcRoofTypeEnum_RAINBOW_ROOF:
        m_out << ".RAINBOW_ROOF.";
        break;
    case IfcRoofTypeEnum_BUTTERFLY_ROOF:
        m_out << ".BUTTERFLY_ROOF.";
        break;
    case IfcRoofTypeEnum_PAVILION_ROOF:
        m_out << ".PAVILION_ROOF.";
        break;
    case IfcRoofTypeEnum_DOME_ROOF:
        m_out << ".DOME_ROOF.";
        break;
    case IfcRoofTypeEnum_FREEFORM:
        m_out << ".FREEFORM.";
        break;
    case IfcRoofTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcRoof(IfcRoof *value) {
    m_out << "#" << value->getKey() << "=IFCROOF(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getShapeType())) {
        m_out << "$";
    }
    else {
        writeIfcRoofTypeEnum(value->getShapeType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRoot(IfcRoot *value) {
    m_out << "#" << value->getKey() << "=IFCROOT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRoundedEdgeFeature(IfcRoundedEdgeFeature *value) {
    m_out << "#" << value->getKey() << "=IFCROUNDEDEDGEFEATURE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getFeatureLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFeatureLength());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcRoundedRectangleProfileDef(IfcRoundedRectangleProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCROUNDEDRECTANGLEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getYDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getRoundingRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRoundingRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSIPrefix(IfcSIPrefix enumData) {
    switch(enumData) {
    case IfcSIPrefix_EXA:
        m_out << ".EXA.";
        break;
    case IfcSIPrefix_PETA:
        m_out << ".PETA.";
        break;
    case IfcSIPrefix_TERA:
        m_out << ".TERA.";
        break;
    case IfcSIPrefix_GIGA:
        m_out << ".GIGA.";
        break;
    case IfcSIPrefix_MEGA:
        m_out << ".MEGA.";
        break;
    case IfcSIPrefix_KILO:
        m_out << ".KILO.";
        break;
    case IfcSIPrefix_HECTO:
        m_out << ".HECTO.";
        break;
    case IfcSIPrefix_DECA:
        m_out << ".DECA.";
        break;
    case IfcSIPrefix_DECI:
        m_out << ".DECI.";
        break;
    case IfcSIPrefix_CENTI:
        m_out << ".CENTI.";
        break;
    case IfcSIPrefix_MILLI:
        m_out << ".MILLI.";
        break;
    case IfcSIPrefix_MICRO:
        m_out << ".MICRO.";
        break;
    case IfcSIPrefix_NANO:
        m_out << ".NANO.";
        break;
    case IfcSIPrefix_PICO:
        m_out << ".PICO.";
        break;
    case IfcSIPrefix_FEMTO:
        m_out << ".FEMTO.";
        break;
    case IfcSIPrefix_ATTO:
        m_out << ".ATTO.";
        break;
        }
}

void SPFWriter::writeIfcSIUnitName(IfcSIUnitName enumData) {
    switch(enumData) {
    case IfcSIUnitName_AMPERE:
        m_out << ".AMPERE.";
        break;
    case IfcSIUnitName_BECQUEREL:
        m_out << ".BECQUEREL.";
        break;
    case IfcSIUnitName_CANDELA:
        m_out << ".CANDELA.";
        break;
    case IfcSIUnitName_COULOMB:
        m_out << ".COULOMB.";
        break;
    case IfcSIUnitName_CUBIC_METRE:
        m_out << ".CUBIC_METRE.";
        break;
    case IfcSIUnitName_DEGREE_CELSIUS:
        m_out << ".DEGREE_CELSIUS.";
        break;
    case IfcSIUnitName_FARAD:
        m_out << ".FARAD.";
        break;
    case IfcSIUnitName_GRAM:
        m_out << ".GRAM.";
        break;
    case IfcSIUnitName_GRAY:
        m_out << ".GRAY.";
        break;
    case IfcSIUnitName_HENRY:
        m_out << ".HENRY.";
        break;
    case IfcSIUnitName_HERTZ:
        m_out << ".HERTZ.";
        break;
    case IfcSIUnitName_JOULE:
        m_out << ".JOULE.";
        break;
    case IfcSIUnitName_KELVIN:
        m_out << ".KELVIN.";
        break;
    case IfcSIUnitName_LUMEN:
        m_out << ".LUMEN.";
        break;
    case IfcSIUnitName_LUX:
        m_out << ".LUX.";
        break;
    case IfcSIUnitName_METRE:
        m_out << ".METRE.";
        break;
    case IfcSIUnitName_MOLE:
        m_out << ".MOLE.";
        break;
    case IfcSIUnitName_NEWTON:
        m_out << ".NEWTON.";
        break;
    case IfcSIUnitName_OHM:
        m_out << ".OHM.";
        break;
    case IfcSIUnitName_PASCAL:
        m_out << ".PASCAL.";
        break;
    case IfcSIUnitName_RADIAN:
        m_out << ".RADIAN.";
        break;
    case IfcSIUnitName_SECOND:
        m_out << ".SECOND.";
        break;
    case IfcSIUnitName_SIEMENS:
        m_out << ".SIEMENS.";
        break;
    case IfcSIUnitName_SIEVERT:
        m_out << ".SIEVERT.";
        break;
    case IfcSIUnitName_SQUARE_METRE:
        m_out << ".SQUARE_METRE.";
        break;
    case IfcSIUnitName_STERADIAN:
        m_out << ".STERADIAN.";
        break;
    case IfcSIUnitName_TESLA:
        m_out << ".TESLA.";
        break;
    case IfcSIUnitName_VOLT:
        m_out << ".VOLT.";
        break;
    case IfcSIUnitName_WATT:
        m_out << ".WATT.";
        break;
    case IfcSIUnitName_WEBER:
        m_out << ".WEBER.";
        break;
        }
}

bool SPFWriter::visitIfcSIUnit(IfcSIUnit *value) {
    m_out << "#" << value->getKey() << "=IFCSIUNIT(";
    m_out << "*";
    m_out << ",";
    if (Step::isUnsetEnum(value->getUnitType())) {
        m_out << "$";
    }
    else {
        writeIfcUnitEnum(value->getUnitType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPrefix())) {
        m_out << "$";
    }
    else {
        writeIfcSIPrefix(value->getPrefix());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getName())) {
        m_out << "$";
    }
    else {
        writeIfcSIUnitName(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSanitaryTerminalTypeEnum(IfcSanitaryTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcSanitaryTerminalTypeEnum_BATH:
        m_out << ".BATH.";
        break;
    case IfcSanitaryTerminalTypeEnum_BIDET:
        m_out << ".BIDET.";
        break;
    case IfcSanitaryTerminalTypeEnum_CISTERN:
        m_out << ".CISTERN.";
        break;
    case IfcSanitaryTerminalTypeEnum_SHOWER:
        m_out << ".SHOWER.";
        break;
    case IfcSanitaryTerminalTypeEnum_SINK:
        m_out << ".SINK.";
        break;
    case IfcSanitaryTerminalTypeEnum_SANITARYFOUNTAIN:
        m_out << ".SANITARYFOUNTAIN.";
        break;
    case IfcSanitaryTerminalTypeEnum_TOILETPAN:
        m_out << ".TOILETPAN.";
        break;
    case IfcSanitaryTerminalTypeEnum_URINAL:
        m_out << ".URINAL.";
        break;
    case IfcSanitaryTerminalTypeEnum_WASHHANDBASIN:
        m_out << ".WASHHANDBASIN.";
        break;
    case IfcSanitaryTerminalTypeEnum_WCSEAT:
        m_out << ".WCSEAT.";
        break;
    case IfcSanitaryTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSanitaryTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSanitaryTerminalType(IfcSanitaryTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCSANITARYTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSanitaryTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcScheduleTimeControl(IfcScheduleTimeControl *value) {
    m_out << "#" << value->getKey() << "=IFCSCHEDULETIMECONTROL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getActualStart())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getActualStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getEarlyStart())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getEarlyStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getLateStart())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getLateStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getScheduleStart())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getScheduleStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getActualFinish())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getActualFinish());
    }
    m_out << ",";
    if (Step::isUnset(value->getEarlyFinish())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getEarlyFinish());
    }
    m_out << ",";
    if (Step::isUnset(value->getLateFinish())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getLateFinish());
    }
    m_out << ",";
    if (Step::isUnset(value->getScheduleFinish())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getScheduleFinish());
    }
    m_out << ",";
    if (Step::isUnset(value->getScheduleDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getScheduleDuration());
    }
    m_out << ",";
    if (Step::isUnset(value->getActualDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getActualDuration());
    }
    m_out << ",";
    if (Step::isUnset(value->getRemainingTime())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRemainingTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getFreeFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFreeFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getTotalFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsCritical())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsCritical());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatusTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStatusTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStartFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getFinishFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFinishFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getCompletion())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCompletion());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSectionTypeEnum(IfcSectionTypeEnum enumData) {
    switch(enumData) {
    case IfcSectionTypeEnum_UNIFORM:
        m_out << ".UNIFORM.";
        break;
    case IfcSectionTypeEnum_TAPERED:
        m_out << ".TAPERED.";
        break;
        }
}

bool SPFWriter::visitIfcSectionProperties(IfcSectionProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSECTIONPROPERTIES(";
    if (Step::isUnsetEnum(value->getSectionType())) {
        m_out << "$";
    }
    else {
        writeIfcSectionTypeEnum(value->getSectionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartProfile())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStartProfile());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndProfile())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEndProfile());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSectionReinforcementProperties(IfcSectionReinforcementProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSECTIONREINFORCEMENTPROPERTIES(";
    if (Step::isUnset(value->getLongitudinalStartPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongitudinalStartPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongitudinalEndPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongitudinalEndPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransversePosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransversePosition());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getReinforcementRole())) {
        m_out << "$";
    }
    else {
        writeIfcReinforcingBarRoleEnum(value->getReinforcementRole());
    }
    m_out << ",";
    if (Step::isUnset(value->getSectionDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSectionDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionReinforcementDefinitions())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcReinforcementBarProperties_1_n::iterator step_it0 = (value->getCrossSectionReinforcementDefinitions()).begin();
            if ((value->getCrossSectionReinforcementDefinitions()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCrossSectionReinforcementDefinitions()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSectionedSpine(IfcSectionedSpine *value) {
    m_out << "#" << value->getKey() << "=IFCSECTIONEDSPINE(";
    if (Step::isUnset(value->getSpineCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSpineCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSections())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcProfileDef_2_n::iterator step_it0 = (value->getCrossSections()).begin();
            if ((value->getCrossSections()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCrossSections()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionPositions())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcAxis2Placement3D_2_n::iterator step_it0 = (value->getCrossSectionPositions()).begin();
            if ((value->getCrossSectionPositions()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCrossSectionPositions()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSensorTypeEnum(IfcSensorTypeEnum enumData) {
    switch(enumData) {
    case IfcSensorTypeEnum_CO2SENSOR:
        m_out << ".CO2SENSOR.";
        break;
    case IfcSensorTypeEnum_FIRESENSOR:
        m_out << ".FIRESENSOR.";
        break;
    case IfcSensorTypeEnum_FLOWSENSOR:
        m_out << ".FLOWSENSOR.";
        break;
    case IfcSensorTypeEnum_GASSENSOR:
        m_out << ".GASSENSOR.";
        break;
    case IfcSensorTypeEnum_HEATSENSOR:
        m_out << ".HEATSENSOR.";
        break;
    case IfcSensorTypeEnum_HUMIDITYSENSOR:
        m_out << ".HUMIDITYSENSOR.";
        break;
    case IfcSensorTypeEnum_LIGHTSENSOR:
        m_out << ".LIGHTSENSOR.";
        break;
    case IfcSensorTypeEnum_MOISTURESENSOR:
        m_out << ".MOISTURESENSOR.";
        break;
    case IfcSensorTypeEnum_MOVEMENTSENSOR:
        m_out << ".MOVEMENTSENSOR.";
        break;
    case IfcSensorTypeEnum_PRESSURESENSOR:
        m_out << ".PRESSURESENSOR.";
        break;
    case IfcSensorTypeEnum_SMOKESENSOR:
        m_out << ".SMOKESENSOR.";
        break;
    case IfcSensorTypeEnum_SOUNDSENSOR:
        m_out << ".SOUNDSENSOR.";
        break;
    case IfcSensorTypeEnum_TEMPERATURESENSOR:
        m_out << ".TEMPERATURESENSOR.";
        break;
    case IfcSensorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSensorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSensorType(IfcSensorType *value) {
    m_out << "#" << value->getKey() << "=IFCSENSORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSensorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcServiceLifeTypeEnum(IfcServiceLifeTypeEnum enumData) {
    switch(enumData) {
    case IfcServiceLifeTypeEnum_ACTUALSERVICELIFE:
        m_out << ".ACTUALSERVICELIFE.";
        break;
    case IfcServiceLifeTypeEnum_EXPECTEDSERVICELIFE:
        m_out << ".EXPECTEDSERVICELIFE.";
        break;
    case IfcServiceLifeTypeEnum_OPTIMISTICREFERENCESERVICELIFE:
        m_out << ".OPTIMISTICREFERENCESERVICELIFE.";
        break;
    case IfcServiceLifeTypeEnum_PESSIMISTICREFERENCESERVICELIFE:
        m_out << ".PESSIMISTICREFERENCESERVICELIFE.";
        break;
    case IfcServiceLifeTypeEnum_REFERENCESERVICELIFE:
        m_out << ".REFERENCESERVICELIFE.";
        break;
        }
}

bool SPFWriter::visitIfcServiceLife(IfcServiceLife *value) {
    m_out << "#" << value->getKey() << "=IFCSERVICELIFE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getServiceLifeType())) {
        m_out << "$";
    }
    else {
        writeIfcServiceLifeTypeEnum(value->getServiceLifeType());
    }
    m_out << ",";
    if (Step::isUnset(value->getServiceLifeDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getServiceLifeDuration());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcServiceLifeFactorTypeEnum(IfcServiceLifeFactorTypeEnum enumData) {
    switch(enumData) {
    case IfcServiceLifeFactorTypeEnum_A_QUALITYOFCOMPONENTS:
        m_out << ".A_QUALITYOFCOMPONENTS.";
        break;
    case IfcServiceLifeFactorTypeEnum_B_DESIGNLEVEL:
        m_out << ".B_DESIGNLEVEL.";
        break;
    case IfcServiceLifeFactorTypeEnum_C_WORKEXECUTIONLEVEL:
        m_out << ".C_WORKEXECUTIONLEVEL.";
        break;
    case IfcServiceLifeFactorTypeEnum_D_INDOORENVIRONMENT:
        m_out << ".D_INDOORENVIRONMENT.";
        break;
    case IfcServiceLifeFactorTypeEnum_E_OUTDOORENVIRONMENT:
        m_out << ".E_OUTDOORENVIRONMENT.";
        break;
    case IfcServiceLifeFactorTypeEnum_F_INUSECONDITIONS:
        m_out << ".F_INUSECONDITIONS.";
        break;
    case IfcServiceLifeFactorTypeEnum_G_MAINTENANCELEVEL:
        m_out << ".G_MAINTENANCELEVEL.";
        break;
    case IfcServiceLifeFactorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcServiceLifeFactorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcMeasureValue(IfcMeasureValue *selectData) {
    switch(selectData->currentType()) {
    case IfcMeasureValue::IFCVOLUMEMEASURE:
        m_out << "IFCVOLUMEMEASURE(";
        writeAttribute(selectData->getIfcVolumeMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCTIMEMEASURE:
        m_out << "IFCTIMEMEASURE(";
        writeAttribute(selectData->getIfcTimeMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCTHERMODYNAMICTEMPERATUREMEASURE:
        m_out << "IFCTHERMODYNAMICTEMPERATUREMEASURE(";
        writeAttribute(selectData->getIfcThermodynamicTemperatureMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCSOLIDANGLEMEASURE:
        m_out << "IFCSOLIDANGLEMEASURE(";
        writeAttribute(selectData->getIfcSolidAngleMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCPOSITIVERATIOMEASURE:
        m_out << "IFCPOSITIVERATIOMEASURE(";
        writeAttribute(selectData->getIfcPositiveRatioMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCRATIOMEASURE:
        m_out << "IFCRATIOMEASURE(";
        writeAttribute(selectData->getIfcRatioMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCPOSITIVEPLANEANGLEMEASURE:
        m_out << "IFCPOSITIVEPLANEANGLEMEASURE(";
        writeAttribute(selectData->getIfcPositivePlaneAngleMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCPLANEANGLEMEASURE:
        m_out << "IFCPLANEANGLEMEASURE(";
        writeAttribute(selectData->getIfcPlaneAngleMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCPARAMETERVALUE:
        m_out << "IFCPARAMETERVALUE(";
        writeAttribute(selectData->getIfcParameterValue());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCNUMERICMEASURE:
        m_out << "IFCNUMERICMEASURE(";
        writeAttribute(selectData->getIfcNumericMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCMASSMEASURE:
        m_out << "IFCMASSMEASURE(";
        writeAttribute(selectData->getIfcMassMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCPOSITIVELENGTHMEASURE:
        m_out << "IFCPOSITIVELENGTHMEASURE(";
        writeAttribute(selectData->getIfcPositiveLengthMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCLENGTHMEASURE:
        m_out << "IFCLENGTHMEASURE(";
        writeAttribute(selectData->getIfcLengthMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCELECTRICCURRENTMEASURE:
        m_out << "IFCELECTRICCURRENTMEASURE(";
        writeAttribute(selectData->getIfcElectricCurrentMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCDESCRIPTIVEMEASURE:
        m_out << "IFCDESCRIPTIVEMEASURE(";
        writeAttribute(selectData->getIfcDescriptiveMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCCOUNTMEASURE:
        m_out << "IFCCOUNTMEASURE(";
        writeAttribute(selectData->getIfcCountMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCCONTEXTDEPENDENTMEASURE:
        m_out << "IFCCONTEXTDEPENDENTMEASURE(";
        writeAttribute(selectData->getIfcContextDependentMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCAREAMEASURE:
        m_out << "IFCAREAMEASURE(";
        writeAttribute(selectData->getIfcAreaMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCAMOUNTOFSUBSTANCEMEASURE:
        m_out << "IFCAMOUNTOFSUBSTANCEMEASURE(";
        writeAttribute(selectData->getIfcAmountOfSubstanceMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCLUMINOUSINTENSITYMEASURE:
        m_out << "IFCLUMINOUSINTENSITYMEASURE(";
        writeAttribute(selectData->getIfcLuminousIntensityMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCNORMALISEDRATIOMEASURE:
        m_out << "IFCNORMALISEDRATIOMEASURE(";
        writeAttribute(selectData->getIfcNormalisedRatioMeasure());
        m_out << ")";
        break;
    case IfcMeasureValue::IFCCOMPLEXNUMBER:
        m_out << "IFCCOMPLEXNUMBER(";
        m_out << "(";
        {
            IfcComplexNumber::iterator step_it0 = (selectData->getIfcComplexNumber()).begin();
            if ((selectData->getIfcComplexNumber()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (selectData->getIfcComplexNumber()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
        m_out << ")";
        break;
        }
}

bool SPFWriter::visitIfcServiceLifeFactor(IfcServiceLifeFactor *value) {
    m_out << "#" << value->getKey() << "=IFCSERVICELIFEFACTOR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcServiceLifeFactorTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUpperValue())) {
        m_out << "$";
    }
    else {
        writeIfcMeasureValue(value->getUpperValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getMostUsedValue())) {
        m_out << "$";
    }
    else {
        writeIfcMeasureValue(value->getMostUsedValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getLowerValue())) {
        m_out << "$";
    }
    else {
        writeIfcMeasureValue(value->getLowerValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcShapeAspect(IfcShapeAspect *value) {
    m_out << "#" << value->getKey() << "=IFCSHAPEASPECT(";
    if (Step::isUnset(value->getShapeRepresentations())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcShapeModel_1_n::iterator step_it0 = (value->getShapeRepresentations()).begin();
            if ((value->getShapeRepresentations()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getShapeRepresentations()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getProductDefinitional())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProductDefinitional());
    }
    m_out << ",";
    if (Step::isUnset(value->getPartOfProductDefinitionShape())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPartOfProductDefinitionShape());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcShapeModel(IfcShapeModel *value) {
    m_out << "#" << value->getKey() << "=IFCSHAPEMODEL(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcShapeRepresentation(IfcShapeRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCSHAPEREPRESENTATION(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcShell(IfcShell *selectData) {
    switch(selectData->currentType()) {
    case IfcShell::IFCCLOSEDSHELL:
        writeAttribute(selectData->getIfcClosedShell());
        break;
    case IfcShell::IFCOPENSHELL:
        writeAttribute(selectData->getIfcOpenShell());
        break;
        }
}

bool SPFWriter::visitIfcShellBasedSurfaceModel(IfcShellBasedSurfaceModel *value) {
    m_out << "#" << value->getKey() << "=IFCSHELLBASEDSURFACEMODEL(";
    if (Step::isUnset(value->getSbsmBoundary())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcShell_1_n::iterator step_it0 = (value->getSbsmBoundary()).begin();
            if ((value->getSbsmBoundary()).size()) {
                writeIfcShell((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSbsmBoundary()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcShell((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSimpleProperty(IfcSimpleProperty *value) {
    m_out << "#" << value->getKey() << "=IFCSIMPLEPROPERTY(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSite(IfcSite *value) {
    m_out << "#" << value->getKey() << "=IFCSITE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ",";
    if (Step::isUnset(value->getRefLatitude())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            IfcCompoundPlaneAngleMeasure::iterator step_it0 = (value->getRefLatitude()).begin();
            if ((value->getRefLatitude()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getRefLatitude()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRefLongitude())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            IfcCompoundPlaneAngleMeasure::iterator step_it0 = (value->getRefLongitude()).begin();
            if ((value->getRefLongitude()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getRefLongitude()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRefElevation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRefElevation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLandTitleNumber())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLandTitleNumber());
    }
    m_out << ",";
    if (Step::isUnset(value->getSiteAddress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSiteAddress());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSlabTypeEnum(IfcSlabTypeEnum enumData) {
    switch(enumData) {
    case IfcSlabTypeEnum_FLOOR:
        m_out << ".FLOOR.";
        break;
    case IfcSlabTypeEnum_ROOF:
        m_out << ".ROOF.";
        break;
    case IfcSlabTypeEnum_LANDING:
        m_out << ".LANDING.";
        break;
    case IfcSlabTypeEnum_BASESLAB:
        m_out << ".BASESLAB.";
        break;
    case IfcSlabTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSlabTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSlab(IfcSlab *value) {
    m_out << "#" << value->getKey() << "=IFCSLAB(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSlabTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSlabType(IfcSlabType *value) {
    m_out << "#" << value->getKey() << "=IFCSLABTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSlabTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSlippageConnectionCondition(IfcSlippageConnectionCondition *value) {
    m_out << "#" << value->getKey() << "=IFCSLIPPAGECONNECTIONCONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getSlippageX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSlippageX());
    }
    m_out << ",";
    if (Step::isUnset(value->getSlippageY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSlippageY());
    }
    m_out << ",";
    if (Step::isUnset(value->getSlippageZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSlippageZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSolidModel(IfcSolidModel *value) {
    m_out << "#" << value->getKey() << "=IFCSOLIDMODEL(";
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSoundScaleEnum(IfcSoundScaleEnum enumData) {
    switch(enumData) {
    case IfcSoundScaleEnum_DBA:
        m_out << ".DBA.";
        break;
    case IfcSoundScaleEnum_DBB:
        m_out << ".DBB.";
        break;
    case IfcSoundScaleEnum_DBC:
        m_out << ".DBC.";
        break;
    case IfcSoundScaleEnum_NC:
        m_out << ".NC.";
        break;
    case IfcSoundScaleEnum_NR:
        m_out << ".NR.";
        break;
    case IfcSoundScaleEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSoundScaleEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSoundProperties(IfcSoundProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSOUNDPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsAttenuating())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsAttenuating());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getSoundScale())) {
        m_out << "$";
    }
    else {
        writeIfcSoundScaleEnum(value->getSoundScale());
    }
    m_out << ",";
    if (Step::isUnset(value->getSoundValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcSoundValue_1_8::iterator step_it0 = (value->getSoundValues()).begin();
            if ((value->getSoundValues()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSoundValues()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSoundValue(IfcSoundValue *value) {
    m_out << "#" << value->getKey() << "=IFCSOUNDVALUE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getSoundLevelTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSoundLevelTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrequency())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrequency());
    }
    m_out << ",";
    if (Step::isUnset(value->getSoundLevelSingleValue())) {
        m_out << "$";
    }
    else {
        writeIfcDerivedMeasureValue(value->getSoundLevelSingleValue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSpace(IfcSpace *value) {
    m_out << "#" << value->getKey() << "=IFCSPACE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getInteriorOrExteriorSpace())) {
        m_out << "$";
    }
    else {
        writeIfcInternalOrExternalEnum(value->getInteriorOrExteriorSpace());
    }
    m_out << ",";
    if (Step::isUnset(value->getElevationWithFlooring())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElevationWithFlooring());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSpaceHeaterTypeEnum(IfcSpaceHeaterTypeEnum enumData) {
    switch(enumData) {
    case IfcSpaceHeaterTypeEnum_SECTIONALRADIATOR:
        m_out << ".SECTIONALRADIATOR.";
        break;
    case IfcSpaceHeaterTypeEnum_PANELRADIATOR:
        m_out << ".PANELRADIATOR.";
        break;
    case IfcSpaceHeaterTypeEnum_TUBULARRADIATOR:
        m_out << ".TUBULARRADIATOR.";
        break;
    case IfcSpaceHeaterTypeEnum_CONVECTOR:
        m_out << ".CONVECTOR.";
        break;
    case IfcSpaceHeaterTypeEnum_BASEBOARDHEATER:
        m_out << ".BASEBOARDHEATER.";
        break;
    case IfcSpaceHeaterTypeEnum_FINNEDTUBEUNIT:
        m_out << ".FINNEDTUBEUNIT.";
        break;
    case IfcSpaceHeaterTypeEnum_UNITHEATER:
        m_out << ".UNITHEATER.";
        break;
    case IfcSpaceHeaterTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSpaceHeaterTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSpaceHeaterType(IfcSpaceHeaterType *value) {
    m_out << "#" << value->getKey() << "=IFCSPACEHEATERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSpaceHeaterTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSpaceProgram(IfcSpaceProgram *value) {
    m_out << "#" << value->getKey() << "=IFCSPACEPROGRAM(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpaceProgramIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSpaceProgramIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaxRequiredArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaxRequiredArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinRequiredArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinRequiredArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getRequestedLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRequestedLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getStandardRequiredArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStandardRequiredArea());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcThermalLoadSourceEnum(IfcThermalLoadSourceEnum enumData) {
    switch(enumData) {
    case IfcThermalLoadSourceEnum_PEOPLE:
        m_out << ".PEOPLE.";
        break;
    case IfcThermalLoadSourceEnum_LIGHTING:
        m_out << ".LIGHTING.";
        break;
    case IfcThermalLoadSourceEnum_EQUIPMENT:
        m_out << ".EQUIPMENT.";
        break;
    case IfcThermalLoadSourceEnum_VENTILATIONINDOORAIR:
        m_out << ".VENTILATIONINDOORAIR.";
        break;
    case IfcThermalLoadSourceEnum_VENTILATIONOUTSIDEAIR:
        m_out << ".VENTILATIONOUTSIDEAIR.";
        break;
    case IfcThermalLoadSourceEnum_RECIRCULATEDAIR:
        m_out << ".RECIRCULATEDAIR.";
        break;
    case IfcThermalLoadSourceEnum_EXHAUSTAIR:
        m_out << ".EXHAUSTAIR.";
        break;
    case IfcThermalLoadSourceEnum_AIREXCHANGERATE:
        m_out << ".AIREXCHANGERATE.";
        break;
    case IfcThermalLoadSourceEnum_DRYBULBTEMPERATURE:
        m_out << ".DRYBULBTEMPERATURE.";
        break;
    case IfcThermalLoadSourceEnum_RELATIVEHUMIDITY:
        m_out << ".RELATIVEHUMIDITY.";
        break;
    case IfcThermalLoadSourceEnum_INFILTRATION:
        m_out << ".INFILTRATION.";
        break;
    case IfcThermalLoadSourceEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcThermalLoadSourceEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcThermalLoadTypeEnum(IfcThermalLoadTypeEnum enumData) {
    switch(enumData) {
    case IfcThermalLoadTypeEnum_SENSIBLE:
        m_out << ".SENSIBLE.";
        break;
    case IfcThermalLoadTypeEnum_LATENT:
        m_out << ".LATENT.";
        break;
    case IfcThermalLoadTypeEnum_RADIANT:
        m_out << ".RADIANT.";
        break;
    case IfcThermalLoadTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSpaceThermalLoadProperties(IfcSpaceThermalLoadProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSPACETHERMALLOADPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableValueRatio())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableValueRatio());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getThermalLoadSource())) {
        m_out << "$";
    }
    else {
        writeIfcThermalLoadSourceEnum(value->getThermalLoadSource());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPropertySource())) {
        m_out << "$";
    }
    else {
        writeIfcPropertySourceEnum(value->getPropertySource());
    }
    m_out << ",";
    if (Step::isUnset(value->getSourceDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSourceDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumValue())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumValue());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalLoadTimeSeriesValues())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalLoadTimeSeriesValues());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedThermalLoadSource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedThermalLoadSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedPropertySource())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedPropertySource());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getThermalLoadType())) {
        m_out << "$";
    }
    else {
        writeIfcThermalLoadTypeEnum(value->getThermalLoadType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSpaceTypeEnum(IfcSpaceTypeEnum enumData) {
    switch(enumData) {
    case IfcSpaceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSpaceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSpaceType(IfcSpaceType *value) {
    m_out << "#" << value->getKey() << "=IFCSPACETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSpaceTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSpatialStructureElement(IfcSpatialStructureElement *value) {
    m_out << "#" << value->getKey() << "=IFCSPATIALSTRUCTUREELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getLongName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLongName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getCompositionType())) {
        m_out << "$";
    }
    else {
        writeIfcElementCompositionEnum(value->getCompositionType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSpatialStructureElementType(IfcSpatialStructureElementType *value) {
    m_out << "#" << value->getKey() << "=IFCSPATIALSTRUCTUREELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSphere(IfcSphere *value) {
    m_out << "#" << value->getKey() << "=IFCSPHERE(";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStackTerminalTypeEnum(IfcStackTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcStackTerminalTypeEnum_BIRDCAGE:
        m_out << ".BIRDCAGE.";
        break;
    case IfcStackTerminalTypeEnum_COWL:
        m_out << ".COWL.";
        break;
    case IfcStackTerminalTypeEnum_RAINWATERHOPPER:
        m_out << ".RAINWATERHOPPER.";
        break;
    case IfcStackTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcStackTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStackTerminalType(IfcStackTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCSTACKTERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStackTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStairTypeEnum(IfcStairTypeEnum enumData) {
    switch(enumData) {
    case IfcStairTypeEnum_STRAIGHT_RUN_STAIR:
        m_out << ".STRAIGHT_RUN_STAIR.";
        break;
    case IfcStairTypeEnum_TWO_STRAIGHT_RUN_STAIR:
        m_out << ".TWO_STRAIGHT_RUN_STAIR.";
        break;
    case IfcStairTypeEnum_QUARTER_WINDING_STAIR:
        m_out << ".QUARTER_WINDING_STAIR.";
        break;
    case IfcStairTypeEnum_QUARTER_TURN_STAIR:
        m_out << ".QUARTER_TURN_STAIR.";
        break;
    case IfcStairTypeEnum_HALF_WINDING_STAIR:
        m_out << ".HALF_WINDING_STAIR.";
        break;
    case IfcStairTypeEnum_HALF_TURN_STAIR:
        m_out << ".HALF_TURN_STAIR.";
        break;
    case IfcStairTypeEnum_TWO_QUARTER_WINDING_STAIR:
        m_out << ".TWO_QUARTER_WINDING_STAIR.";
        break;
    case IfcStairTypeEnum_TWO_QUARTER_TURN_STAIR:
        m_out << ".TWO_QUARTER_TURN_STAIR.";
        break;
    case IfcStairTypeEnum_THREE_QUARTER_WINDING_STAIR:
        m_out << ".THREE_QUARTER_WINDING_STAIR.";
        break;
    case IfcStairTypeEnum_THREE_QUARTER_TURN_STAIR:
        m_out << ".THREE_QUARTER_TURN_STAIR.";
        break;
    case IfcStairTypeEnum_SPIRAL_STAIR:
        m_out << ".SPIRAL_STAIR.";
        break;
    case IfcStairTypeEnum_DOUBLE_RETURN_STAIR:
        m_out << ".DOUBLE_RETURN_STAIR.";
        break;
    case IfcStairTypeEnum_CURVED_RUN_STAIR:
        m_out << ".CURVED_RUN_STAIR.";
        break;
    case IfcStairTypeEnum_TWO_CURVED_RUN_STAIR:
        m_out << ".TWO_CURVED_RUN_STAIR.";
        break;
    case IfcStairTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcStairTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStair(IfcStair *value) {
    m_out << "#" << value->getKey() << "=IFCSTAIR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getShapeType())) {
        m_out << "$";
    }
    else {
        writeIfcStairTypeEnum(value->getShapeType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStairFlight(IfcStairFlight *value) {
    m_out << "#" << value->getKey() << "=IFCSTAIRFLIGHT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getNumberOfRiser())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNumberOfRiser());
    }
    m_out << ",";
    if (Step::isUnset(value->getNumberOfTreads())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNumberOfTreads());
    }
    m_out << ",";
    if (Step::isUnset(value->getRiserHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRiserHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getTreadLength())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTreadLength());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStairFlightTypeEnum(IfcStairFlightTypeEnum enumData) {
    switch(enumData) {
    case IfcStairFlightTypeEnum_STRAIGHT:
        m_out << ".STRAIGHT.";
        break;
    case IfcStairFlightTypeEnum_WINDER:
        m_out << ".WINDER.";
        break;
    case IfcStairFlightTypeEnum_SPIRAL:
        m_out << ".SPIRAL.";
        break;
    case IfcStairFlightTypeEnum_CURVED:
        m_out << ".CURVED.";
        break;
    case IfcStairFlightTypeEnum_FREEFORM:
        m_out << ".FREEFORM.";
        break;
    case IfcStairFlightTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcStairFlightTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStairFlightType(IfcStairFlightType *value) {
    m_out << "#" << value->getKey() << "=IFCSTAIRFLIGHTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStairFlightTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralAction(IfcStructuralAction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralActivity(IfcStructuralActivity *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALACTIVITY(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAnalysisModelTypeEnum(IfcAnalysisModelTypeEnum enumData) {
    switch(enumData) {
    case IfcAnalysisModelTypeEnum_IN_PLANE_LOADING_2D:
        m_out << ".IN_PLANE_LOADING_2D.";
        break;
    case IfcAnalysisModelTypeEnum_OUT_PLANE_LOADING_2D:
        m_out << ".OUT_PLANE_LOADING_2D.";
        break;
    case IfcAnalysisModelTypeEnum_LOADING_3D:
        m_out << ".LOADING_3D.";
        break;
    case IfcAnalysisModelTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAnalysisModelTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralAnalysisModel(IfcStructuralAnalysisModel *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALANALYSISMODEL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcAnalysisModelTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getOrientationOf2DPlane())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientationOf2DPlane());
    }
    m_out << ",";
    if (Step::isUnset(value->getLoadedBy())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcStructuralLoadGroup_1_n::iterator step_it0 = (value->getLoadedBy()).begin();
            if ((value->getLoadedBy()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getLoadedBy()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getHasResults())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcStructuralResultGroup_1_n::iterator step_it0 = (value->getHasResults()).begin();
            if ((value->getHasResults()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasResults()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralConnection(IfcStructuralConnection *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALCONNECTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralConnectionCondition(IfcStructuralConnectionCondition *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALCONNECTIONCONDITION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralCurveConnection(IfcStructuralCurveConnection *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALCURVECONNECTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStructuralCurveTypeEnum(IfcStructuralCurveTypeEnum enumData) {
    switch(enumData) {
    case IfcStructuralCurveTypeEnum_RIGID_JOINED_MEMBER:
        m_out << ".RIGID_JOINED_MEMBER.";
        break;
    case IfcStructuralCurveTypeEnum_PIN_JOINED_MEMBER:
        m_out << ".PIN_JOINED_MEMBER.";
        break;
    case IfcStructuralCurveTypeEnum_CABLE:
        m_out << ".CABLE.";
        break;
    case IfcStructuralCurveTypeEnum_TENSION_MEMBER:
        m_out << ".TENSION_MEMBER.";
        break;
    case IfcStructuralCurveTypeEnum_COMPRESSION_MEMBER:
        m_out << ".COMPRESSION_MEMBER.";
        break;
    case IfcStructuralCurveTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcStructuralCurveTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralCurveMember(IfcStructuralCurveMember *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALCURVEMEMBER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStructuralCurveTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralCurveMemberVarying(IfcStructuralCurveMemberVarying *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALCURVEMEMBERVARYING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStructuralCurveTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralItem(IfcStructuralItem *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALITEM(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcProjectedOrTrueLengthEnum(IfcProjectedOrTrueLengthEnum enumData) {
    switch(enumData) {
    case IfcProjectedOrTrueLengthEnum_PROJECTED_LENGTH:
        m_out << ".PROJECTED_LENGTH.";
        break;
    case IfcProjectedOrTrueLengthEnum_TRUE_LENGTH:
        m_out << ".TRUE_LENGTH.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralLinearAction(IfcStructuralLinearAction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLINEARACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProjectedOrTrue())) {
        m_out << "$";
    }
    else {
        writeIfcProjectedOrTrueLengthEnum(value->getProjectedOrTrue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLinearActionVarying(IfcStructuralLinearActionVarying *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLINEARACTIONVARYING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProjectedOrTrue())) {
        m_out << "$";
    }
    else {
        writeIfcProjectedOrTrueLengthEnum(value->getProjectedOrTrue());
    }
    m_out << ",";
    if (Step::isUnset(value->getVaryingAppliedLoadLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVaryingAppliedLoadLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubsequentAppliedLoads())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcStructuralLoad_1_n::iterator step_it0 = (value->getSubsequentAppliedLoads()).begin();
            if ((value->getSubsequentAppliedLoads()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSubsequentAppliedLoads()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoad(IfcStructuralLoad *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOAD(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcLoadGroupTypeEnum(IfcLoadGroupTypeEnum enumData) {
    switch(enumData) {
    case IfcLoadGroupTypeEnum_LOAD_GROUP:
        m_out << ".LOAD_GROUP.";
        break;
    case IfcLoadGroupTypeEnum_LOAD_CASE:
        m_out << ".LOAD_CASE.";
        break;
    case IfcLoadGroupTypeEnum_LOAD_COMBINATION_GROUP:
        m_out << ".LOAD_COMBINATION_GROUP.";
        break;
    case IfcLoadGroupTypeEnum_LOAD_COMBINATION:
        m_out << ".LOAD_COMBINATION.";
        break;
    case IfcLoadGroupTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcLoadGroupTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcActionTypeEnum(IfcActionTypeEnum enumData) {
    switch(enumData) {
    case IfcActionTypeEnum_PERMANENT_G:
        m_out << ".PERMANENT_G.";
        break;
    case IfcActionTypeEnum_VARIABLE_Q:
        m_out << ".VARIABLE_Q.";
        break;
    case IfcActionTypeEnum_EXTRAORDINARY_A:
        m_out << ".EXTRAORDINARY_A.";
        break;
    case IfcActionTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcActionTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcActionSourceTypeEnum(IfcActionSourceTypeEnum enumData) {
    switch(enumData) {
    case IfcActionSourceTypeEnum_DEAD_LOAD_G:
        m_out << ".DEAD_LOAD_G.";
        break;
    case IfcActionSourceTypeEnum_COMPLETION_G1:
        m_out << ".COMPLETION_G1.";
        break;
    case IfcActionSourceTypeEnum_LIVE_LOAD_Q:
        m_out << ".LIVE_LOAD_Q.";
        break;
    case IfcActionSourceTypeEnum_SNOW_S:
        m_out << ".SNOW_S.";
        break;
    case IfcActionSourceTypeEnum_WIND_W:
        m_out << ".WIND_W.";
        break;
    case IfcActionSourceTypeEnum_PRESTRESSING_P:
        m_out << ".PRESTRESSING_P.";
        break;
    case IfcActionSourceTypeEnum_SETTLEMENT_U:
        m_out << ".SETTLEMENT_U.";
        break;
    case IfcActionSourceTypeEnum_TEMPERATURE_T:
        m_out << ".TEMPERATURE_T.";
        break;
    case IfcActionSourceTypeEnum_EARTHQUAKE_E:
        m_out << ".EARTHQUAKE_E.";
        break;
    case IfcActionSourceTypeEnum_FIRE:
        m_out << ".FIRE.";
        break;
    case IfcActionSourceTypeEnum_IMPULSE:
        m_out << ".IMPULSE.";
        break;
    case IfcActionSourceTypeEnum_IMPACT:
        m_out << ".IMPACT.";
        break;
    case IfcActionSourceTypeEnum_TRANSPORT:
        m_out << ".TRANSPORT.";
        break;
    case IfcActionSourceTypeEnum_ERECTION:
        m_out << ".ERECTION.";
        break;
    case IfcActionSourceTypeEnum_PROPPING:
        m_out << ".PROPPING.";
        break;
    case IfcActionSourceTypeEnum_SYSTEM_IMPERFECTION:
        m_out << ".SYSTEM_IMPERFECTION.";
        break;
    case IfcActionSourceTypeEnum_SHRINKAGE:
        m_out << ".SHRINKAGE.";
        break;
    case IfcActionSourceTypeEnum_CREEP:
        m_out << ".CREEP.";
        break;
    case IfcActionSourceTypeEnum_LACK_OF_FIT:
        m_out << ".LACK_OF_FIT.";
        break;
    case IfcActionSourceTypeEnum_BUOYANCY:
        m_out << ".BUOYANCY.";
        break;
    case IfcActionSourceTypeEnum_ICE:
        m_out << ".ICE.";
        break;
    case IfcActionSourceTypeEnum_CURRENT:
        m_out << ".CURRENT.";
        break;
    case IfcActionSourceTypeEnum_WAVE:
        m_out << ".WAVE.";
        break;
    case IfcActionSourceTypeEnum_RAIN:
        m_out << ".RAIN.";
        break;
    case IfcActionSourceTypeEnum_BRAKES:
        m_out << ".BRAKES.";
        break;
    case IfcActionSourceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcActionSourceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralLoadGroup(IfcStructuralLoadGroup *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADGROUP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcLoadGroupTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getActionType())) {
        m_out << "$";
    }
    else {
        writeIfcActionTypeEnum(value->getActionType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getActionSource())) {
        m_out << "$";
    }
    else {
        writeIfcActionSourceTypeEnum(value->getActionSource());
    }
    m_out << ",";
    if (Step::isUnset(value->getCoefficient())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCoefficient());
    }
    m_out << ",";
    if (Step::isUnset(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPurpose());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadLinearForce(IfcStructuralLoadLinearForce *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADLINEARFORCE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearForceX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearForceX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearForceY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearForceY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearForceZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearForceZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearMomentX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearMomentX());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearMomentY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearMomentY());
    }
    m_out << ",";
    if (Step::isUnset(value->getLinearMomentZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLinearMomentZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadPlanarForce(IfcStructuralLoadPlanarForce *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADPLANARFORCE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlanarForceX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlanarForceX());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlanarForceY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlanarForceY());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlanarForceZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlanarForceZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadSingleDisplacement(IfcStructuralLoadSingleDisplacement *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADSINGLEDISPLACEMENT(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementX());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementY());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRX());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRY());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadSingleDisplacementDistortion(IfcStructuralLoadSingleDisplacementDistortion *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementX());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementY());
    }
    m_out << ",";
    if (Step::isUnset(value->getDisplacementZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDisplacementZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRX());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRY());
    }
    m_out << ",";
    if (Step::isUnset(value->getRotationalDisplacementRZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRotationalDisplacementRZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getDistortion())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDistortion());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadSingleForce(IfcStructuralLoadSingleForce *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADSINGLEFORCE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceX());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceY());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentX());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadSingleForceWarping(IfcStructuralLoadSingleForceWarping *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADSINGLEFORCEWARPING(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceX());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceY());
    }
    m_out << ",";
    if (Step::isUnset(value->getForceZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getForceZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentX());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getWarpingMoment())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWarpingMoment());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadStatic(IfcStructuralLoadStatic *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADSTATIC(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralLoadTemperature(IfcStructuralLoadTemperature *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALLOADTEMPERATURE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDeltaT_Constant())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDeltaT_Constant());
    }
    m_out << ",";
    if (Step::isUnset(value->getDeltaT_Y())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDeltaT_Y());
    }
    m_out << ",";
    if (Step::isUnset(value->getDeltaT_Z())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDeltaT_Z());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralMember(IfcStructuralMember *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALMEMBER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralPlanarAction(IfcStructuralPlanarAction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPLANARACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProjectedOrTrue())) {
        m_out << "$";
    }
    else {
        writeIfcProjectedOrTrueLengthEnum(value->getProjectedOrTrue());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralPlanarActionVarying(IfcStructuralPlanarActionVarying *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPLANARACTIONVARYING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getProjectedOrTrue())) {
        m_out << "$";
    }
    else {
        writeIfcProjectedOrTrueLengthEnum(value->getProjectedOrTrue());
    }
    m_out << ",";
    if (Step::isUnset(value->getVaryingAppliedLoadLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVaryingAppliedLoadLocation());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubsequentAppliedLoads())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcStructuralLoad_2_n::iterator step_it0 = (value->getSubsequentAppliedLoads()).begin();
            if ((value->getSubsequentAppliedLoads()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getSubsequentAppliedLoads()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralPointAction(IfcStructuralPointAction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPOINTACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ",";
    if (Step::isUnset(value->getDestabilizingLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDestabilizingLoad());
    }
    m_out << ",";
    if (Step::isUnset(value->getCausedBy())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCausedBy());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralPointConnection(IfcStructuralPointConnection *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPOINTCONNECTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralPointReaction(IfcStructuralPointReaction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPOINTREACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralProfileProperties(IfcStructuralProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALPROFILEPROPERTIES(";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getPhysicalWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPhysicalWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getPerimeter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPerimeter());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getTorsionalConstantX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTorsionalConstantX());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaYZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaYZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getWarpingConstant())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWarpingConstant());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearCentreZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearCentreZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearCentreY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearCentreY());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearDeformationAreaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearDeformationAreaZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearDeformationAreaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearDeformationAreaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumSectionModulusY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumSectionModulusY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumSectionModulusY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumSectionModulusY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumSectionModulusZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumSectionModulusZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumSectionModulusZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumSectionModulusZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getTorsionalSectionModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTorsionalSectionModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralReaction(IfcStructuralReaction *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALREACTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedLoad())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedLoad());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getGlobalOrLocal())) {
        m_out << "$";
    }
    else {
        writeIfcGlobalOrLocalEnum(value->getGlobalOrLocal());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcAnalysisTheoryTypeEnum(IfcAnalysisTheoryTypeEnum enumData) {
    switch(enumData) {
    case IfcAnalysisTheoryTypeEnum_FIRST_ORDER_THEORY:
        m_out << ".FIRST_ORDER_THEORY.";
        break;
    case IfcAnalysisTheoryTypeEnum_SECOND_ORDER_THEORY:
        m_out << ".SECOND_ORDER_THEORY.";
        break;
    case IfcAnalysisTheoryTypeEnum_THIRD_ORDER_THEORY:
        m_out << ".THIRD_ORDER_THEORY.";
        break;
    case IfcAnalysisTheoryTypeEnum_FULL_NONLINEAR_THEORY:
        m_out << ".FULL_NONLINEAR_THEORY.";
        break;
    case IfcAnalysisTheoryTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcAnalysisTheoryTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralResultGroup(IfcStructuralResultGroup *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALRESULTGROUP(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTheoryType())) {
        m_out << "$";
    }
    else {
        writeIfcAnalysisTheoryTypeEnum(value->getTheoryType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResultForLoadGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResultForLoadGroup());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsLinear())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsLinear());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralSteelProfileProperties(IfcStructuralSteelProfileProperties *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALSTEELPROFILEPROPERTIES(";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileDefinition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileDefinition());
    }
    m_out << ",";
    if (Step::isUnset(value->getPhysicalWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPhysicalWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getPerimeter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPerimeter());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumPlateThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumPlateThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getTorsionalConstantX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTorsionalConstantX());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaYZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaYZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMomentOfInertiaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMomentOfInertiaZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getWarpingConstant())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWarpingConstant());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearCentreZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearCentreZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearCentreY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearCentreY());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearDeformationAreaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearDeformationAreaZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearDeformationAreaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearDeformationAreaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumSectionModulusY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumSectionModulusY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumSectionModulusY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumSectionModulusY());
    }
    m_out << ",";
    if (Step::isUnset(value->getMaximumSectionModulusZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaximumSectionModulusZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinimumSectionModulusZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinimumSectionModulusZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getTorsionalSectionModulus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTorsionalSectionModulus());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInX());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearAreaZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearAreaZ());
    }
    m_out << ",";
    if (Step::isUnset(value->getShearAreaY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShearAreaY());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlasticShapeFactorY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlasticShapeFactorY());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlasticShapeFactorZ())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPlasticShapeFactorZ());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralSurfaceConnection(IfcStructuralSurfaceConnection *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALSURFACECONNECTION(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getAppliedCondition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAppliedCondition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcStructuralSurfaceTypeEnum(IfcStructuralSurfaceTypeEnum enumData) {
    switch(enumData) {
    case IfcStructuralSurfaceTypeEnum_BENDING_ELEMENT:
        m_out << ".BENDING_ELEMENT.";
        break;
    case IfcStructuralSurfaceTypeEnum_MEMBRANE_ELEMENT:
        m_out << ".MEMBRANE_ELEMENT.";
        break;
    case IfcStructuralSurfaceTypeEnum_SHELL:
        m_out << ".SHELL.";
        break;
    case IfcStructuralSurfaceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcStructuralSurfaceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcStructuralSurfaceMember(IfcStructuralSurfaceMember *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALSURFACEMEMBER(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStructuralSurfaceTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThickness());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuralSurfaceMemberVarying(IfcStructuralSurfaceMemberVarying *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTURALSURFACEMEMBERVARYING(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcStructuralSurfaceTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubsequentThickness())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcPositiveLengthMeasure_2_n::iterator step_it0 = (value->getSubsequentThickness()).begin();
            if ((value->getSubsequentThickness()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getSubsequentThickness()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getVaryingThicknessLocation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVaryingThicknessLocation());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStructuredDimensionCallout(IfcStructuredDimensionCallout *value) {
    m_out << "#" << value->getKey() << "=IFCSTRUCTUREDDIMENSIONCALLOUT(";
    if (Step::isUnset(value->getContents())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDraughtingCalloutElement_1_n::iterator step_it0 = (value->getContents()).begin();
            if ((value->getContents()).size()) {
                writeIfcDraughtingCalloutElement((*step_it0).get());
                for (step_it0++; step_it0 != (value->getContents()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDraughtingCalloutElement((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStyleModel(IfcStyleModel *value) {
    m_out << "#" << value->getKey() << "=IFCSTYLEMODEL(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStyledItem(IfcStyledItem *value) {
    m_out << "#" << value->getKey() << "=IFCSTYLEDITEM(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcStyledRepresentation(IfcStyledRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCSTYLEDREPRESENTATION(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSubContractResource(IfcSubContractResource *value) {
    m_out << "#" << value->getKey() << "=IFCSUBCONTRACTRESOURCE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getResourceGroup())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getResourceGroup());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getResourceConsumption())) {
        m_out << "$";
    }
    else {
        writeIfcResourceConsumptionEnum(value->getResourceConsumption());
    }
    m_out << ",";
    if (Step::isUnset(value->getBaseQuantity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBaseQuantity());
    }
    m_out << ",";
    if (Step::isUnset(value->getSubContractor())) {
        m_out << "$";
    }
    else {
        writeIfcActorSelect(value->getSubContractor());
    }
    m_out << ",";
    if (Step::isUnset(value->getJobDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getJobDescription());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSubedge(IfcSubedge *value) {
    m_out << "#" << value->getKey() << "=IFCSUBEDGE(";
    if (Step::isUnset(value->getEdgeStart())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeStart());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeEnd())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeEnd());
    }
    m_out << ",";
    if (Step::isUnset(value->getParentEdge())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParentEdge());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurface(IfcSurface *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACE(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceCurveSweptAreaSolid(IfcSurfaceCurveSweptAreaSolid *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACECURVESWEPTAREASOLID(";
    if (Step::isUnset(value->getSweptArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDirectrix())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDirectrix());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartParam())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStartParam());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndParam())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEndParam());
    }
    m_out << ",";
    if (Step::isUnset(value->getReferenceSurface())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getReferenceSurface());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceOfLinearExtrusion(IfcSurfaceOfLinearExtrusion *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACEOFLINEAREXTRUSION(";
    if (Step::isUnset(value->getSweptCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getExtrudedDirection())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExtrudedDirection());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceOfRevolution(IfcSurfaceOfRevolution *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACEOFREVOLUTION(";
    if (Step::isUnset(value->getSweptCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getAxisPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAxisPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSurfaceSide(IfcSurfaceSide enumData) {
    switch(enumData) {
    case IfcSurfaceSide_POSITIVE:
        m_out << ".POSITIVE.";
        break;
    case IfcSurfaceSide_NEGATIVE:
        m_out << ".NEGATIVE.";
        break;
    case IfcSurfaceSide_BOTH:
        m_out << ".BOTH.";
        break;
        }
}

void SPFWriter::writeIfcSurfaceStyleElementSelect(IfcSurfaceStyleElementSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcSurfaceStyleElementSelect::IFCSURFACESTYLESHADING:
        writeAttribute(selectData->getIfcSurfaceStyleShading());
        break;
    case IfcSurfaceStyleElementSelect::IFCSURFACESTYLELIGHTING:
        writeAttribute(selectData->getIfcSurfaceStyleLighting());
        break;
    case IfcSurfaceStyleElementSelect::IFCSURFACESTYLEWITHTEXTURES:
        writeAttribute(selectData->getIfcSurfaceStyleWithTextures());
        break;
    case IfcSurfaceStyleElementSelect::IFCEXTERNALLYDEFINEDSURFACESTYLE:
        writeAttribute(selectData->getIfcExternallyDefinedSurfaceStyle());
        break;
    case IfcSurfaceStyleElementSelect::IFCSURFACESTYLEREFRACTION:
        writeAttribute(selectData->getIfcSurfaceStyleRefraction());
        break;
        }
}

bool SPFWriter::visitIfcSurfaceStyle(IfcSurfaceStyle *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getSide())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceSide(value->getSide());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcSurfaceStyleElementSelect_1_5::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeIfcSurfaceStyleElementSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcSurfaceStyleElementSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceStyleLighting(IfcSurfaceStyleLighting *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLELIGHTING(";
    if (Step::isUnset(value->getDiffuseTransmissionColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDiffuseTransmissionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getDiffuseReflectionColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDiffuseReflectionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransmissionColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransmissionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getReflectanceColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getReflectanceColour());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceStyleRefraction(IfcSurfaceStyleRefraction *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLEREFRACTION(";
    if (Step::isUnset(value->getRefractionIndex())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRefractionIndex());
    }
    m_out << ",";
    if (Step::isUnset(value->getDispersionFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDispersionFactor());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcColourOrFactor(IfcColourOrFactor *selectData) {
    switch(selectData->currentType()) {
    case IfcColourOrFactor::IFCCOLOURRGB:
        writeAttribute(selectData->getIfcColourRgb());
        break;
    case IfcColourOrFactor::IFCNORMALISEDRATIOMEASURE:
        m_out << "IFCNORMALISEDRATIOMEASURE(";
        writeAttribute(selectData->getIfcNormalisedRatioMeasure());
        m_out << ")";
        break;
        }
}

void SPFWriter::writeIfcSpecularHighlightSelect(IfcSpecularHighlightSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcSpecularHighlightSelect::IFCSPECULAREXPONENT:
        m_out << "IFCSPECULAREXPONENT(";
        writeAttribute(selectData->getIfcSpecularExponent());
        m_out << ")";
        break;
    case IfcSpecularHighlightSelect::IFCSPECULARROUGHNESS:
        m_out << "IFCSPECULARROUGHNESS(";
        writeAttribute(selectData->getIfcSpecularRoughness());
        m_out << ")";
        break;
        }
}

void SPFWriter::writeIfcReflectanceMethodEnum(IfcReflectanceMethodEnum enumData) {
    switch(enumData) {
    case IfcReflectanceMethodEnum_BLINN:
        m_out << ".BLINN.";
        break;
    case IfcReflectanceMethodEnum_FLAT:
        m_out << ".FLAT.";
        break;
    case IfcReflectanceMethodEnum_GLASS:
        m_out << ".GLASS.";
        break;
    case IfcReflectanceMethodEnum_MATT:
        m_out << ".MATT.";
        break;
    case IfcReflectanceMethodEnum_METAL:
        m_out << ".METAL.";
        break;
    case IfcReflectanceMethodEnum_MIRROR:
        m_out << ".MIRROR.";
        break;
    case IfcReflectanceMethodEnum_PHONG:
        m_out << ".PHONG.";
        break;
    case IfcReflectanceMethodEnum_PLASTIC:
        m_out << ".PLASTIC.";
        break;
    case IfcReflectanceMethodEnum_STRAUSS:
        m_out << ".STRAUSS.";
        break;
    case IfcReflectanceMethodEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSurfaceStyleRendering(IfcSurfaceStyleRendering *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLERENDERING(";
    if (Step::isUnset(value->getSurfaceColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSurfaceColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransparency())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransparency());
    }
    m_out << ",";
    if (Step::isUnset(value->getDiffuseColour())) {
        m_out << "$";
    }
    else {
        writeIfcColourOrFactor(value->getDiffuseColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransmissionColour())) {
        m_out << "$";
    }
    else {
        writeIfcColourOrFactor(value->getTransmissionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getDiffuseTransmissionColour())) {
        m_out << "$";
    }
    else {
        writeIfcColourOrFactor(value->getDiffuseTransmissionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getReflectionColour())) {
        m_out << "$";
    }
    else {
        writeIfcColourOrFactor(value->getReflectionColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpecularColour())) {
        m_out << "$";
    }
    else {
        writeIfcColourOrFactor(value->getSpecularColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpecularHighlight())) {
        m_out << "$";
    }
    else {
        writeIfcSpecularHighlightSelect(value->getSpecularHighlight());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getReflectanceMethod())) {
        m_out << "$";
    }
    else {
        writeIfcReflectanceMethodEnum(value->getReflectanceMethod());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceStyleShading(IfcSurfaceStyleShading *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLESHADING(";
    if (Step::isUnset(value->getSurfaceColour())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSurfaceColour());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceStyleWithTextures(IfcSurfaceStyleWithTextures *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACESTYLEWITHTEXTURES(";
    if (Step::isUnset(value->getTextures())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcSurfaceTexture_1_n::iterator step_it0 = (value->getTextures()).begin();
            if ((value->getTextures()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTextures()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSurfaceTexture(IfcSurfaceTexture *value) {
    m_out << "#" << value->getKey() << "=IFCSURFACETEXTURE(";
    if (Step::isUnset(value->getRepeatS())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatS());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepeatT())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatT());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTextureType())) {
        m_out << "$";
    }
    else {
        writeIfcSurfaceTextureEnum(value->getTextureType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextureTransform())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextureTransform());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSweptAreaSolid(IfcSweptAreaSolid *value) {
    m_out << "#" << value->getKey() << "=IFCSWEPTAREASOLID(";
    if (Step::isUnset(value->getSweptArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSweptDiskSolid(IfcSweptDiskSolid *value) {
    m_out << "#" << value->getKey() << "=IFCSWEPTDISKSOLID(";
    if (Step::isUnset(value->getDirectrix())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDirectrix());
    }
    m_out << ",";
    if (Step::isUnset(value->getRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getInnerRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getInnerRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartParam())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStartParam());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndParam())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEndParam());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSweptSurface(IfcSweptSurface *value) {
    m_out << "#" << value->getKey() << "=IFCSWEPTSURFACE(";
    if (Step::isUnset(value->getSweptCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSweptCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSwitchingDeviceTypeEnum(IfcSwitchingDeviceTypeEnum enumData) {
    switch(enumData) {
    case IfcSwitchingDeviceTypeEnum_CONTACTOR:
        m_out << ".CONTACTOR.";
        break;
    case IfcSwitchingDeviceTypeEnum_EMERGENCYSTOP:
        m_out << ".EMERGENCYSTOP.";
        break;
    case IfcSwitchingDeviceTypeEnum_STARTER:
        m_out << ".STARTER.";
        break;
    case IfcSwitchingDeviceTypeEnum_SWITCHDISCONNECTOR:
        m_out << ".SWITCHDISCONNECTOR.";
        break;
    case IfcSwitchingDeviceTypeEnum_TOGGLESWITCH:
        m_out << ".TOGGLESWITCH.";
        break;
    case IfcSwitchingDeviceTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcSwitchingDeviceTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcSwitchingDeviceType(IfcSwitchingDeviceType *value) {
    m_out << "#" << value->getKey() << "=IFCSWITCHINGDEVICETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcSwitchingDeviceTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSymbolStyleSelect(IfcSymbolStyleSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcSymbolStyleSelect::IFCCOLOURSPECIFICATION:
        writeAttribute(selectData->getIfcColourSpecification());
        break;
    case IfcSymbolStyleSelect::IFCPREDEFINEDCOLOUR:
        writeAttribute(selectData->getIfcPreDefinedColour());
        break;
        }
}

bool SPFWriter::visitIfcSymbolStyle(IfcSymbolStyle *value) {
    m_out << "#" << value->getKey() << "=IFCSYMBOLSTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyleOfSymbol())) {
        m_out << "$";
    }
    else {
        writeIfcSymbolStyleSelect(value->getStyleOfSymbol());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSystem(IfcSystem *value) {
    m_out << "#" << value->getKey() << "=IFCSYSTEM(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcSystemFurnitureElementType(IfcSystemFurnitureElementType *value) {
    m_out << "#" << value->getKey() << "=IFCSYSTEMFURNITUREELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTShapeProfileDef(IfcTShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCTSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeEdgeRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeEdgeRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebEdgeRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebEdgeRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebSlope())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebSlope());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeSlope())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeSlope());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInY())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInY());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTable(IfcTable *value) {
    m_out << "#" << value->getKey() << "=IFCTABLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getRows())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcTableRow_1_n::iterator step_it0 = (value->getRows()).begin();
            if ((value->getRows()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRows()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTableRow(IfcTableRow *value) {
    m_out << "#" << value->getKey() << "=IFCTABLEROW(";
    if (Step::isUnset(value->getRowCells())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getRowCells()).begin();
            if ((value->getRowCells()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRowCells()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getIsHeading())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsHeading());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTankTypeEnum(IfcTankTypeEnum enumData) {
    switch(enumData) {
    case IfcTankTypeEnum_PREFORMED:
        m_out << ".PREFORMED.";
        break;
    case IfcTankTypeEnum_SECTIONAL:
        m_out << ".SECTIONAL.";
        break;
    case IfcTankTypeEnum_EXPANSION:
        m_out << ".EXPANSION.";
        break;
    case IfcTankTypeEnum_PRESSUREVESSEL:
        m_out << ".PRESSUREVESSEL.";
        break;
    case IfcTankTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTankTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTankType(IfcTankType *value) {
    m_out << "#" << value->getKey() << "=IFCTANKTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcTankTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTask(IfcTask *value) {
    m_out << "#" << value->getKey() << "=IFCTASK(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTaskId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTaskId());
    }
    m_out << ",";
    if (Step::isUnset(value->getStatus())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getStatus());
    }
    m_out << ",";
    if (Step::isUnset(value->getWorkMethod())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWorkMethod());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsMilestone())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsMilestone());
    }
    m_out << ",";
    if (Step::isUnset(value->getPriority())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPriority());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTelecomAddress(IfcTelecomAddress *value) {
    m_out << "#" << value->getKey() << "=IFCTELECOMADDRESS(";
    if (Step::isUnsetEnum(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeIfcAddressTypeEnum(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getTelephoneNumbers())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getTelephoneNumbers()).begin();
            if ((value->getTelephoneNumbers()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getTelephoneNumbers()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getFacsimileNumbers())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getFacsimileNumbers()).begin();
            if ((value->getFacsimileNumbers()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getFacsimileNumbers()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPagerNumber())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPagerNumber());
    }
    m_out << ",";
    if (Step::isUnset(value->getElectronicMailAddresses())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLabel_1_n::iterator step_it0 = (value->getElectronicMailAddresses()).begin();
            if ((value->getElectronicMailAddresses()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getElectronicMailAddresses()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getWWWHomePageURL())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWWWHomePageURL());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTendonTypeEnum(IfcTendonTypeEnum enumData) {
    switch(enumData) {
    case IfcTendonTypeEnum_STRAND:
        m_out << ".STRAND.";
        break;
    case IfcTendonTypeEnum_WIRE:
        m_out << ".WIRE.";
        break;
    case IfcTendonTypeEnum_BAR:
        m_out << ".BAR.";
        break;
    case IfcTendonTypeEnum_COATED:
        m_out << ".COATED.";
        break;
    case IfcTendonTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTendonTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTendon(IfcTendon *value) {
    m_out << "#" << value->getKey() << "=IFCTENDON(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcTendonTypeEnum(value->getPredefinedType());
    }
    m_out << ",";
    if (Step::isUnset(value->getNominalDiameter())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getNominalDiameter());
    }
    m_out << ",";
    if (Step::isUnset(value->getCrossSectionArea())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCrossSectionArea());
    }
    m_out << ",";
    if (Step::isUnset(value->getTensionForce())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTensionForce());
    }
    m_out << ",";
    if (Step::isUnset(value->getPreStress())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPreStress());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrictionCoefficient())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrictionCoefficient());
    }
    m_out << ",";
    if (Step::isUnset(value->getAnchorageSlip())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAnchorageSlip());
    }
    m_out << ",";
    if (Step::isUnset(value->getMinCurvatureRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMinCurvatureRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTendonAnchor(IfcTendonAnchor *value) {
    m_out << "#" << value->getKey() << "=IFCTENDONANCHOR(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getSteelGrade())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSteelGrade());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTerminatorSymbol(IfcTerminatorSymbol *value) {
    m_out << "#" << value->getKey() << "=IFCTERMINATORSYMBOL(";
    if (Step::isUnset(value->getItem())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getItem());
    }
    m_out << ",";
    if (Step::isUnset(value->getStyles())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPresentationStyleAssignment_1_n::iterator step_it0 = (value->getStyles()).begin();
            if ((value->getStyles()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getStyles()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getAnnotatedCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAnnotatedCurve());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTextPath(IfcTextPath enumData) {
    switch(enumData) {
    case IfcTextPath_LEFT:
        m_out << ".LEFT.";
        break;
    case IfcTextPath_RIGHT:
        m_out << ".RIGHT.";
        break;
    case IfcTextPath_UP:
        m_out << ".UP.";
        break;
    case IfcTextPath_DOWN:
        m_out << ".DOWN.";
        break;
        }
}

bool SPFWriter::visitIfcTextLiteral(IfcTextLiteral *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTLITERAL(";
    if (Step::isUnset(value->getLiteral())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiteral());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlacement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPlacement());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPath())) {
        m_out << "$";
    }
    else {
        writeIfcTextPath(value->getPath());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextLiteralWithExtent(IfcTextLiteralWithExtent *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTLITERALWITHEXTENT(";
    if (Step::isUnset(value->getLiteral())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiteral());
    }
    m_out << ",";
    if (Step::isUnset(value->getPlacement())) {
        m_out << "$";
    }
    else {
        writeIfcAxis2Placement(value->getPlacement());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPath())) {
        m_out << "$";
    }
    else {
        writeIfcTextPath(value->getPath());
    }
    m_out << ",";
    if (Step::isUnset(value->getExtent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getExtent());
    }
    m_out << ",";
    if (Step::isUnset(value->getBoxAlignment())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoxAlignment());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcCharacterStyleSelect(IfcCharacterStyleSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcCharacterStyleSelect::IFCTEXTSTYLEFORDEFINEDFONT:
        writeAttribute(selectData->getIfcTextStyleForDefinedFont());
        break;
        }
}

void SPFWriter::writeIfcTextStyleSelect(IfcTextStyleSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcTextStyleSelect::IFCTEXTSTYLEWITHBOXCHARACTERISTICS:
        writeAttribute(selectData->getIfcTextStyleWithBoxCharacteristics());
        break;
    case IfcTextStyleSelect::IFCTEXTSTYLETEXTMODEL:
        writeAttribute(selectData->getIfcTextStyleTextModel());
        break;
        }
}

void SPFWriter::writeIfcTextFontSelect(IfcTextFontSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcTextFontSelect::IFCPREDEFINEDTEXTFONT:
        writeAttribute(selectData->getIfcPreDefinedTextFont());
        break;
    case IfcTextFontSelect::IFCEXTERNALLYDEFINEDTEXTFONT:
        writeAttribute(selectData->getIfcExternallyDefinedTextFont());
        break;
        }
}

bool SPFWriter::visitIfcTextStyle(IfcTextStyle *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTSTYLE(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextCharacterAppearance())) {
        m_out << "$";
    }
    else {
        writeIfcCharacterStyleSelect(value->getTextCharacterAppearance());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextStyle())) {
        m_out << "$";
    }
    else {
        writeIfcTextStyleSelect(value->getTextStyle());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextFontStyle())) {
        m_out << "$";
    }
    else {
        writeIfcTextFontSelect(value->getTextFontStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextStyleFontModel(IfcTextStyleFontModel *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTSTYLEFONTMODEL(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getFontFamily())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcTextFontName_1_n::iterator step_it0 = (value->getFontFamily()).begin();
            if ((value->getFontFamily()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getFontFamily()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getFontStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFontStyle());
    }
    m_out << ",";
    if (Step::isUnset(value->getFontVariant())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFontVariant());
    }
    m_out << ",";
    if (Step::isUnset(value->getFontWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFontWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getFontSize())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getFontSize());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextStyleForDefinedFont(IfcTextStyleForDefinedFont *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTSTYLEFORDEFINEDFONT(";
    if (Step::isUnset(value->getColour())) {
        m_out << "$";
    }
    else {
        writeIfcColour(value->getColour());
    }
    m_out << ",";
    if (Step::isUnset(value->getBackgroundColour())) {
        m_out << "$";
    }
    else {
        writeIfcColour(value->getBackgroundColour());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextStyleTextModel(IfcTextStyleTextModel *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTSTYLETEXTMODEL(";
    if (Step::isUnset(value->getTextIndent())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getTextIndent());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextAlign())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextAlign());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextDecoration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextDecoration());
    }
    m_out << ",";
    if (Step::isUnset(value->getLetterSpacing())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getLetterSpacing());
    }
    m_out << ",";
    if (Step::isUnset(value->getWordSpacing())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getWordSpacing());
    }
    m_out << ",";
    if (Step::isUnset(value->getTextTransform())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTextTransform());
    }
    m_out << ",";
    if (Step::isUnset(value->getLineHeight())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getLineHeight());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextStyleWithBoxCharacteristics(IfcTextStyleWithBoxCharacteristics *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTSTYLEWITHBOXCHARACTERISTICS(";
    if (Step::isUnset(value->getBoxHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoxHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getBoxWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoxWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getBoxSlantAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoxSlantAngle());
    }
    m_out << ",";
    if (Step::isUnset(value->getBoxRotateAngle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoxRotateAngle());
    }
    m_out << ",";
    if (Step::isUnset(value->getCharacterSpacing())) {
        m_out << "$";
    }
    else {
        writeIfcSizeSelect(value->getCharacterSpacing());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextureCoordinate(IfcTextureCoordinate *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTURECOORDINATE(";
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcSimpleValue(IfcSimpleValue *selectData) {
    switch(selectData->currentType()) {
    case IfcSimpleValue::IFCINTEGER:
        m_out << "IFCINTEGER(";
        writeAttribute(selectData->getIfcInteger());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCREAL:
        m_out << "IFCREAL(";
        writeAttribute(selectData->getIfcReal());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCBOOLEAN:
        m_out << "IFCBOOLEAN(";
        writeAttribute(selectData->getIfcBoolean());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCIDENTIFIER:
        m_out << "IFCIDENTIFIER(";
        writeAttribute(selectData->getIfcIdentifier());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCTEXT:
        m_out << "IFCTEXT(";
        writeAttribute(selectData->getIfcText());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCLABEL:
        m_out << "IFCLABEL(";
        writeAttribute(selectData->getIfcLabel());
        m_out << ")";
        break;
    case IfcSimpleValue::IFCLOGICAL:
        m_out << "IFCLOGICAL(";
        writeAttribute(selectData->getIfcLogical());
        m_out << ")";
        break;
        }
}

bool SPFWriter::visitIfcTextureCoordinateGenerator(IfcTextureCoordinateGenerator *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTURECOORDINATEGENERATOR(";
    if (Step::isUnset(value->getMode())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMode());
    }
    m_out << ",";
    if (Step::isUnset(value->getParameter())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcSimpleValue_1_n::iterator step_it0 = (value->getParameter()).begin();
            if ((value->getParameter()).size()) {
                writeIfcSimpleValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getParameter()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcSimpleValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextureMap(IfcTextureMap *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTUREMAP(";
    if (Step::isUnset(value->getTextureMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcVertexBasedTextureMap_1_n::iterator step_it0 = (value->getTextureMaps()).begin();
            if ((value->getTextureMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTextureMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTextureVertex(IfcTextureVertex *value) {
    m_out << "#" << value->getKey() << "=IFCTEXTUREVERTEX(";
    if (Step::isUnset(value->getCoordinates())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcParameterValue_2_2::iterator step_it0 = (value->getCoordinates()).begin();
            if ((value->getCoordinates()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getCoordinates()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcThermalMaterialProperties(IfcThermalMaterialProperties *value) {
    m_out << "#" << value->getKey() << "=IFCTHERMALMATERIALPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getSpecificHeatCapacity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSpecificHeatCapacity());
    }
    m_out << ",";
    if (Step::isUnset(value->getBoilingPoint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBoilingPoint());
    }
    m_out << ",";
    if (Step::isUnset(value->getFreezingPoint())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFreezingPoint());
    }
    m_out << ",";
    if (Step::isUnset(value->getThermalConductivity())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getThermalConductivity());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTimeSeries(IfcTimeSeries *value) {
    m_out << "#" << value->getKey() << "=IFCTIMESERIES(";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getEndTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getEndTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTimeSeriesDataType())) {
        m_out << "$";
    }
    else {
        writeIfcTimeSeriesDataTypeEnum(value->getTimeSeriesDataType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getDataOrigin())) {
        m_out << "$";
    }
    else {
        writeIfcDataOriginEnum(value->getDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedDataOrigin())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedDataOrigin());
    }
    m_out << ",";
    if (Step::isUnset(value->getUnit())) {
        m_out << "$";
    }
    else {
        writeIfcUnit(value->getUnit());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTimeSeriesReferenceRelationship(IfcTimeSeriesReferenceRelationship *value) {
    m_out << "#" << value->getKey() << "=IFCTIMESERIESREFERENCERELATIONSHIP(";
    if (Step::isUnset(value->getReferencedTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getReferencedTimeSeries());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeSeriesReferences())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcDocumentSelect_1_n::iterator step_it0 = (value->getTimeSeriesReferences()).begin();
            if ((value->getTimeSeriesReferences()).size()) {
                writeIfcDocumentSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTimeSeriesReferences()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDocumentSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTimeSeriesScheduleTypeEnum(IfcTimeSeriesScheduleTypeEnum enumData) {
    switch(enumData) {
    case IfcTimeSeriesScheduleTypeEnum_ANNUAL:
        m_out << ".ANNUAL.";
        break;
    case IfcTimeSeriesScheduleTypeEnum_MONTHLY:
        m_out << ".MONTHLY.";
        break;
    case IfcTimeSeriesScheduleTypeEnum_WEEKLY:
        m_out << ".WEEKLY.";
        break;
    case IfcTimeSeriesScheduleTypeEnum_DAILY:
        m_out << ".DAILY.";
        break;
    case IfcTimeSeriesScheduleTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTimeSeriesScheduleTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTimeSeriesSchedule(IfcTimeSeriesSchedule *value) {
    m_out << "#" << value->getKey() << "=IFCTIMESERIESSCHEDULE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableDates())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcDateTimeSelect_1_n::iterator step_it0 = (value->getApplicableDates()).begin();
            if ((value->getApplicableDates()).size()) {
                writeIfcDateTimeSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getApplicableDates()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcDateTimeSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getTimeSeriesScheduleType())) {
        m_out << "$";
    }
    else {
        writeIfcTimeSeriesScheduleTypeEnum(value->getTimeSeriesScheduleType());
    }
    m_out << ",";
    if (Step::isUnset(value->getTimeSeries())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTimeSeries());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTimeSeriesValue(IfcTimeSeriesValue *value) {
    m_out << "#" << value->getKey() << "=IFCTIMESERIESVALUE(";
    if (Step::isUnset(value->getListValues())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcValue_1_n::iterator step_it0 = (value->getListValues()).begin();
            if ((value->getListValues()).size()) {
                writeIfcValue((*step_it0).get());
                for (step_it0++; step_it0 != (value->getListValues()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcValue((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTopologicalRepresentationItem(IfcTopologicalRepresentationItem *value) {
    m_out << "#" << value->getKey() << "=IFCTOPOLOGICALREPRESENTATIONITEM(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTopologyRepresentation(IfcTopologyRepresentation *value) {
    m_out << "#" << value->getKey() << "=IFCTOPOLOGYREPRESENTATION(";
    if (Step::isUnset(value->getContextOfItems())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getContextOfItems());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getItems())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcRepresentationItem_1_n::iterator step_it0 = (value->getItems()).begin();
            if ((value->getItems()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getItems()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTransformerTypeEnum(IfcTransformerTypeEnum enumData) {
    switch(enumData) {
    case IfcTransformerTypeEnum_CURRENT:
        m_out << ".CURRENT.";
        break;
    case IfcTransformerTypeEnum_FREQUENCY:
        m_out << ".FREQUENCY.";
        break;
    case IfcTransformerTypeEnum_VOLTAGE:
        m_out << ".VOLTAGE.";
        break;
    case IfcTransformerTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTransformerTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTransformerType(IfcTransformerType *value) {
    m_out << "#" << value->getKey() << "=IFCTRANSFORMERTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcTransformerTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTransportElementTypeEnum(IfcTransportElementTypeEnum enumData) {
    switch(enumData) {
    case IfcTransportElementTypeEnum_ELEVATOR:
        m_out << ".ELEVATOR.";
        break;
    case IfcTransportElementTypeEnum_ESCALATOR:
        m_out << ".ESCALATOR.";
        break;
    case IfcTransportElementTypeEnum_MOVINGWALKWAY:
        m_out << ".MOVINGWALKWAY.";
        break;
    case IfcTransportElementTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTransportElementTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTransportElement(IfcTransportElement *value) {
    m_out << "#" << value->getKey() << "=IFCTRANSPORTELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getOperationType())) {
        m_out << "$";
    }
    else {
        writeIfcTransportElementTypeEnum(value->getOperationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getCapacityByWeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCapacityByWeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getCapacityByNumber())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCapacityByNumber());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTransportElementType(IfcTransportElementType *value) {
    m_out << "#" << value->getKey() << "=IFCTRANSPORTELEMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcTransportElementTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTrapeziumProfileDef(IfcTrapeziumProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCTRAPEZIUMPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getBottomXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBottomXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getTopXDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTopXDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getYDim())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getYDim());
    }
    m_out << ",";
    if (Step::isUnset(value->getTopXOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTopXOffset());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTrimmingSelect(IfcTrimmingSelect *selectData) {
    switch(selectData->currentType()) {
    case IfcTrimmingSelect::IFCCARTESIANPOINT:
        writeAttribute(selectData->getIfcCartesianPoint());
        break;
    case IfcTrimmingSelect::IFCPARAMETERVALUE:
        m_out << "IFCPARAMETERVALUE(";
        writeAttribute(selectData->getIfcParameterValue());
        m_out << ")";
        break;
        }
}

void SPFWriter::writeIfcTrimmingPreference(IfcTrimmingPreference enumData) {
    switch(enumData) {
    case IfcTrimmingPreference_CARTESIAN:
        m_out << ".CARTESIAN.";
        break;
    case IfcTrimmingPreference_PARAMETER:
        m_out << ".PARAMETER.";
        break;
    case IfcTrimmingPreference_UNSPECIFIED:
        m_out << ".UNSPECIFIED.";
        break;
        }
}

bool SPFWriter::visitIfcTrimmedCurve(IfcTrimmedCurve *value) {
    m_out << "#" << value->getKey() << "=IFCTRIMMEDCURVE(";
    if (Step::isUnset(value->getBasisCurve())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getBasisCurve());
    }
    m_out << ",";
    if (Step::isUnset(value->getTrim1())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcTrimmingSelect_1_2::iterator step_it0 = (value->getTrim1()).begin();
            if ((value->getTrim1()).size()) {
                writeIfcTrimmingSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTrim1()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcTrimmingSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTrim2())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcTrimmingSelect_1_2::iterator step_it0 = (value->getTrim2()).begin();
            if ((value->getTrim2()).size()) {
                writeIfcTrimmingSelect((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTrim2()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcTrimmingSelect((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getSenseAgreement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSenseAgreement());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getMasterRepresentation())) {
        m_out << "$";
    }
    else {
        writeIfcTrimmingPreference(value->getMasterRepresentation());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcTubeBundleTypeEnum(IfcTubeBundleTypeEnum enumData) {
    switch(enumData) {
    case IfcTubeBundleTypeEnum_FINNED:
        m_out << ".FINNED.";
        break;
    case IfcTubeBundleTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcTubeBundleTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcTubeBundleType(IfcTubeBundleType *value) {
    m_out << "#" << value->getKey() << "=IFCTUBEBUNDLETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcTubeBundleTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTwoDirectionRepeatFactor(IfcTwoDirectionRepeatFactor *value) {
    m_out << "#" << value->getKey() << "=IFCTWODIRECTIONREPEATFACTOR(";
    if (Step::isUnset(value->getRepeatFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepeatFactor());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondRepeatFactor())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSecondRepeatFactor());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTypeObject(IfcTypeObject *value) {
    m_out << "#" << value->getKey() << "=IFCTYPEOBJECT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcTypeProduct(IfcTypeProduct *value) {
    m_out << "#" << value->getKey() << "=IFCTYPEPRODUCT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcUShapeProfileDef(IfcUShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCUSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeSlope())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeSlope());
    }
    m_out << ",";
    if (Step::isUnset(value->getCentreOfGravityInX())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getCentreOfGravityInX());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcUnitAssignment(IfcUnitAssignment *value) {
    m_out << "#" << value->getKey() << "=IFCUNITASSIGNMENT(";
    if (Step::isUnset(value->getUnits())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcUnit_1_n::iterator step_it0 = (value->getUnits()).begin();
            if ((value->getUnits()).size()) {
                writeIfcUnit((*step_it0).get());
                for (step_it0++; step_it0 != (value->getUnits()).end(); step_it0++) {
                    m_out << ",";
                    writeIfcUnit((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcUnitaryEquipmentTypeEnum(IfcUnitaryEquipmentTypeEnum enumData) {
    switch(enumData) {
    case IfcUnitaryEquipmentTypeEnum_AIRHANDLER:
        m_out << ".AIRHANDLER.";
        break;
    case IfcUnitaryEquipmentTypeEnum_AIRCONDITIONINGUNIT:
        m_out << ".AIRCONDITIONINGUNIT.";
        break;
    case IfcUnitaryEquipmentTypeEnum_SPLITSYSTEM:
        m_out << ".SPLITSYSTEM.";
        break;
    case IfcUnitaryEquipmentTypeEnum_ROOFTOPUNIT:
        m_out << ".ROOFTOPUNIT.";
        break;
    case IfcUnitaryEquipmentTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcUnitaryEquipmentTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcUnitaryEquipmentType(IfcUnitaryEquipmentType *value) {
    m_out << "#" << value->getKey() << "=IFCUNITARYEQUIPMENTTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcUnitaryEquipmentTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcValveTypeEnum(IfcValveTypeEnum enumData) {
    switch(enumData) {
    case IfcValveTypeEnum_AIRRELEASE:
        m_out << ".AIRRELEASE.";
        break;
    case IfcValveTypeEnum_ANTIVACUUM:
        m_out << ".ANTIVACUUM.";
        break;
    case IfcValveTypeEnum_CHANGEOVER:
        m_out << ".CHANGEOVER.";
        break;
    case IfcValveTypeEnum_CHECK:
        m_out << ".CHECK.";
        break;
    case IfcValveTypeEnum_COMMISSIONING:
        m_out << ".COMMISSIONING.";
        break;
    case IfcValveTypeEnum_DIVERTING:
        m_out << ".DIVERTING.";
        break;
    case IfcValveTypeEnum_DRAWOFFCOCK:
        m_out << ".DRAWOFFCOCK.";
        break;
    case IfcValveTypeEnum_DOUBLECHECK:
        m_out << ".DOUBLECHECK.";
        break;
    case IfcValveTypeEnum_DOUBLEREGULATING:
        m_out << ".DOUBLEREGULATING.";
        break;
    case IfcValveTypeEnum_FAUCET:
        m_out << ".FAUCET.";
        break;
    case IfcValveTypeEnum_FLUSHING:
        m_out << ".FLUSHING.";
        break;
    case IfcValveTypeEnum_GASCOCK:
        m_out << ".GASCOCK.";
        break;
    case IfcValveTypeEnum_GASTAP:
        m_out << ".GASTAP.";
        break;
    case IfcValveTypeEnum_ISOLATING:
        m_out << ".ISOLATING.";
        break;
    case IfcValveTypeEnum_MIXING:
        m_out << ".MIXING.";
        break;
    case IfcValveTypeEnum_PRESSUREREDUCING:
        m_out << ".PRESSUREREDUCING.";
        break;
    case IfcValveTypeEnum_PRESSURERELIEF:
        m_out << ".PRESSURERELIEF.";
        break;
    case IfcValveTypeEnum_REGULATING:
        m_out << ".REGULATING.";
        break;
    case IfcValveTypeEnum_SAFETYCUTOFF:
        m_out << ".SAFETYCUTOFF.";
        break;
    case IfcValveTypeEnum_STEAMTRAP:
        m_out << ".STEAMTRAP.";
        break;
    case IfcValveTypeEnum_STOPCOCK:
        m_out << ".STOPCOCK.";
        break;
    case IfcValveTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcValveTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcValveType(IfcValveType *value) {
    m_out << "#" << value->getKey() << "=IFCVALVETYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcValveTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVector(IfcVector *value) {
    m_out << "#" << value->getKey() << "=IFCVECTOR(";
    if (Step::isUnset(value->getOrientation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOrientation());
    }
    m_out << ",";
    if (Step::isUnset(value->getMagnitude())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMagnitude());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVertex(IfcVertex *value) {
    m_out << "#" << value->getKey() << "=IFCVERTEX(";
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVertexBasedTextureMap(IfcVertexBasedTextureMap *value) {
    m_out << "#" << value->getKey() << "=IFCVERTEXBASEDTEXTUREMAP(";
    if (Step::isUnset(value->getTextureVertices())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcTextureVertex_3_n::iterator step_it0 = (value->getTextureVertices()).begin();
            if ((value->getTextureVertices()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTextureVertices()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTexturePoints())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcCartesianPoint_3_n::iterator step_it0 = (value->getTexturePoints()).begin();
            if ((value->getTexturePoints()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getTexturePoints()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVertexLoop(IfcVertexLoop *value) {
    m_out << "#" << value->getKey() << "=IFCVERTEXLOOP(";
    if (Step::isUnset(value->getLoopVertex())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLoopVertex());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVertexPoint(IfcVertexPoint *value) {
    m_out << "#" << value->getKey() << "=IFCVERTEXPOINT(";
    if (Step::isUnset(value->getVertexGeometry())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getVertexGeometry());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcVibrationIsolatorTypeEnum(IfcVibrationIsolatorTypeEnum enumData) {
    switch(enumData) {
    case IfcVibrationIsolatorTypeEnum_COMPRESSION:
        m_out << ".COMPRESSION.";
        break;
    case IfcVibrationIsolatorTypeEnum_SPRING:
        m_out << ".SPRING.";
        break;
    case IfcVibrationIsolatorTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcVibrationIsolatorTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcVibrationIsolatorType(IfcVibrationIsolatorType *value) {
    m_out << "#" << value->getKey() << "=IFCVIBRATIONISOLATORTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcVibrationIsolatorTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVirtualElement(IfcVirtualElement *value) {
    m_out << "#" << value->getKey() << "=IFCVIRTUALELEMENT(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcVirtualGridIntersection(IfcVirtualGridIntersection *value) {
    m_out << "#" << value->getKey() << "=IFCVIRTUALGRIDINTERSECTION(";
    if (Step::isUnset(value->getIntersectingAxes())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcGridAxis_2_2::iterator step_it0 = (value->getIntersectingAxes()).begin();
            if ((value->getIntersectingAxes()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getIntersectingAxes()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getOffsetDistances())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcLengthMeasure_2_3::iterator step_it0 = (value->getOffsetDistances()).begin();
            if ((value->getOffsetDistances()).size()) {
                writeAttribute(*step_it0);
                for (step_it0++; step_it0 != (value->getOffsetDistances()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute(*step_it0);
                }
            }
        }
        m_out << ")";
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWall(IfcWall *value) {
    m_out << "#" << value->getKey() << "=IFCWALL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWallStandardCase(IfcWallStandardCase *value) {
    m_out << "#" << value->getKey() << "=IFCWALLSTANDARDCASE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcWallTypeEnum(IfcWallTypeEnum enumData) {
    switch(enumData) {
    case IfcWallTypeEnum_STANDARD:
        m_out << ".STANDARD.";
        break;
    case IfcWallTypeEnum_POLYGONAL:
        m_out << ".POLYGONAL.";
        break;
    case IfcWallTypeEnum_SHEAR:
        m_out << ".SHEAR.";
        break;
    case IfcWallTypeEnum_ELEMENTEDWALL:
        m_out << ".ELEMENTEDWALL.";
        break;
    case IfcWallTypeEnum_PLUMBINGWALL:
        m_out << ".PLUMBINGWALL.";
        break;
    case IfcWallTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcWallTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcWallType(IfcWallType *value) {
    m_out << "#" << value->getKey() << "=IFCWALLTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcWallTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcWasteTerminalTypeEnum(IfcWasteTerminalTypeEnum enumData) {
    switch(enumData) {
    case IfcWasteTerminalTypeEnum_FLOORTRAP:
        m_out << ".FLOORTRAP.";
        break;
    case IfcWasteTerminalTypeEnum_FLOORWASTE:
        m_out << ".FLOORWASTE.";
        break;
    case IfcWasteTerminalTypeEnum_GULLYSUMP:
        m_out << ".GULLYSUMP.";
        break;
    case IfcWasteTerminalTypeEnum_GULLYTRAP:
        m_out << ".GULLYTRAP.";
        break;
    case IfcWasteTerminalTypeEnum_GREASEINTERCEPTOR:
        m_out << ".GREASEINTERCEPTOR.";
        break;
    case IfcWasteTerminalTypeEnum_OILINTERCEPTOR:
        m_out << ".OILINTERCEPTOR.";
        break;
    case IfcWasteTerminalTypeEnum_PETROLINTERCEPTOR:
        m_out << ".PETROLINTERCEPTOR.";
        break;
    case IfcWasteTerminalTypeEnum_ROOFDRAIN:
        m_out << ".ROOFDRAIN.";
        break;
    case IfcWasteTerminalTypeEnum_WASTEDISPOSALUNIT:
        m_out << ".WASTEDISPOSALUNIT.";
        break;
    case IfcWasteTerminalTypeEnum_WASTETRAP:
        m_out << ".WASTETRAP.";
        break;
    case IfcWasteTerminalTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcWasteTerminalTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcWasteTerminalType(IfcWasteTerminalType *value) {
    m_out << "#" << value->getKey() << "=IFCWASTETERMINALTYPE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getElementType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getElementType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPredefinedType())) {
        m_out << "$";
    }
    else {
        writeIfcWasteTerminalTypeEnum(value->getPredefinedType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWaterProperties(IfcWaterProperties *value) {
    m_out << "#" << value->getKey() << "=IFCWATERPROPERTIES(";
    if (Step::isUnset(value->getMaterial())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMaterial());
    }
    m_out << ",";
    if (Step::isUnset(value->getIsPotable())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIsPotable());
    }
    m_out << ",";
    if (Step::isUnset(value->getHardness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getHardness());
    }
    m_out << ",";
    if (Step::isUnset(value->getAlkalinityConcentration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAlkalinityConcentration());
    }
    m_out << ",";
    if (Step::isUnset(value->getAcidityConcentration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getAcidityConcentration());
    }
    m_out << ",";
    if (Step::isUnset(value->getImpuritiesContent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getImpuritiesContent());
    }
    m_out << ",";
    if (Step::isUnset(value->getPHLevel())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPHLevel());
    }
    m_out << ",";
    if (Step::isUnset(value->getDissolvedSolidsContent())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDissolvedSolidsContent());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWindow(IfcWindow *value) {
    m_out << "#" << value->getKey() << "=IFCWINDOW(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectPlacement())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectPlacement());
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentation())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getRepresentation());
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallHeight())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallHeight());
    }
    m_out << ",";
    if (Step::isUnset(value->getOverallWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOverallWidth());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWindowLiningProperties(IfcWindowLiningProperties *value) {
    m_out << "#" << value->getKey() << "=IFCWINDOWLININGPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getLiningDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiningDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getLiningThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getLiningThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getTransomThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTransomThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getMullionThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getMullionThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFirstTransomOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFirstTransomOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondTransomOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSecondTransomOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getFirstMullionOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFirstMullionOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getSecondMullionOffset())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSecondMullionOffset());
    }
    m_out << ",";
    if (Step::isUnset(value->getShapeAspectStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShapeAspectStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcWindowPanelOperationEnum(IfcWindowPanelOperationEnum enumData) {
    switch(enumData) {
    case IfcWindowPanelOperationEnum_SIDEHUNGRIGHTHAND:
        m_out << ".SIDEHUNGRIGHTHAND.";
        break;
    case IfcWindowPanelOperationEnum_SIDEHUNGLEFTHAND:
        m_out << ".SIDEHUNGLEFTHAND.";
        break;
    case IfcWindowPanelOperationEnum_TILTANDTURNRIGHTHAND:
        m_out << ".TILTANDTURNRIGHTHAND.";
        break;
    case IfcWindowPanelOperationEnum_TILTANDTURNLEFTHAND:
        m_out << ".TILTANDTURNLEFTHAND.";
        break;
    case IfcWindowPanelOperationEnum_TOPHUNG:
        m_out << ".TOPHUNG.";
        break;
    case IfcWindowPanelOperationEnum_BOTTOMHUNG:
        m_out << ".BOTTOMHUNG.";
        break;
    case IfcWindowPanelOperationEnum_PIVOTHORIZONTAL:
        m_out << ".PIVOTHORIZONTAL.";
        break;
    case IfcWindowPanelOperationEnum_PIVOTVERTICAL:
        m_out << ".PIVOTVERTICAL.";
        break;
    case IfcWindowPanelOperationEnum_SLIDINGHORIZONTAL:
        m_out << ".SLIDINGHORIZONTAL.";
        break;
    case IfcWindowPanelOperationEnum_SLIDINGVERTICAL:
        m_out << ".SLIDINGVERTICAL.";
        break;
    case IfcWindowPanelOperationEnum_REMOVABLECASEMENT:
        m_out << ".REMOVABLECASEMENT.";
        break;
    case IfcWindowPanelOperationEnum_FIXEDCASEMENT:
        m_out << ".FIXEDCASEMENT.";
        break;
    case IfcWindowPanelOperationEnum_OTHEROPERATION:
        m_out << ".OTHEROPERATION.";
        break;
    case IfcWindowPanelOperationEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcWindowPanelProperties(IfcWindowPanelProperties *value) {
    m_out << "#" << value->getKey() << "=IFCWINDOWPANELPROPERTIES(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getOperationType())) {
        m_out << "$";
    }
    else {
        writeIfcWindowPanelOperationEnum(value->getOperationType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getPanelPosition())) {
        m_out << "$";
    }
    else {
        writeIfcWindowPanelPositionEnum(value->getPanelPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrameDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrameDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getFrameThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFrameThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getShapeAspectStyle())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getShapeAspectStyle());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcWindowStyleConstructionEnum(IfcWindowStyleConstructionEnum enumData) {
    switch(enumData) {
    case IfcWindowStyleConstructionEnum_ALUMINIUM:
        m_out << ".ALUMINIUM.";
        break;
    case IfcWindowStyleConstructionEnum_HIGH_GRADE_STEEL:
        m_out << ".HIGH_GRADE_STEEL.";
        break;
    case IfcWindowStyleConstructionEnum_STEEL:
        m_out << ".STEEL.";
        break;
    case IfcWindowStyleConstructionEnum_WOOD:
        m_out << ".WOOD.";
        break;
    case IfcWindowStyleConstructionEnum_ALUMINIUM_WOOD:
        m_out << ".ALUMINIUM_WOOD.";
        break;
    case IfcWindowStyleConstructionEnum_PLASTIC:
        m_out << ".PLASTIC.";
        break;
    case IfcWindowStyleConstructionEnum_OTHER_CONSTRUCTION:
        m_out << ".OTHER_CONSTRUCTION.";
        break;
    case IfcWindowStyleConstructionEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

void SPFWriter::writeIfcWindowStyleOperationEnum(IfcWindowStyleOperationEnum enumData) {
    switch(enumData) {
    case IfcWindowStyleOperationEnum_SINGLE_PANEL:
        m_out << ".SINGLE_PANEL.";
        break;
    case IfcWindowStyleOperationEnum_DOUBLE_PANEL_VERTICAL:
        m_out << ".DOUBLE_PANEL_VERTICAL.";
        break;
    case IfcWindowStyleOperationEnum_DOUBLE_PANEL_HORIZONTAL:
        m_out << ".DOUBLE_PANEL_HORIZONTAL.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_VERTICAL:
        m_out << ".TRIPLE_PANEL_VERTICAL.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_BOTTOM:
        m_out << ".TRIPLE_PANEL_BOTTOM.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_TOP:
        m_out << ".TRIPLE_PANEL_TOP.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_LEFT:
        m_out << ".TRIPLE_PANEL_LEFT.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_RIGHT:
        m_out << ".TRIPLE_PANEL_RIGHT.";
        break;
    case IfcWindowStyleOperationEnum_TRIPLE_PANEL_HORIZONTAL:
        m_out << ".TRIPLE_PANEL_HORIZONTAL.";
        break;
    case IfcWindowStyleOperationEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcWindowStyleOperationEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcWindowStyle(IfcWindowStyle *value) {
    m_out << "#" << value->getKey() << "=IFCWINDOWSTYLE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getApplicableOccurrence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getApplicableOccurrence());
    }
    m_out << ",";
    if (Step::isUnset(value->getHasPropertySets())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPropertySetDefinition_1_n::iterator step_it0 = (value->getHasPropertySets()).begin();
            if ((value->getHasPropertySets()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getHasPropertySets()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getRepresentationMaps())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            List_IfcRepresentationMap_1_n::iterator step_it0 = (value->getRepresentationMaps()).begin();
            if ((value->getRepresentationMaps()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getRepresentationMaps()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getTag())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTag());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getConstructionType())) {
        m_out << "$";
    }
    else {
        writeIfcWindowStyleConstructionEnum(value->getConstructionType());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getOperationType())) {
        m_out << "$";
    }
    else {
        writeIfcWindowStyleOperationEnum(value->getOperationType());
    }
    m_out << ",";
    if (Step::isUnset(value->getParameterTakesPrecedence())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getParameterTakesPrecedence());
    }
    m_out << ",";
    if (Step::isUnset(value->getSizeable())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getSizeable());
    }
    m_out << ");" << std::endl;
    return true;
}

void SPFWriter::writeIfcWorkControlTypeEnum(IfcWorkControlTypeEnum enumData) {
    switch(enumData) {
    case IfcWorkControlTypeEnum_ACTUAL:
        m_out << ".ACTUAL.";
        break;
    case IfcWorkControlTypeEnum_BASELINE:
        m_out << ".BASELINE.";
        break;
    case IfcWorkControlTypeEnum_PLANNED:
        m_out << ".PLANNED.";
        break;
    case IfcWorkControlTypeEnum_USERDEFINED:
        m_out << ".USERDEFINED.";
        break;
    case IfcWorkControlTypeEnum_NOTDEFINED:
        m_out << ".NOTDEFINED.";
        break;
        }
}

bool SPFWriter::visitIfcWorkControl(IfcWorkControl *value) {
    m_out << "#" << value->getKey() << "=IFCWORKCONTROL(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreators())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPerson_1_n::iterator step_it0 = (value->getCreators()).begin();
            if ((value->getCreators()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCreators()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDuration());
    }
    m_out << ",";
    if (Step::isUnset(value->getTotalFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getFinishTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFinishTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getWorkControlType())) {
        m_out << "$";
    }
    else {
        writeIfcWorkControlTypeEnum(value->getWorkControlType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedControlType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedControlType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWorkPlan(IfcWorkPlan *value) {
    m_out << "#" << value->getKey() << "=IFCWORKPLAN(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreators())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPerson_1_n::iterator step_it0 = (value->getCreators()).begin();
            if ((value->getCreators()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCreators()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDuration());
    }
    m_out << ",";
    if (Step::isUnset(value->getTotalFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getFinishTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFinishTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getWorkControlType())) {
        m_out << "$";
    }
    else {
        writeIfcWorkControlTypeEnum(value->getWorkControlType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedControlType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedControlType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcWorkSchedule(IfcWorkSchedule *value) {
    m_out << "#" << value->getKey() << "=IFCWORKSCHEDULE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ",";
    if (Step::isUnset(value->getIdentifier())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getIdentifier());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreationDate())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getCreationDate());
    }
    m_out << ",";
    if (Step::isUnset(value->getCreators())) {
        m_out << "$";
    }
    else {
        m_out << "(";
        {
            Set_IfcPerson_1_n::iterator step_it0 = (value->getCreators()).begin();
            if ((value->getCreators()).size()) {
                writeAttribute((*step_it0).get());
                for (step_it0++; step_it0 != (value->getCreators()).end(); step_it0++) {
                    m_out << ",";
                    writeAttribute((*step_it0).get());
                }
            }
        }
        m_out << ")";
    }
    m_out << ",";
    if (Step::isUnset(value->getPurpose())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPurpose());
    }
    m_out << ",";
    if (Step::isUnset(value->getDuration())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDuration());
    }
    m_out << ",";
    if (Step::isUnset(value->getTotalFloat())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getTotalFloat());
    }
    m_out << ",";
    if (Step::isUnset(value->getStartTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getStartTime());
    }
    m_out << ",";
    if (Step::isUnset(value->getFinishTime())) {
        m_out << "$";
    }
    else {
        writeIfcDateTimeSelect(value->getFinishTime());
    }
    m_out << ",";
    if (Step::isUnsetEnum(value->getWorkControlType())) {
        m_out << "$";
    }
    else {
        writeIfcWorkControlTypeEnum(value->getWorkControlType());
    }
    m_out << ",";
    if (Step::isUnset(value->getUserDefinedControlType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getUserDefinedControlType());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcZShapeProfileDef(IfcZShapeProfileDef *value) {
    m_out << "#" << value->getKey() << "=IFCZSHAPEPROFILEDEF(";
    if (Step::isUnsetEnum(value->getProfileType())) {
        m_out << "$";
    }
    else {
        writeIfcProfileTypeEnum(value->getProfileType());
    }
    m_out << ",";
    if (Step::isUnset(value->getProfileName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getProfileName());
    }
    m_out << ",";
    if (Step::isUnset(value->getPosition())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getPosition());
    }
    m_out << ",";
    if (Step::isUnset(value->getDepth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDepth());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeWidth())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeWidth());
    }
    m_out << ",";
    if (Step::isUnset(value->getWebThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getWebThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFlangeThickness())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFlangeThickness());
    }
    m_out << ",";
    if (Step::isUnset(value->getFilletRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getFilletRadius());
    }
    m_out << ",";
    if (Step::isUnset(value->getEdgeRadius())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getEdgeRadius());
    }
    m_out << ");" << std::endl;
    return true;
}

bool SPFWriter::visitIfcZone(IfcZone *value) {
    m_out << "#" << value->getKey() << "=IFCZONE(";
    if (Step::isUnset(value->getGlobalId())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getGlobalId());
    }
    m_out << ",";
    if (Step::isUnset(value->getOwnerHistory())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getOwnerHistory());
    }
    m_out << ",";
    if (Step::isUnset(value->getName())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getName());
    }
    m_out << ",";
    if (Step::isUnset(value->getDescription())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getDescription());
    }
    m_out << ",";
    if (Step::isUnset(value->getObjectType())) {
        m_out << "$";
    }
    else {
        writeAttribute(value->getObjectType());
    }
    m_out << ");" << std::endl;
    return true;
}

